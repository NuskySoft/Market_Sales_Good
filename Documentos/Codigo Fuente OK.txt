===== FILE: ArticuloDao.kt
// app/src/main/java/es/nuskysoftware/marketsales/data/local/dao/ArticuloDao.kt
package es.nuskysoftware.marketsales.data.local.dao

import androidx.room.*
import es.nuskysoftware.marketsales.data.local.entity.ArticuloEntity
import kotlinx.coroutines.flow.Flow

/**
 * ArticuloDao V11 - Market Sales
 *
 * DIFERENCIAS CON CAJA MERCADILLOS:
 * - Todas las consultas filtradas por userId
 * - Arquitectura híbrida con sincronizadoFirebase
 * - Compatibilidad con sistema "Reloj Suizo"
 */
@Dao
interface ArticuloDao {

    // ========== OPERACIONES BÁSICAS ==========

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertArticulo(articulo: ArticuloEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOrUpdate(articulo: ArticuloEntity)

    @Update
    suspend fun updateArticulo(articulo: ArticuloEntity)

    @Delete
    suspend fun deleteArticulo(articulo: ArticuloEntity)

    // ========== CONSULTAS FILTRADAS POR USUARIO ==========

    /**
     * Obtiene todos los artículos del usuario actual ordenados por nombre
     */
    @Query("SELECT * FROM articulos WHERE userId = :userId AND activo = 1 ORDER BY nombre ASC")
    fun getArticulosByUser(userId: String): Flow<List<ArticuloEntity>>

    /**
     * Obtiene artículos filtrados por categoría
     */
    @Query("SELECT * FROM articulos WHERE userId = :userId AND idCategoria = :categoriaId AND activo = 1 ORDER BY nombre ASC")
    fun getArticulosByUserAndCategoria(userId: String, categoriaId: String): Flow<List<ArticuloEntity>>

    /**
     * Obtiene un artículo específico por ID
     */
    @Query("SELECT * FROM articulos WHERE idArticulo = :id")
    suspend fun getArticuloById(id: String): ArticuloEntity?

    /**
     * Elimina artículo por ID
     */
    @Query("DELETE FROM articulos WHERE idArticulo = :id")
    suspend fun deleteArticuloById(id: String)

    // ========== SINCRONIZACIÓN HÍBRIDA ==========

    /**
     * Obtiene artículos no sincronizados de un usuario específico
     */
    @Query("SELECT * FROM articulos WHERE userId = :userId AND sincronizadoFirebase = 0")
    suspend fun getArticulosNoSincronizadosByUser(userId: String): List<ArticuloEntity>

    /**
     * Marca artículo como sincronizado
     */
    @Query("UPDATE articulos SET sincronizadoFirebase = 1, lastModified = :timestamp WHERE idArticulo = :id")
    suspend fun marcarComoSincronizado(id: String, timestamp: Long = System.currentTimeMillis())

    /**
     * Marca artículo como no sincronizado (para cambios locales)
     */
    @Query("UPDATE articulos SET sincronizadoFirebase = 0 WHERE idArticulo = :id")
    suspend fun marcarComoNoSincronizado(id: String)

    /**
     * Obtiene la versión actual de un artículo
     */
    @Query("SELECT version FROM articulos WHERE idArticulo = :id")
    suspend fun getArticuloVersion(id: String): Long?

    // ========== UTILIDADES ==========

    /**
     * Cuenta el total de artículos de un usuario
     */
    @Query("SELECT COUNT(*) FROM articulos WHERE userId = :userId AND activo = 1")
    suspend fun getArticuloCountByUser(userId: String): Int

    /**
     * Verifica si existe un artículo con el mismo nombre para un usuario
     */
    @Query("SELECT COUNT(*) > 0 FROM articulos WHERE userId = :userId AND nombre = :nombre AND activo = 1 AND idArticulo != :excludeId")
    suspend fun existeArticuloConNombre(userId: String, nombre: String, excludeId: String = ""): Boolean

    /**
     * Obtiene nombres únicos de artículos para autocompletado
     */
    @Query("SELECT DISTINCT nombre FROM articulos WHERE userId = :userId AND activo = 1 ORDER BY nombre ASC")
    suspend fun getNombresArticulosUnicos(userId: String): List<String>

    /**
     * Busca artículos por nombre
     */
    @Query("SELECT * FROM articulos WHERE userId = :userId AND nombre LIKE '%' || :query || '%' AND activo = 1 ORDER BY nombre ASC")
    fun searchArticulosByNombre(userId: String, query: String): Flow<List<ArticuloEntity>>

    // ========== MANTENIMIENTO ==========

    /**
     * Elimina artículos inactivos antiguos
     */
    @Query("DELETE FROM articulos WHERE userId = :userId AND activo = 0 AND lastModified < :limiteFecha")
    suspend fun limpiarArticulosInactivosAntiguos(userId: String, limiteFecha: Long)

    /**
     * Resetea sincronización para forzar re-sync
     */
    @Query("UPDATE articulos SET sincronizadoFirebase = 0 WHERE userId = :userId")
    suspend fun resetearSincronizacion(userId: String)
}
===== END
===== FILE: CategoriaDao.kt
// app/src/main/java/es/nuskysoftware/marketsales/data/local/dao/CategoriaDao.kt
package es.nuskysoftware.marketsales.data.local.dao

import androidx.room.*
import es.nuskysoftware.marketsales.data.local.entity.CategoriaEntity
import kotlinx.coroutines.flow.Flow

/**
 * CategoriaDao V11 - Market Sales
 *
 * DIFERENCIAS CON CAJA MERCADILLOS:
 * - Todas las consultas filtradas por userId
 * - Arquitectura híbrida con sincronizadoFirebase
 * - Compatibilidad con sistema "Reloj Suizo"
 */
@Dao
interface CategoriaDao {

    // ========== OPERACIONES BÁSICAS ==========

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertCategoria(categoria: CategoriaEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOrUpdate(categoria: CategoriaEntity)

    @Update
    suspend fun updateCategoria(categoria: CategoriaEntity)

    @Delete
    suspend fun deleteCategoria(categoria: CategoriaEntity)

    // ========== CONSULTAS FILTRADAS POR USUARIO ==========

    /**
     * Obtiene todas las categorías del usuario actual ordenadas por nombre
     */
    @Query("SELECT * FROM categorias WHERE userId = :userId AND activa = 1 ORDER BY nombre ASC")
    fun getCategoriasByUser(userId: String): Flow<List<CategoriaEntity>>

    /**
     * Obtiene una categoría específica por ID
     */
    @Query("SELECT * FROM categorias WHERE idCategoria = :id")
    suspend fun getCategoriaById(id: String): CategoriaEntity?

    /**
     * Elimina categoría por ID
     */
    @Query("DELETE FROM categorias WHERE idCategoria = :id")
    suspend fun deleteCategoriaById(id: String)

    // ========== SINCRONIZACIÓN HÍBRIDA ==========

    /**
     * Obtiene categorías no sincronizadas de un usuario específico
     */
    @Query("SELECT * FROM categorias WHERE userId = :userId AND sincronizadoFirebase = 0")
    suspend fun getCategoriasNoSincronizadasByUser(userId: String): List<CategoriaEntity>

    /**
     * Marca categoría como sincronizada
     */
    @Query("UPDATE categorias SET sincronizadoFirebase = 1, lastModified = :timestamp WHERE idCategoria = :id")
    suspend fun marcarComoSincronizada(id: String, timestamp: Long = System.currentTimeMillis())

    /**
     * Marca categoría como no sincronizada (para cambios locales)
     */
    @Query("UPDATE categorias SET sincronizadoFirebase = 0 WHERE idCategoria = :id")
    suspend fun marcarComoNoSincronizada(id: String)

    /**
     * Obtiene la versión actual de una categoría
     */
    @Query("SELECT version FROM categorias WHERE idCategoria = :id")
    suspend fun getCategoriaVersion(id: String): Long?

    // ========== UTILIDADES ==========

    /**
     * Cuenta el total de categorías de un usuario
     */
    @Query("SELECT COUNT(*) FROM categorias WHERE userId = :userId AND activa = 1")
    suspend fun getCategoriaCountByUser(userId: String): Int

    /**
     * Verifica si existe una categoría con el mismo nombre para un usuario
     */
    @Query("SELECT COUNT(*) > 0 FROM categorias WHERE userId = :userId AND nombre = :nombre AND activa = 1 AND idCategoria != :excludeId")
    suspend fun existeCategoriaConNombre(userId: String, nombre: String, excludeId: String = ""): Boolean

    /**
     * Obtiene nombres únicos de categorías para autocompletado
     */
    @Query("SELECT DISTINCT nombre FROM categorias WHERE userId = :userId AND activa = 1 ORDER BY nombre ASC")
    suspend fun getNombresCategoriasUnicas(userId: String): List<String>

    // ========== MANTENIMIENTO ==========

    /**
     * Elimina categorías inactivas antiguas
     */
    @Query("DELETE FROM categorias WHERE userId = :userId AND activa = 0 AND lastModified < :limiteFecha")
    suspend fun limpiarCategoriasInactivasAntiguas(userId: String, limiteFecha: Long)

    /**
     * Resetea sincronización para forzar re-sync
     */
    @Query("UPDATE categorias SET sincronizadoFirebase = 0 WHERE userId = :userId")
    suspend fun resetearSincronizacion(userId: String)
}
===== END
===== FILE: ConfiguracionDao.kt
// app/src/main/java/es/nuskysoftware/marketsales/data/local/dao/ConfiguracionDao.kt
package es.nuskysoftware.marketsales.data.local.dao

import androidx.room.*
import kotlinx.coroutines.flow.Flow
import es.nuskysoftware.marketsales.data.local.entity.ConfiguracionEntity

/**
 * ConfiguracionDao V10 - ACTUALIZADO PARA SISTEMA MONOUSUARIO
 *
 * CAMBIOS V10:
 * - Agregados métodos para usuarioLogueado
 * - Agregados métodos para sincronización (version, lastModified)
 * - Eliminados métodos obsoletos (usuarioPassword, usuarioEmail, usuarioId, versionApp)
 * - Mantenidos métodos legacy marcados como @Deprecated
 */
@Dao
interface ConfiguracionDao {

    // ========== MÉTODOS BÁSICOS (sin cambios) ==========

    @Query("SELECT * FROM configuracion WHERE id = 1")
    suspend fun getConfiguracion(): ConfiguracionEntity?

    @Query("SELECT * FROM configuracion WHERE id = 1")
    suspend fun getConfiguracionSync(): ConfiguracionEntity?

    @Query("SELECT * FROM configuracion WHERE id = 1")
    fun getConfiguracionFlow(): Flow<ConfiguracionEntity?>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertarConfiguracion(configuracion: ConfiguracionEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOrUpdate(configuracion: ConfiguracionEntity)

    @Update
    suspend fun actualizarConfiguracion(configuracion: ConfiguracionEntity)

    @Query("DELETE FROM configuracion")
    suspend fun eliminarTodasLasConfiguraciones()

    // ========== CONFIGURACIÓN GLOBAL V10 ==========

    /** Actualiza la moneda (común a todos los usuarios) */
    @Query("UPDATE configuracion SET moneda = :moneda, version = version + 1, lastModified = :timestamp, pendienteSync = 1 WHERE id = 1")
    suspend fun updateMoneda(moneda: String, timestamp: Long = System.currentTimeMillis())

    /** Actualiza el idioma (común a todos los usuarios) */
    @Query("UPDATE configuracion SET idioma = :idioma, version = version + 1, lastModified = :timestamp, pendienteSync = 1 WHERE id = 1")
    suspend fun updateIdioma(idioma: String, timestamp: Long = System.currentTimeMillis())

    /** Actualiza la fuente (común a todos los usuarios) */
    @Query("UPDATE configuracion SET fuente = :fuente, version = version + 1, lastModified = :timestamp, pendienteSync = 1 WHERE id = 1")
    suspend fun updateFuente(fuente: String, timestamp: Long = System.currentTimeMillis())

    /** Actualiza el tema oscuro (común a todos los usuarios) */
    @Query("UPDATE configuracion SET temaOscuro = :esTemaOscuro, version = version + 1, lastModified = :timestamp, pendienteSync = 1 WHERE id = 1")
    suspend fun updateTemaOscuro(esTemaOscuro: Boolean, timestamp: Long = System.currentTimeMillis())

    // ========== USUARIO LOGUEADO V10 ==========

    /** Establece el usuario actualmente logueado */
    @Query("UPDATE configuracion SET usuarioLogueado = :usuarioUid, version = version + 1, lastModified = :timestamp WHERE id = 1")
    suspend fun setUsuarioLogueado(usuarioUid: String, timestamp: Long = System.currentTimeMillis())

    /** Obtiene el UID del usuario actualmente logueado */
    @Query("SELECT usuarioLogueado FROM configuracion WHERE id = 1")
    suspend fun getUsuarioLogueado(): String?

    /** Flow que emite el usuario logueado */
    @Query("SELECT usuarioLogueado FROM configuracion WHERE id = 1")
    fun getUsuarioLogueadoFlow(): Flow<String?>

    /** Verifica si es usuario por defecto */
    @Query("SELECT usuarioLogueado = 'usuario_default' FROM configuracion WHERE id = 1")
    suspend fun isUsuarioDefault(): Boolean

    // ========== SINCRONIZACIÓN V10 ==========

    /** Marca si hay pendiente de sincronizar en Firebase */
    @Query("UPDATE configuracion SET pendienteSync = :pendiente WHERE id = 1")
    suspend fun updatePendienteSync(pendiente: Boolean)

    /** Flujo que emite true/false según si hay pendienteSync */
    @Query("SELECT pendienteSync FROM configuracion WHERE id = 1")
    fun getPendienteSyncFlow(): Flow<Boolean>

    /** Actualiza campos de sincronización después de sync exitoso */
    @Query("UPDATE configuracion SET version = :version, lastModified = :timestamp, pendienteSync = 0 WHERE id = 1")
    suspend fun markSyncSuccessful(version: Long, timestamp: Long = System.currentTimeMillis())

    /** Obtiene versión actual para resolución de conflictos */
    @Query("SELECT version FROM configuracion WHERE id = 1")
    suspend fun getCurrentVersion(): Long?

    /** Obtiene timestamp de última modificación */
    @Query("SELECT lastModified FROM configuracion WHERE id = 1")
    suspend fun getLastModified(): Long?

    // ========== MÉTODOS LEGACY (mantener para compatibilidad) ==========

    /** Actualiza la fecha de última sincronización */
    @Query("UPDATE configuracion SET fechaUltimaSync = :fecha WHERE id = 1")
    suspend fun updateFechaUltimaSync(fecha: String?)

    /** Actualiza el último dispositivo */
    @Query("UPDATE configuracion SET ultimoDispositivo = :dispositivo WHERE id = 1")
    suspend fun updateUltimoDispositivo(dispositivo: String?)

    /** Actualiza el número de versión de la app */
    @Query("UPDATE configuracion SET numeroVersion = :version WHERE id = 1")
    suspend fun updateNumeroVersion(version: String)

    // ========== MÉTODOS OBSOLETOS V10 (mantener por compatibilidad) ==========

    @Deprecated("Campo eliminado en V10 - usar UserRepository para gestionar usuarios", ReplaceWith("UserRepository.updateUserPassword()"))
    @Query("SELECT 1") // Query dummy que no hace nada
    suspend fun updateUsuarioPassword(password: String?) { /* No-op */ }

    @Deprecated("Campo eliminado en V10 - usar UserRepository para gestionar usuarios", ReplaceWith("UserRepository.updateUserEmail()"))
    @Query("SELECT 1") // Query dummy que no hace nada
    suspend fun updateUsuarioEmail(email: String?) { /* No-op */ }

    @Deprecated("Campo eliminado en V10 - usar setUsuarioLogueado()", ReplaceWith("setUsuarioLogueado(usuarioId)"))
    @Query("SELECT 1") // Query dummy que no hace nada
    suspend fun updateUsuarioId(usuarioId: String?) { /* No-op */ }

    @Deprecated("Campo eliminado en V10 - usar UserRepository.updateUserPremium()", ReplaceWith("UserRepository.updateUserPremium()"))
    @Query("SELECT 1") // Query dummy que no hace nada
    suspend fun updateVersionApp(version: Int) { /* No-op */ }
}

===== END
===== FILE: MercadilloDao.kt
// app/src/main/java/es/nuskysoftware/marketsales/data/local/dao/MercadilloDao.kt
package es.nuskysoftware.marketsales.data.local.dao

import androidx.room.*
import es.nuskysoftware.marketsales.data.local.entity.MercadilloEntity
import kotlinx.coroutines.flow.Flow

/**
 * MercadilloDao V11 - Market Sales
 *
 * DIFERENCIAS CON CAJA MERCADILLOS:
 * - Todas las consultas filtradas por userId
 * - Arquitectura híbrida con sincronizadoFirebase
 * - Compatibilidad con sistema "Reloj Suizo"
 * - Métodos específicos para gestión de estados y saldos
 */
@Dao
interface MercadilloDao {

    // ========== OPERACIONES BÁSICAS ==========

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertMercadillo(mercadillo: MercadilloEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOrUpdate(mercadillo: MercadilloEntity)

    @Update
    suspend fun updateMercadillo(mercadillo: MercadilloEntity)

    @Delete
    suspend fun deleteMercadillo(mercadillo: MercadilloEntity)

    // ========== CONSULTAS FILTRADAS POR USUARIO ==========

    // Agregar en MercadilloDao.kt:

    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND fecha = :fecha AND activo = 1")
    suspend fun getMercadillosByUserAndFecha(userId: String, fecha: String): List<MercadilloEntity>

    /**
     * Obtiene todos los mercadillos del usuario actual ordenados por fecha DESC
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND activo = 1 ORDER BY fecha DESC, horaInicio DESC")
    fun getMercadillosByUser(userId: String): Flow<List<MercadilloEntity>>

    /**
     * Obtiene mercadillos de un mes específico para el calendario
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND fecha LIKE :mesPattern AND activo = 1 ORDER BY fecha ASC")
    fun getMercadillosByUserAndMes(userId: String, mesPattern: String): Flow<List<MercadilloEntity>>

    /**
     * Obtiene un mercadillo específico por ID
     */
    @Query("SELECT * FROM mercadillos WHERE idMercadillo = :id")
    suspend fun getMercadilloById(id: String): MercadilloEntity?

    /**
     * Elimina mercadillo por ID
     */
    @Query("DELETE FROM mercadillos WHERE idMercadillo = :id")
    suspend fun deleteMercadilloById(id: String)

    // ========== CONSULTAS POR ESTADO ==========

    /**
     * Obtiene mercadillos por estado específico
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND estado = :estado AND activo = 1 ORDER BY fecha ASC")
    fun getMercadillosByUserAndEstado(userId: String, estado: Int): Flow<List<MercadilloEntity>>

    /**
     * Obtiene mercadillos programados parcialmente (sin saldo inicial)
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND saldoInicial IS NULL AND activo = 1 ORDER BY fecha ASC")
    fun getMercadillosProgramadosParciales(userId: String): Flow<List<MercadilloEntity>>

    /**
     * Obtiene mercadillos pendientes de arqueo
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND pendienteArqueo = 1 AND activo = 1 ORDER BY fecha ASC")
    fun getMercadillosPendientesArqueo(userId: String): Flow<List<MercadilloEntity>>

    /**
     * Obtiene mercadillos pendientes de asignar saldo
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND pendienteAsignarSaldo = 1 AND activo = 1 ORDER BY fecha ASC")
    fun getMercadillosPendientesAsignarSaldo(userId: String): Flow<List<MercadilloEntity>>

    // ========== CONSULTAS PARA LÓGICA DE NEGOCIO ==========

    /**
     * Obtiene el próximo mercadillo programado
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND fecha >= :fechaActual AND activo = 1 ORDER BY fecha ASC, horaInicio ASC LIMIT 1")
    suspend fun getProximoMercadillo(userId: String, fechaActual: String): MercadilloEntity?

    /**
     * Obtiene mercadillos de una fecha específica
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND fecha = :fecha AND activo = 1 ORDER BY horaInicio ASC")
    suspend fun getMercadillosByFecha(userId: String, fecha: String): List<MercadilloEntity>

    /**
     * Obtiene el último mercadillo con saldo final para asignación automática
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND saldoFinal IS NOT NULL AND pendienteAsignarSaldo = 1 AND activo = 1 ORDER BY fecha DESC, horaFin DESC LIMIT 1")
    suspend fun getUltimoMercadilloConSaldoFinal(userId: String): MercadilloEntity?

    /**
     * Verifica si existe un mercadillo en la misma fecha y hora
     */
    @Query("SELECT COUNT(*) > 0 FROM mercadillos WHERE userId = :userId AND fecha = :fecha AND horaInicio = :horaInicio AND activo = 1 AND idMercadillo != :excludeId")
    suspend fun existeMercadilloEnFechaHora(userId: String, fecha: String, horaInicio: String, excludeId: String = ""): Boolean

    // ========== SINCRONIZACIÓN HÍBRIDA ==========

    /**
     * Obtiene mercadillos no sincronizados de un usuario específico
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND sincronizadoFirebase = 0")
    suspend fun getMercadillosNoSincronizadosByUser(userId: String): List<MercadilloEntity>

    /**
     * Marca mercadillo como sincronizado
     */
    @Query("UPDATE mercadillos SET sincronizadoFirebase = 1, lastModified = :timestamp WHERE idMercadillo = :id")
    suspend fun marcarComoSincronizado(id: String, timestamp: Long = System.currentTimeMillis())

    /**
     * Marca mercadillo como no sincronizado (para cambios locales)
     */
    @Query("UPDATE mercadillos SET sincronizadoFirebase = 0 WHERE idMercadillo = :id")
    suspend fun marcarComoNoSincronizado(id: String)

    /**
     * Obtiene la versión actual de un mercadillo
     */
    @Query("SELECT version FROM mercadillos WHERE idMercadillo = :id")
    suspend fun getMercadilloVersion(id: String): Long?

    // ========== ACTUALIZACIÓN DE ESTADOS Y SALDOS ==========

    /**
     * Asigna saldo inicial a un mercadillo
     */
    @Query("UPDATE mercadillos SET saldoInicial = :saldoInicial, estado = 2, version = version + 1, lastModified = :timestamp, sincronizadoFirebase = 0 WHERE idMercadillo = :id")
    suspend fun asignarSaldoInicial(id: String, saldoInicial: Double, timestamp: Long = System.currentTimeMillis())

    /**
     * Actualiza estado del mercadillo
     */
    @Query("UPDATE mercadillos SET estado = :nuevoEstado, version = version + 1, lastModified = :timestamp, sincronizadoFirebase = 0 WHERE idMercadillo = :id")
    suspend fun actualizarEstado(id: String, nuevoEstado: Int, timestamp: Long = System.currentTimeMillis())

    /**
     * Realiza arqueo de caja
     */
    @Query("UPDATE mercadillos SET arqueoCaja = :arqueoCaja, saldoFinal = :saldoFinal, pendienteArqueo = 0, pendienteAsignarSaldo = 1, estado = 5, version = version + 1, lastModified = :timestamp, sincronizadoFirebase = 0 WHERE idMercadillo = :id")
    suspend fun realizarArqueoCaja(id: String, arqueoCaja: Double, saldoFinal: Double, timestamp: Long = System.currentTimeMillis())

    /**
     * Marca saldo como asignado (mercadillo cerrado completo)
     */
    @Query("UPDATE mercadillos SET pendienteAsignarSaldo = 0, estado = 6, version = version + 1, lastModified = :timestamp, sincronizadoFirebase = 0 WHERE idMercadillo = :id")
    suspend fun marcarSaldoAsignado(id: String, timestamp: Long = System.currentTimeMillis())

    /**
     * Actualiza totales de ventas y gastos (calculados desde otras tablas)
     */
    @Query("UPDATE mercadillos SET totalVentas = :totalVentas, totalGastos = :totalGastos, arqueoMercadillo = :arqueoMercadillo, version = version + 1, lastModified = :timestamp, sincronizadoFirebase = 0 WHERE idMercadillo = :id")
    suspend fun actualizarTotales(id: String, totalVentas: Double, totalGastos: Double, arqueoMercadillo: Double, timestamp: Long = System.currentTimeMillis())

    /**
     * Cancela un mercadillo
     */
    @Query("UPDATE mercadillos SET estado = 7, activo = 0, version = version + 1, lastModified = :timestamp, sincronizadoFirebase = 0 WHERE idMercadillo = :id")
    suspend fun cancelarMercadillo(id: String, timestamp: Long = System.currentTimeMillis())

    // ========== UTILIDADES ==========

    /**
     * Cuenta el total de mercadillos de un usuario
     */
    @Query("SELECT COUNT(*) FROM mercadillos WHERE userId = :userId AND activo = 1")
    suspend fun getMercadilloCountByUser(userId: String): Int

    /**
     * Obtiene estadísticas básicas de mercadillos por estado
     */
    @Query("SELECT estado, COUNT(*) as cantidad FROM mercadillos WHERE userId = :userId AND activo = 1 GROUP BY estado")
    suspend fun getEstadisticasPorEstado(userId: String): List<EstadisticaEstado>

    // ========== MANTENIMIENTO ==========

    /**
     * Elimina mercadillos cancelados antiguos
     */
    @Query("DELETE FROM mercadillos WHERE userId = :userId AND estado = 7 AND lastModified < :limiteFecha")
    suspend fun limpiarMercadillosCanceladosAntiguos(userId: String, limiteFecha: Long)

    /**
     * Resetea sincronización para forzar re-sync
     */
    @Query("UPDATE mercadillos SET sincronizadoFirebase = 0 WHERE userId = :userId")
    suspend fun resetearSincronizacion(userId: String)

    // AGREGAR ESTA FUNCIÓN AL MercadilloDao.kt

    /**
     * Obtiene todos los mercadillos desde una fecha específica en adelante
     * Ordenados por fecha ASC y luego por hora de inicio ASC
     */
    @Query("""
    SELECT * FROM mercadillos 
    WHERE userId = :userId 
    AND fecha >= :fechaActual 
    AND activo = 1 
    ORDER BY fecha ASC, horaInicio ASC
""")
    suspend fun getMercadillosDesdeHoy(userId: String, fechaActual: String): List<MercadilloEntity>

}




/**
 * Data class para estadísticas por estado
 */
data class EstadisticaEstado(
    val estado: Int,
    val cantidad: Int
)

===== END
===== FILE: RecibosDao.kt
// app/src/main/java/es/nuskysoftware/marketsales/data/local/dao/RecibosDao.kt
package es.nuskysoftware.marketsales.data.local.dao

import androidx.room.*
import es.nuskysoftware.marketsales.data.local.entity.ReciboEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface RecibosDao {

    @Query("SELECT * FROM recibos WHERE idMercadillo = :idMercadillo ORDER BY fechaHora DESC")
    fun obtenerRecibosPorMercadillo(idMercadillo: String): Flow<List<ReciboEntity>>

    @Query("SELECT * FROM recibos WHERE idRecibo = :idRecibo")
    suspend fun obtenerReciboPorId(idRecibo: String): ReciboEntity?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertarRecibo(recibo: ReciboEntity)

    @Update
    suspend fun actualizarRecibo(recibo: ReciboEntity)

    @Delete
    suspend fun eliminarRecibo(recibo: ReciboEntity)

    @Query("DELETE FROM recibos WHERE idMercadillo = :idMercadillo")
    suspend fun eliminarRecibosPorMercadillo(idMercadillo: String)
}

===== END
===== FILE: UserDao.kt
// app/src/main/java/es/nuskysoftware/marketsales/data/local/dao/UserDao.kt
package es.nuskysoftware.marketsales.data.local.dao

import androidx.room.*
import kotlinx.coroutines.flow.Flow
import es.nuskysoftware.marketsales.data.local.entity.UserEntity

/**
 * ✅ UserDao COMPLETO con todos los métodos que necesita UserRepository
 */
@Dao
interface UserDao {

    // ========== MÉTODOS BÁSICOS ==========
    @Query("SELECT * FROM usuarios WHERE uid = :uid")
    suspend fun getUserById(uid: String): UserEntity?

    @Query("SELECT * FROM usuarios WHERE uid = :uid")
    suspend fun getUserByIdSync(uid: String): UserEntity?

    @Query("SELECT * FROM usuarios WHERE uid = :uid")
    fun getUserByIdFlow(uid: String): Flow<UserEntity?>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertUser(user: UserEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOrUpdate(user: UserEntity)

    @Update
    suspend fun updateUser(user: UserEntity)

    @Delete
    suspend fun deleteUser(user: UserEntity)

    // ========== MÉTODOS FALTANTES PARA UserRepository ==========

    /**
     * Obtener usuario actual (dummy - UserRepository lo maneja)
     */
    @Query("SELECT * FROM usuarios WHERE uid != 'dummy'")
    fun getCurrentUserFlow(): Flow<UserEntity?>

    /**
     * Obtener usuarios pendientes de sincronización
     */
    @Query("SELECT * FROM usuarios WHERE sincronizadoFirebase = 0")
    suspend fun getUsersPendingSync(): List<UserEntity>

    /**
     * Actualizar estado Premium del usuario
     */
    @Query("UPDATE usuarios SET esPremium = :esPremium WHERE uid = :uid")
    suspend fun updateUserPremium(uid: String, esPremium: Boolean)

    /**
     * Actualizar email del usuario
     */
    @Query("UPDATE usuarios SET email = :email WHERE uid = :uid")
    suspend fun updateUserEmail(uid: String, email: String)

    /**
     * Actualizar nombre del usuario
     */
    @Query("UPDATE usuarios SET displayName = :displayName WHERE uid = :uid")
    suspend fun updateUserDisplayName(uid: String, displayName: String)

    /**
     * Actualizar foto del usuario
     */
    @Query("UPDATE usuarios SET photoUrl = :photoUrl WHERE uid = :uid")
    suspend fun updateUserPhotoUrl(uid: String, photoUrl: String)

    /**
     * Obtener todos los usuarios Premium
     */
    @Query("SELECT * FROM usuarios WHERE esPremium = 1 AND activo = 1")
    suspend fun getAllPremiumUsers(): List<UserEntity>

    /**
     * Obtener todos los usuarios Free
     */
    @Query("SELECT * FROM usuarios WHERE esPremium = 0 AND activo = 1")
    suspend fun getAllFreeUsers(): List<UserEntity>

    /**
     * Marcar usuario como sincronizado exitosamente
     */
    @Query("UPDATE usuarios SET sincronizadoFirebase = 1, version = :newVersion WHERE uid = :uid")
    suspend fun markUserSyncSuccessful(uid: String, newVersion: Long)

    /**
     * Actualizar fecha de última sincronización
     */
    @Query("UPDATE usuarios SET fechaUltimaSync = :fecha WHERE uid = :uid")
    suspend fun updateFechaUltimaSync(uid: String, fecha: String)

    /**
     * Obtener versión de usuario
     */
    @Query("SELECT version FROM usuarios WHERE uid = :uid")
    suspend fun getUserVersion(uid: String): Long?

    // ========== MÉTODOS EXISTENTES ==========
    @Query("SELECT * FROM usuarios WHERE email = :email")
    suspend fun getUserByEmail(email: String): UserEntity?

    @Query("SELECT * FROM usuarios WHERE activo = 1")
    suspend fun getAllActiveUsers(): List<UserEntity>

    // En UserDao.kt - Alternativa más robusta:

    @Query("UPDATE usuarios SET displayName = :displayName, email = :email WHERE uid = :userId")
    suspend fun updateUserProfile(userId: String, displayName: String, email: String): Int

    // Método adicional para verificar si se actualizó correctamente
    @Query("SELECT COUNT(*) FROM usuarios WHERE uid = :userId")
    suspend fun userExists(userId: String): Int

    @Query("UPDATE usuarios SET sincronizadoFirebase = 0 WHERE uid = :uid")
    suspend fun markUserNotSynced(uid: String)
}


===== END
===== FILE: LineasVentaDao.kt

// app/src/main/java/es/nuskysoftware/marketsales/data/local/dao/LineasVentaDao.kt
package es.nuskysoftware.marketsales.data.local.dao

import androidx.room.*
import es.nuskysoftware.marketsales.data.local.entity.LineaVentaEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface LineasVentaDao {

    @Query("SELECT * FROM lineas_venta WHERE idRecibo = :idRecibo ORDER BY numeroLinea")
    fun obtenerLineasPorRecibo(idRecibo: String): Flow<List<LineaVentaEntity>>

    @Query("SELECT * FROM lineas_venta WHERE idMercadillo = :idMercadillo ORDER BY numeroLinea")
    fun obtenerLineasPorMercadillo(idMercadillo: String): Flow<List<LineaVentaEntity>>

    @Query("SELECT * FROM lineas_venta WHERE idLinea = :idLinea")
    suspend fun obtenerLineaPorId(idLinea: String): LineaVentaEntity?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertarLinea(linea: LineaVentaEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertarLineas(lineas: List<LineaVentaEntity>)

    @Update
    suspend fun actualizarLinea(linea: LineaVentaEntity)

    @Delete
    suspend fun eliminarLinea(linea: LineaVentaEntity)

    @Query("DELETE FROM lineas_venta WHERE idRecibo = :idRecibo")
    suspend fun eliminarLineasPorRecibo(idRecibo: String)

    @Query("DELETE FROM lineas_venta WHERE idMercadillo = :idMercadillo")
    suspend fun eliminarLineasPorMercadillo(idMercadillo: String)
}
===== END
===== FILE: AppDatabase.kt
// app/src/main/java/es/nuskysoftware/marketsales/data/local/database/AppDatabase.kt
package es.nuskysoftware.marketsales.data.local.database

import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import android.content.Context
import es.nuskysoftware.marketsales.data.local.entity.ConfiguracionEntity
import es.nuskysoftware.marketsales.data.local.entity.MercadilloEntity
import es.nuskysoftware.marketsales.data.local.entity.UserEntity
import es.nuskysoftware.marketsales.data.local.entity.CategoriaEntity
import es.nuskysoftware.marketsales.data.local.entity.ArticuloEntity
import es.nuskysoftware.marketsales.data.local.entity.ReciboEntity // ✅ NUEVO
import es.nuskysoftware.marketsales.data.local.entity.LineaVentaEntity // ✅ NUEVO
import es.nuskysoftware.marketsales.data.local.dao.ConfiguracionDao
import es.nuskysoftware.marketsales.data.local.dao.MercadilloDao
import es.nuskysoftware.marketsales.data.local.dao.UserDao
import es.nuskysoftware.marketsales.data.local.dao.CategoriaDao
import es.nuskysoftware.marketsales.data.local.dao.ArticuloDao
import es.nuskysoftware.marketsales.data.local.dao.RecibosDao // ✅ NUEVO
import es.nuskysoftware.marketsales.data.local.dao.LineasVentaDao // ✅ NUEVO
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.launch

/**
 * ✅ V13 - AppDatabase con soporte para Ventas
 * CAMBIOS V13:
 * - Agregadas ReciboEntity y LineaVentaEntity
 * - Agregados RecibosDao y LineasVentaDao
 * - Incrementada versión de 6 a 7
 * - Sistema de ventas completo integrado
 */
@Database(
    entities = [
        ConfiguracionEntity::class,
        MercadilloEntity::class,
        UserEntity::class,
        CategoriaEntity::class,
        ArticuloEntity::class,
        ReciboEntity::class, // ✅ NUEVO
        LineaVentaEntity::class // ✅ NUEVO
    ],
    version = 7, // ✅ INCREMENTADA DE 6 A 7
    exportSchema = false
)
abstract class AppDatabase : RoomDatabase() {

    abstract fun configuracionDao(): ConfiguracionDao
    abstract fun mercadilloDao(): MercadilloDao
    abstract fun userDao(): UserDao
    abstract fun categoriaDao(): CategoriaDao
    abstract fun articuloDao(): ArticuloDao
    abstract fun recibosDao(): RecibosDao // ✅ NUEVO
    abstract fun lineasVentaDao(): LineasVentaDao // ✅ NUEVO

    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null

        private val applicationScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

        fun getDatabase(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "marketsales_database_v10" // ✅ Mantenido el mismo nombre
                )
                    .fallbackToDestructiveMigration()
                    .addCallback(DatabaseCallback(applicationScope))
                    .build()

                INSTANCE = instance
                instance
            }
        }

        fun clearInstance() {
            INSTANCE = null
        }
    }

    private class DatabaseCallback(
        private val scope: CoroutineScope
    ) : RoomDatabase.Callback() {

        override fun onCreate(db: androidx.sqlite.db.SupportSQLiteDatabase) {
            super.onCreate(db)

            INSTANCE?.let { database ->
                scope.launch {
                    try {
                        crearConfiguracionPorDefecto(database.configuracionDao())
                        println("✅ Base de datos V13 inicializada correctamente con soporte de ventas")
                    } catch (e: Exception) {
                        println("❌ Error inicializando base de datos: ${e.message}")
                    }
                }
            }
        }

        private suspend fun crearConfiguracionPorDefecto(configuracionDao: ConfiguracionDao) {
            val configuracionExistente = configuracionDao.getConfiguracion()

            if (configuracionExistente == null) {
                // ✅ USANDO ConfiguracionEntity V13 con versión actualizada
                val configuracionPorDefecto = ConfiguracionEntity(
                    id = 1,
                    moneda = "€ Euro",
                    idioma = "es",
                    fuente = "Montserrat",
                    temaOscuro = false,
                    usuarioLogueado = "usuario_default",
                    numeroVersion = "V13.0", // ✅ ACTUALIZADA PARA REFLEJAR SOPORTE DE VENTAS
                    ultimoDispositivo = android.os.Build.MODEL,
                    fechaUltimaSync = null,
                    version = 1,
                    lastModified = System.currentTimeMillis(),
                    pendienteSync = false
                )

                configuracionDao.insertOrUpdate(configuracionPorDefecto)
                println("✅ Configuración V13 por defecto creada con soporte de ventas")
            }
        }
    }
}

===== END
===== FILE: ArticuloEntity.kt
// app/src/main/java/es/nuskysoftware/marketsales/data/local/entity/ArticuloEntity.kt
package es.nuskysoftware.marketsales.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.UUID

/**
 * ArticuloEntity V11 - Market Sales
 *
 * CAMBIOS RESPECTO A CAJA MERCADILLOS:
 * - Agregado campo userId para vincular con usuario
 * - Compatible con arquitectura híbrida "Reloj Suizo"
 * - Sincronización con Firebase + Room offline-first
 * - Campos de control Premium (coste, stock)
 */
@Entity(tableName = "articulos")
data class ArticuloEntity(
    @PrimaryKey
    val idArticulo: String = UUID.randomUUID().toString(),

    // ✅ NUEVO: Campo para vincular con usuario
    val userId: String = "",

    // Campos principales
    val nombre: String = "",
    val idCategoria: String = "",
    val precioVenta: Double = 0.0,

    // Campos Premium
    val precioCoste: Double? = null,
    val stock: Int? = null,
    val controlarStock: Boolean = false,
    val controlarCoste: Boolean = false,

    // Campos adicionales
    val favorito: Boolean = false,
    val fotoUri: String? = null,
    val activo: Boolean = true,

    // Campos de sincronización híbrida
    val version: Long = 1,
    val lastModified: Long = System.currentTimeMillis(),
    val sincronizadoFirebase: Boolean = false
) {
    // Constructor vacío para Firestore
    constructor() : this(
        idArticulo = "",
        userId = "",
        nombre = "",
        idCategoria = "",
        precioVenta = 0.0,
        precioCoste = null,
        stock = null,
        controlarStock = false,
        controlarCoste = false,
        favorito = false,
        fotoUri = null,
        activo = true,
        version = 1,
        lastModified = System.currentTimeMillis(),
        sincronizadoFirebase = false
    )
}
===== END
===== FILE: CategoriaEntity.kt
// app/src/main/java/es/nuskysoftware/marketsales/data/local/entity/CategoriaEntity.kt
package es.nuskysoftware.marketsales.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.UUID

/**
 * CategoriaEntity V11 - Market Sales
 *
 * CAMBIOS RESPECTO A CAJA MERCADILLOS:
 * - Agregado campo userId para vincular con tabla usuarios
 * - Compatible con arquitectura híbrida "Reloj Suizo"
 * - Sincronización con Firebase + Room offline-first
 */
@Entity(tableName = "categorias")
data class CategoriaEntity(
    @PrimaryKey
    val idCategoria: String = UUID.randomUUID().toString(),

    // ✅ NUEVO: Campo para vincular con usuario
    val userId: String = "",

    val nombre: String = "",
    val colorHex: String = "#FFFFFF",
    val orden: Int = 0,
    val activa: Boolean = true,

    // Campos de sincronización híbrida
    val version: Long = 1,
    val lastModified: Long = System.currentTimeMillis(),
    val sincronizadoFirebase: Boolean = false
) {
    // Constructor vacío para Firestore
    constructor() : this(
        idCategoria = "",
        userId = "",
        nombre = "",
        colorHex = "#FFFFFF",
        orden = 0,
        activa = true,
        version = 1,
        lastModified = System.currentTimeMillis(),
        sincronizadoFirebase = false
    )
}
===== END
===== FILE: ConfiguracionEntity.kt
// app/src/main/java/es/nuskysoftware/marketsales/data/local/entity/ConfiguracionEntity.kt
package es.nuskysoftware.marketsales.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey

/**
 * ConfiguracionEntity V10 - SIMPLIFICADO MONOUSUARIO
 *
 * CAMBIOS V10:
 * - Configuración GLOBAL (moneda, idioma, fuente, tema) común a todos los usuarios
 * - usuarioLogueado: UID del usuario actual o "usuario_default"
 * - Eliminado: versionApp, empresaId, tipoUsuario, etc. (lógica multiusuario)
 * - Agregado: Campos de sincronización (version, lastModified, pendienteSync)
 */
@Entity(tableName = "configuracion")
data class ConfiguracionEntity(
    @PrimaryKey val id: Int = 1,

    // ========== CONFIGURACIÓN GLOBAL (común a todos los usuarios) ==========
    val moneda: String = "€ Euro",           // Común a todos
    val idioma: String = "es",               // Común a todos
    val fuente: String = "Montserrat",       // Común a todos
    val temaOscuro: Boolean = false,         // Común a todos

    // ========== USUARIO ACTUAL ==========
    val usuarioLogueado: String = "usuario_default",  // UID actual o "usuario_default"

    // ========== CAMPOS LEGACY (mantener para compatibilidad) ==========
    val numeroVersion: String = "V10.0",
    val ultimoDispositivo: String? = android.os.Build.MODEL,
    val fechaUltimaSync: String? = null,

    // ========== SINCRONIZACIÓN V10 ==========
    val version: Long = 1,
    val lastModified: Long = System.currentTimeMillis(),
    val pendienteSync: Boolean = false,
    val sincronizadoFirebase: Boolean = false
)

// ========== EXTENSION PROPERTIES (compatibilidad con código existente) ==========

/**
 * Determina si el usuario actual es Premium
 * NOTA: Ahora se debe consultar desde la tabla usuarios
 */
@Deprecated("Usar UserRepository.getCurrentUser().esPremium", ReplaceWith("userRepository.getCurrentUser()?.esPremium ?: false"))
val ConfiguracionEntity.isPremium: Boolean
    get() = false // Siempre false, se consulta desde usuarios

/**
 * Alias para compatibilidad
 */
val ConfiguracionEntity.modoOscuro: Boolean
    get() = this.temaOscuro

/**
 * Indica si es usuario por defecto
 */
val ConfiguracionEntity.isUsuarioDefault: Boolean
    get() = this.usuarioLogueado == "usuario_default"

===== END
===== FILE: LineaVentaEntity.kt
// app/src/main/java/es/nuskysoftware/marketsales/data/local/entity/LineaVentaEntity.kt
package es.nuskysoftware.marketsales.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "lineas_venta")
data class LineaVentaEntity(
    @PrimaryKey val idLinea: String,
    val idRecibo: String,
    val idMercadillo: String,
    val idUsuario: String,
    val numeroLinea: Int,
    val tipoLinea: String,
    val descripcion: String,
    val idProducto: String? = null,
    val cantidad: Int,
    val precioUnitario: Double,
    val subtotal: Double,
    val idLineaOriginalAbonada: String? = null
)
===== END
===== FILE: MercadilloEntity.kt
// app/src/main/java/es/nuskysoftware/marketsales/data/local/entity/MercadilloEntity.kt
package es.nuskysoftware.marketsales.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.UUID

/**
 * MercadilloEntity V11 - Market Sales
 *
 * ARQUITECTURA HÍBRIDA "RELOJ SUIZO":
 * - Compatible con sincronización Firebase + Room offline-first
 * - Campo userId para vincular con usuario
 * - Estados automáticos según lógica de negocio
 * - Gestión completa de saldos y arqueos
 * - Campos calculados almacenados en BD
 */
@Entity(tableName = "mercadillos")
data class MercadilloEntity(
    @PrimaryKey
    val idMercadillo: String = UUID.randomUUID().toString(),

    // ✅ Campo para vincular con usuario
    val userId: String = "",

    // ========== DATOS BÁSICOS (MÍNIMOS REQUERIDOS) ==========
    val fecha: String = "", // Formato "dd-MM-yyyy"
    val lugar: String = "",
    val organizador: String = "",

    // ========== CONFIGURACIÓN DEL MERCADILLO ==========
    val esGratis: Boolean = true,
    val importeSuscripcion: Double = 0.0, // Solo si esGratis = false
    val requiereMesa: Boolean = true,
    val requiereCarpa: Boolean = true,
    val hayPuntoLuz: Boolean = false,
    val horaInicio: String = "09:00", // Formato "HH:mm"
    val horaFin: String = "14:00", // Formato "HH:mm"

    // ========== ESTADOS Y CONTROL ==========
    val estado: Int = 1, // Según EstadosMercadillo.Estado.codigo (automático)
    val pendienteArqueo: Boolean = false,
    val pendienteAsignarSaldo: Boolean = false,

    // ========== GESTIÓN FINANCIERA ==========
    // null en saldoInicial = PROGRAMADO_PARCIAL, asignado = PROGRAMADO_TOTAL
    val saldoInicial: Double? = null,
    val saldoFinal: Double? = null,

    // Campos calculados pero almacenados:
    val arqueoCaja: Double? = null, // saldoInicial + ventasEfectivo - gastosEfectivo
    val totalVentas: Double = 0.0, // Ventas en cualquier forma de pago (calculado desde tabla ventas)
    val totalGastos: Double = 0.0, // Gastos en cualquier forma de pago (calculado desde tabla gastos)
    val arqueoMercadillo: Double? = null, // saldoInicial + totalVentas - totalGastos - importeSuscripcion

    // ========== CAMPOS DE CONTROL ==========
    val activo: Boolean = true,

    // ========== CAMPOS SINCRONIZACIÓN HÍBRIDA ==========
    val version: Long = 1,
    val lastModified: Long = System.currentTimeMillis(),
    val sincronizadoFirebase: Boolean = false
) {
    // Constructor vacío para Firestore
    constructor() : this(
        idMercadillo = "",
        userId = "",
        fecha = "",
        lugar = "",
        organizador = "",
        esGratis = true,
        importeSuscripcion = 0.0,
        requiereMesa = true,
        requiereCarpa = true,
        hayPuntoLuz = false,
        horaInicio = "09:00",
        horaFin = "14:00",
        estado = 1,
        pendienteArqueo = false,
        pendienteAsignarSaldo = false,
        saldoInicial = null,
        saldoFinal = null,
        arqueoCaja = null,
        totalVentas = 0.0,
        totalGastos = 0.0,
        arqueoMercadillo = null,
        activo = true,
        version = 1,
        lastModified = System.currentTimeMillis(),
        sincronizadoFirebase = false
    )
}

===== END
===== FILE: ReciboEntity.kt
// app/src/main/java/es/nuskysoftware/marketsales/data/local/entity/ReciboEntity.kt
package es.nuskysoftware.marketsales.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "recibos")
data class ReciboEntity(
    @PrimaryKey val idRecibo: String,
    val idMercadillo: String,
    val idUsuario: String,
    val fechaHora: Long,
    val metodoPago: String,
    val totalTicket: Double,
    val estado: String = "COMPLETADO"
)===== END
===== FILE: UserEntity.kt
// app/src/main/java/es/nuskysoftware/marketsales/data/local/entity/UserEntity.kt
package es.nuskysoftware.marketsales.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey

/**
 * ✅ COMPLETO V10 - UserEntity con todos los campos necesarios
 */
@Entity(tableName = "usuarios")
data class UserEntity(
    @PrimaryKey val uid: String,
    val email: String = "",
    val displayName: String = "",
    val photoUrl: String = "",
    val esPremium: Boolean = false,        // Premium/Free

    // ✅ CAMPOS FALTANTES AGREGADOS
    val version: Long = 1,                 // Para versionado
    val lastModified: Long = System.currentTimeMillis(), // Para sincronización

    val fechaCreacion: Long = System.currentTimeMillis(),
    val fechaUltimaSync: String? = null,
    val sincronizadoFirebase: Boolean = false,
    val activo: Boolean = true
)
===== END
===== FILE: ArticuloRepository.kt
// app/src/main/java/es/nuskysoftware/marketsales/data/repository/ArticuloRepository.kt
package es.nuskysoftware.marketsales.data.repository

import android.content.Context
import android.util.Log
import com.google.firebase.firestore.FirebaseFirestore
import es.nuskysoftware.marketsales.data.local.dao.ArticuloDao
import es.nuskysoftware.marketsales.data.local.database.AppDatabase
import es.nuskysoftware.marketsales.data.local.entity.ArticuloEntity
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.ConnectivityObserver
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.tasks.await

/**
 * ArticuloRepository V11 - Market Sales
 *
 * ARQUITECTURA HÍBRIDA "RELOJ SUIZO":
 * - Local First: Toda operación se ejecuta primero en Room
 * - Sync When Possible: Sincronización automática cuando hay conexión
 * - Never Block UI: La interfaz nunca espera operaciones de red
 * - Graceful Degradation: Funcionamiento completo offline
 * - Filtrado por usuario: Cada usuario solo ve sus datos
 */
class ArticuloRepository(
    context: Context
) {
    private val articuloDao: ArticuloDao = AppDatabase.getDatabase(context).articuloDao()
    private val firestore = FirebaseFirestore.getInstance()
    private val connectivityObserver = ConnectivityObserver(context)
    private val repositoryScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

    companion object {
        private const val TAG = "ArticuloRepository"
    }

    init {
        // Sincronización automática cuando volvemos online
        repositoryScope.launch {
            connectivityObserver.isConnected.collect { online ->
                if (online) {
                    val userId = ConfigurationManager.getCurrentUserId()
                    if (userId != null) {
                        sincronizarArticulosNoSincronizados(userId)
                    }
                }
            }
        }
    }

    // ========== OPERACIONES PRINCIPALES ==========

    /**
     * Obtiene todos los artículos del usuario actual
     */
    fun getArticulosUsuarioActual(): Flow<List<ArticuloEntity>> {
        val userId = ConfigurationManager.getCurrentUserId()
        return if (userId != null) {
            articuloDao.getArticulosByUser(userId)
        } else {
            flowOf(emptyList())
        }
    }

    /**
     * Obtiene artículos filtrados por categoría
     */
    fun getArticulosByCategoria(categoriaId: String): Flow<List<ArticuloEntity>> {
        val userId = ConfigurationManager.getCurrentUserId()
        return if (userId != null) {
            articuloDao.getArticulosByUserAndCategoria(userId, categoriaId)
        } else {
            flowOf(emptyList())
        }
    }

    /**
     * Crea un nuevo artículo - PATRÓN HÍBRIDO
     */
    suspend fun crearArticulo(
        nombre: String,
        idCategoria: String,
        precioVenta: Double,
        precioCoste: Double? = null,
        stock: Int? = null,
        controlarStock: Boolean = false,
        controlarCoste: Boolean = false,
        favorito: Boolean = false,
        fotoUri: String? = null
    ): String = withContext(Dispatchers.IO) {
        val userId = ConfigurationManager.getCurrentUserId()
            ?: throw IllegalStateException("No se puede crear artículo sin usuario")

        Log.d(TAG, "🔄 Creando artículo para usuario: $userId")

        val nuevoArticulo = ArticuloEntity(
            userId = userId,
            nombre = nombre,
            idCategoria = idCategoria,
            precioVenta = precioVenta,
            precioCoste = precioCoste,
            stock = stock,
            controlarStock = controlarStock,
            controlarCoste = controlarCoste,
            favorito = favorito,
            fotoUri = fotoUri,
            sincronizadoFirebase = false
        )

        try {
            // 1. GUARDAR EN ROOM PRIMERO (respuesta inmediata)
            articuloDao.insertArticulo(nuevoArticulo)
            Log.d(TAG, "✅ Artículo guardado en Room: ${nuevoArticulo.nombre}")

            // 2. INTENTAR SINCRONIZAR CON FIREBASE
            sincronizarArticuloConFirebase(nuevoArticulo)

            return@withContext nuevoArticulo.idArticulo

        } catch (e: Exception) {
            Log.e(TAG, "❌ Error creando artículo", e)
            throw e
        }
    }

    /**
     * Actualiza un artículo existente - PATRÓN HÍBRIDO
     */
    suspend fun actualizarArticulo(articulo: ArticuloEntity): Boolean = withContext(Dispatchers.IO) {
        try {
            val articuloActualizado = articulo.copy(
                version = articulo.version + 1,
                lastModified = System.currentTimeMillis(),
                sincronizadoFirebase = false
            )

            // 1. ACTUALIZAR EN ROOM PRIMERO
            articuloDao.updateArticulo(articuloActualizado)
            Log.d(TAG, "✅ Artículo actualizado en Room: ${articuloActualizado.nombre}")

            // 2. INTENTAR SINCRONIZAR CON FIREBASE
            sincronizarArticuloConFirebase(articuloActualizado)

            true
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error actualizando artículo", e)
            false
        }
    }

    /**
     * Elimina un artículo - PATRÓN HÍBRIDO
     */
    suspend fun eliminarArticulo(articulo: ArticuloEntity): Boolean = withContext(Dispatchers.IO) {
        try {
            // 1. ELIMINAR DE ROOM PRIMERO
            articuloDao.deleteArticulo(articulo)
            Log.d(TAG, "✅ Artículo eliminado de Room: ${articulo.nombre}")

            // 2. INTENTAR ELIMINAR DE FIREBASE
            eliminarArticuloDeFirebase(articulo.idArticulo)

            true
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error eliminando artículo", e)
            false
        }
    }

    /**
     * Obtiene artículo por ID
     */
    suspend fun getArticuloById(id: String): ArticuloEntity? = withContext(Dispatchers.IO) {
        articuloDao.getArticuloById(id)
    }

    // ========== ESTRATEGIA HÍBRIDA INTELIGENTE ==========

    /**
     * Obtiene datos híbridos: combina lo mejor de Room y Firebase
     */
    suspend fun getHybridArticulos(userId: String): List<ArticuloEntity> = withContext(Dispatchers.IO) {
        try {
            // 1. Verificar cambios pendientes en Room
            val articulosNoSincronizados = articuloDao.getArticulosNoSincronizadosByUser(userId)

            if (articulosNoSincronizados.isNotEmpty()) {
                // HAY CAMBIOS PENDIENTES → Room es fuente de verdad
                Log.d(TAG, "📱 Usando Room (${articulosNoSincronizados.size} cambios pendientes)")
                return@withContext articuloDao.getArticulosByUser(userId).first()
            } else {
                // NO HAY CAMBIOS PENDIENTES → Intentar Firebase
                Log.d(TAG, "☁️ Intentando Firebase (sin cambios pendientes)")

                if (connectivityObserver.isConnected.first()) {
                    try {
                        val firebaseArticulos = descargarArticulosDesdeFirebase(userId)
                        if (firebaseArticulos.isNotEmpty()) {
                            // Actualizar Room con datos frescos
                            firebaseArticulos.forEach { articulo ->
                                articuloDao.insertOrUpdate(articulo.copy(sincronizadoFirebase = true))
                            }
                            Log.d(TAG, "✅ Datos frescos de Firebase aplicados")
                        }
                    } catch (e: Exception) {
                        Log.w(TAG, "⚠️ Error con Firebase, usando Room como fallback", e)
                    }
                }

                // Devolver datos de Room (actualizados o fallback)
                return@withContext articuloDao.getArticulosByUser(userId).first()
            }
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error en estrategia híbrida", e)
            // Fallback total a Room
            return@withContext articuloDao.getArticulosByUser(userId).first()
        }
    }

    // ========== SINCRONIZACIÓN CON FIREBASE ==========

    /**
     * Sincroniza un artículo específico con Firebase
     */
    private suspend fun sincronizarArticuloConFirebase(articulo: ArticuloEntity) {
        try {
            if (!connectivityObserver.isConnected.first()) {
                Log.d(TAG, "⚠️ Sin conexión, artículo quedará pendiente de sincronización")
                return
            }

            val datos = mapOf(
                "idArticulo" to articulo.idArticulo,
                "userId" to articulo.userId,
                "nombre" to articulo.nombre,
                "idCategoria" to articulo.idCategoria,
                "precioVenta" to articulo.precioVenta,
                "precioCoste" to articulo.precioCoste,
                "stock" to articulo.stock,
                "controlarStock" to articulo.controlarStock,
                "controlarCoste" to articulo.controlarCoste,
                "favorito" to articulo.favorito,
                "fotoUri" to articulo.fotoUri,
                "activo" to articulo.activo,
                "version" to articulo.version,
                "lastModified" to articulo.lastModified,
                "fechaSync" to System.currentTimeMillis()
            )

            firestore.collection("articulos")
                .document(articulo.idArticulo)
                .set(datos)
                .await()

            // Marcar como sincronizado en Room
            articuloDao.marcarComoSincronizado(articulo.idArticulo)
            Log.d(TAG, "☁️ Artículo sincronizado con Firebase: ${articulo.nombre}")

        } catch (e: Exception) {
            Log.w(TAG, "⚠️ Error sincronizando con Firebase: ${articulo.nombre}", e)
            // El artículo queda marcado como no sincronizado para reintento posterior
        }
    }

    /**
     * Elimina artículo de Firebase
     */
    private suspend fun eliminarArticuloDeFirebase(articuloId: String) {
        try {
            if (connectivityObserver.isConnected.first()) {
                firestore.collection("articulos")
                    .document(articuloId)
                    .delete()
                    .await()
                Log.d(TAG, "☁️ Artículo eliminado de Firebase: $articuloId")
            }
        } catch (e: Exception) {
            Log.w(TAG, "⚠️ Error eliminando de Firebase: $articuloId", e)
        }
    }

    /**
     * Sincroniza artículos no sincronizados cuando hay conexión
     */
    private suspend fun sincronizarArticulosNoSincronizados(userId: String) {
        try {
            val pendientes = articuloDao.getArticulosNoSincronizadosByUser(userId)
            Log.d(TAG, "🔄 Sincronizando ${pendientes.size} artículos pendientes")

            pendientes.forEach { articulo ->
                sincronizarArticuloConFirebase(articulo)
                delay(100) // Evitar saturar Firebase
            }
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error sincronizando pendientes", e)
        }
    }

    /**
     * Descarga artículos desde Firebase
     */
    private suspend fun descargarArticulosDesdeFirebase(userId: String): List<ArticuloEntity> {
        return try {
            val snapshot = firestore.collection("articulos")
                .whereEqualTo("userId", userId)
                .whereEqualTo("activo", true)
                .get()
                .await()

            val articulos = snapshot.documents.mapNotNull { doc ->
                try {
                    val data = doc.data ?: return@mapNotNull null
                    ArticuloEntity(
                        idArticulo = data["idArticulo"] as? String ?: "",
                        userId = data["userId"] as? String ?: "",
                        nombre = data["nombre"] as? String ?: "",
                        idCategoria = data["idCategoria"] as? String ?: "",
                        precioVenta = (data["precioVenta"] as? Number)?.toDouble() ?: 0.0,
                        precioCoste = (data["precioCoste"] as? Number)?.toDouble(),
                        stock = (data["stock"] as? Long)?.toInt(),
                        controlarStock = data["controlarStock"] as? Boolean ?: false,
                        controlarCoste = data["controlarCoste"] as? Boolean ?: false,
                        favorito = data["favorito"] as? Boolean ?: false,
                        fotoUri = data["fotoUri"] as? String,
                        activo = data["activo"] as? Boolean ?: true,
                        version = data["version"] as? Long ?: 1L,
                        lastModified = data["lastModified"] as? Long ?: System.currentTimeMillis(),
                        sincronizadoFirebase = true
                    )
                } catch (e: Exception) {
                    Log.w(TAG, "⚠️ Error parseando artículo de Firebase", e)
                    null
                }
            }

            Log.d(TAG, "☁️ Descargados ${articulos.size} artículos de Firebase")
            articulos

        } catch (e: Exception) {
            Log.e(TAG, "❌ Error descargando de Firebase", e)
            emptyList()
        }
    }

    // ========== UTILIDADES ==========

    /**
     * Verifica si existe un artículo con el mismo nombre
     */
    suspend fun existeArticuloConNombre(nombre: String, excludeId: String = ""): Boolean {
        val userId = ConfigurationManager.getCurrentUserId() ?: return false
        return articuloDao.existeArticuloConNombre(userId, nombre, excludeId)
    }

    /**
     * Busca artículos por nombre
     */
    fun searchArticulos(query: String): Flow<List<ArticuloEntity>> {
        val userId = ConfigurationManager.getCurrentUserId()
        return if (userId != null && query.isNotBlank()) {
            articuloDao.searchArticulosByNombre(userId, query)
        } else {
            flowOf(emptyList())
        }
    }

    /**
     * Fuerza sincronización completa
     */
    suspend fun forzarSincronizacion(): Boolean = withContext(Dispatchers.IO) {
        try {
            val userId = ConfigurationManager.getCurrentUserId() ?: return@withContext false

            sincronizarArticulosNoSincronizados(userId)
            getHybridArticulos(userId) // Esto descargará datos frescos de Firebase

            true
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error en sincronización forzada", e)
            false
        }
    }
}===== END
===== FILE: AuthRepository.kt
// app/src/main/java/es/nuskysoftware/marketsales/data/repository/AuthRepository.kt
package es.nuskysoftware.marketsales.data.repository

import android.content.Context
import android.util.Log
import com.google.firebase.Firebase
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.FirebaseUser
import com.google.firebase.auth.GoogleAuthProvider
import com.google.firebase.auth.auth
import com.google.firebase.firestore.FirebaseFirestore
import es.nuskysoftware.marketsales.data.local.entity.ConfiguracionEntity
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.tasks.await
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import kotlinx.coroutines.launch
import kotlin.coroutines.cancellation.CancellationException

/**
 * AuthRepository V10 - SIMPLIFICADO PARA SISTEMA MONOUSUARIO
 *
 * CAMBIOS V10:
 * - Eliminado sistema multiusuario (empresas, roles, permisos)
 * - Simplificado flujo login/logout
 * - Solo gestiona: usuario básico + esPremium
 * - Configuración global común a todos los usuarios
 */

sealed class AuthState {
    object Loading : AuthState()
    object Unauthenticated : AuthState()
    data class Authenticated(val user: FirebaseUser) : AuthState()
    data class Error(val message: String) : AuthState()
}

sealed class AuthResult {
    data class Success(val user: FirebaseUser?) : AuthResult()
    data class Error(val message: String) : AuthResult()
}

class AuthRepository(
    private val context: Context
) {
    private val firebaseAuth = FirebaseAuth.getInstance()
    private val firestore = FirebaseFirestore.getInstance()

    private var isLoadingConfiguration = false


    // ✅ V10: Repositorios simplificados
    private val userRepository = UserRepository(context)
    private val configuracionRepository = ConfiguracionRepository(context)

    private val _authState = MutableStateFlow<AuthState>(AuthState.Loading)
    val authState: StateFlow<AuthState> = _authState.asStateFlow()

    private val _currentUser = MutableStateFlow<FirebaseUser?>(null)
    val currentUser: StateFlow<FirebaseUser?> = _currentUser.asStateFlow()

    companion object {
        private const val TAG = "AuthRepository"
    }
    // En AuthRepository.kt, reemplaza el bloque init{} con esta versión corregida:
// REEMPLAZA COMPLETAMENTE el bloque init{} en tu AuthRepository.kt con esto:

    init {
        // Inicializar estado basado en usuario actual
        val user = firebaseAuth.currentUser
        _currentUser.value = user
        _authState.value = if (user != null) {
            AuthState.Authenticated(user)
        } else {
            AuthState.Unauthenticated
        }


        if (user != null) {
            Log.d(TAG, "Usuario existente detectado: ${user.email}")

            // Usar GlobalScope para corrutinas (simple pero funcional para init)
            kotlinx.coroutines.GlobalScope.launch {
                try {
                    loadUserConfigurationHybrid(user.uid)
                } catch (e: Exception) {
                    Log.e(TAG, "Error cargando configuración híbrida en init", e)

                    ConfigurationManager.logout()
                }
            }
        } else {
            // Asegurar que ConfigurationManager refleje que no hay usuario
            ConfigurationManager.logout()
            Log.d(TAG, "No hay usuario - ConfigurationManager en estado logout")
        }

        // Listener para cambios de autenticación
        firebaseAuth.addAuthStateListener { auth ->
            val currentUser = auth.currentUser
            _currentUser.value = currentUser
            _authState.value = if (currentUser != null) {
                AuthState.Authenticated(currentUser)
            } else {
                AuthState.Unauthenticated
            }
        }

        Log.d(TAG, "AuthRepository V10 inicializado - Usuario actual: ${user?.email ?: "null"}")
    }


    // ========== MÉTODOS DE TESTING (preservados) ==========

    fun testConnection(): Boolean {
        return try {
            val app = firebaseAuth.app
            Log.d(TAG, "Conexión Firebase Auth OK - App: ${app.name}")
            true
        } catch (e: Exception) {
            Log.e(TAG, "Error conexión Firebase Auth", e)
            false
        }
    }

    /**
     * 🔥 NUEVO: Cargar configuración usando estrategia híbrida
     */

    private suspend fun loadUserConfigurationHybrid(usuarioUid: String) {
        if (isLoadingConfiguration) {
            Log.d(TAG, "Ya se está cargando configuración, omitiendo")
            return
        }

        isLoadingConfiguration = true
        try {
            Log.d(TAG, "🔄 Cargando configuración HÍBRIDA para usuario: $usuarioUid")

            // ✅ VERIFICAR FIREBASE ANTES DE USAR ROOM
            val firebaseDisplayName = Firebase.auth.currentUser?.displayName
            Log.d(TAG, "🔍 Firebase displayName: $firebaseDisplayName")

            val userEntity = userRepository.getHybridUserData(usuarioUid)
            val configEntity = configuracionRepository.getHybridConfiguracion()

            configuracionRepository.setUsuarioLogueado(usuarioUid)

            if (configEntity != null && userEntity != null) {

                // 🚨 NUEVO: Si usuario NO es premium, forzar configuración por defecto
                val finalConfig = if (!userEntity.esPremium) {
                    Log.w(TAG, "🔄 Usuario FREE detectado - aplicando configuración por defecto")
                    configEntity.copy(
                        idioma = "es",
                        fuente = "Montserrat",
                        moneda = "€ Euro",
                        pendienteSync = true
                    )
                } else {
                    configEntity
                }

                // ✅ LÓGICA INTELIGENTE: Priorizar Firebase si es diferente
                val finalDisplayName = if (firebaseDisplayName != null &&
                    firebaseDisplayName.isNotBlank() &&
                    firebaseDisplayName != userEntity.displayName) {
                    Log.d(TAG, "🎯 Usando displayName de Firebase (más reciente): $firebaseDisplayName")

                    // ✅ ACTUALIZAR ROOM CON EL VALOR DE FIREBASE
                    userRepository.updateUserDisplayName(usuarioUid, firebaseDisplayName)

                    firebaseDisplayName
                } else {
                    Log.d(TAG, "🎯 Usando displayName de Room: ${userEntity.displayName}")
                    userEntity.displayName ?: ""
                }

                ConfigurationManager.updateUserConfiguration(
                    idioma = finalConfig.idioma,
                    fuente = finalConfig.fuente,
                    temaOscuro = finalConfig.temaOscuro,
                    moneda = finalConfig.moneda,
                    usuarioEmail = userEntity.email,
                    usuarioId = usuarioUid,
                    displayName = finalDisplayName, // ✅ Usar el displayName inteligente
                    planUsuario = if (userEntity.esPremium) "PREMIUM" else "FREE",
                    isAuthenticated = true
                )

                Log.d(TAG, "✅ Configuración HÍBRIDA cargada:")
                Log.d(TAG, "   - usuario: $usuarioUid")
                Log.d(TAG, "   - displayName final: $finalDisplayName")
                Log.d(TAG, "   - esPremium: ${userEntity.esPremium}")
                Log.d(TAG, "   - idioma: ${finalConfig.idioma}")
                Log.d(TAG, "   - moneda: ${finalConfig.moneda}")

            } else {
                Log.e(TAG, "Error cargando configuración híbrida")
                return
            }

        } catch (e: CancellationException) {
            Log.w(TAG, "Configuración cancelada - manteniendo estado actual")
            return
        } catch (e: Exception) {
            Log.e(TAG, "Error real cargando configuración híbrida", e)
            ConfigurationManager.resetToDefaults()
        } finally {
            isLoadingConfiguration = false
        }
    }

    suspend fun updateUserProfile(userId: String, displayName: String, email: String) {
        try {
            // Usar el método existente de UserRepository
            userRepository.updateUserProfile(userId, displayName, email)
            Log.d(TAG, "✅ Perfil actualizado en UserRepository")
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error actualizando perfil en repository", e)
        }
    }
    suspend fun updateUserProfileAndMarkDirty(userId: String, displayName: String, email: String) {
        try {
            // Actualizar UserRepository con datos frescos
            userRepository.updateUserProfileAndMarkDirty(userId, displayName, email)
            Log.d(TAG, "✅ Perfil actualizado en UserRepository y marcado como no sincronizado")
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error actualizando perfil en repository", e)
        }
    }
    suspend fun refreshUserConfiguration() {
        val currentUser = Firebase.auth.currentUser
        if (currentUser != null) {
            Log.d(TAG, "🔄 Forzando refresh de configuración de usuario")
            loadUserConfigurationHybrid(currentUser.uid)
        }
    }
        fun isUserAuthenticated(): Boolean {
            val authenticated = firebaseAuth.currentUser != null
            Log.d(TAG, "¿Usuario autenticado? $authenticated")
            return authenticated
        }

        // ========== REGISTRO CON EMAIL/PASSWORD V10 ==========

        suspend fun registerWithEmail(email: String, password: String): AuthResult {
            return try {
                Log.d(TAG, "Iniciando registro para: $email")
                _authState.value = AuthState.Loading

                // 1. Crear usuario en Firebase Auth
                val authResult =
                    firebaseAuth.createUserWithEmailAndPassword(email, password).await()
                val user = authResult.user

                if (user != null) {
                    Log.d(TAG, "Usuario registrado exitosamente: ${user.email}")

                    // 2. Crear/cargar usuario en base de datos local
                    val userEntity = userRepository.getOrCreateUser(
                        uid = user.uid,
                        email = user.email ?: "",
                        displayName = user.displayName ?: "",
                        photoUrl = user.photoUrl?.toString() ?: "",
                        esPremium = false // Nuevos usuarios son FREE por defecto
                    )

                    // 3. Cargar configuración para este usuario
                    //loadUserConfiguration(user.uid, userEntity.esPremium)
                    loadUserConfigurationHybrid(user.uid) // ✅ esPremium: true


                    _authState.value = AuthState.Authenticated(user)
                    AuthResult.Success(user)
                } else {
                    val error = "Error: Usuario nulo después del registro"
                    Log.e(TAG, error)
                    _authState.value = AuthState.Error(error)
                    AuthResult.Error(error)
                }

            } catch (e: Exception) {
                val errorMessage = "Error en registro: ${e.message}"
                Log.e(TAG, errorMessage, e)
                _authState.value = AuthState.Error(errorMessage)
                AuthResult.Error(errorMessage)
            }
        }

    suspend fun updateUserInDatabase(userId: String, displayName: String, email: String) {
        try {
            userRepository.updateUserProfile(userId, displayName, email)
            Log.d(TAG, "✅ Perfil actualizado en base de datos local")
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error actualizando perfil en BD local", e)
        }
    }
        // ========== LOGIN CON EMAIL/PASSWORD V10 ==========

        suspend fun loginWithEmail(email: String, password: String): AuthResult {
            return try {
                Log.d(TAG, "Iniciando login para: $email")
                _authState.value = AuthState.Loading

                // 1. Autenticar con Firebase Auth
                val authResult = firebaseAuth.signInWithEmailAndPassword(email, password).await()
                val user = authResult.user

                if (user != null) {
                    Log.d(TAG, "Login exitoso: ${user.email}")

                    // 2. Buscar/crear usuario en base de datos local
                    val userEntity = userRepository.getOrCreateUser(
                        uid = user.uid,
                        email = user.email ?: "",
                        displayName = user.displayName ?: "",
                        photoUrl = user.photoUrl?.toString() ?: ""
                    )

                    // 3. Cargar configuración para este usuario
                    //loadUserConfiguration(user.uid, userEntity.esPremium)
                    loadUserConfigurationHybrid(user.uid) // ✅ esPremium: true


                    _authState.value = AuthState.Authenticated(user)
                    AuthResult.Success(user)
                } else {
                    val error = "Error: Usuario nulo después del login"
                    Log.e(TAG, error)
                    _authState.value = AuthState.Error(error)
                    AuthResult.Error(error)
                }

            } catch (e: Exception) {
                val errorMessage = when (e.message) {
                    "The email address is badly formatted." -> "Email inválido"
                    "The password is invalid or the user does not have a password." -> "Contraseña incorrecta"
                    "There is no user record corresponding to this identifier. The user may have been deleted." -> "Usuario no encontrado"
                    "A network error (such as timeout, interrupted connection or unreachable host) has occurred." -> "Error de conexión"
                    else -> "Error en login: ${e.message}"
                }
                Log.e(TAG, errorMessage, e)
                _authState.value = AuthState.Error(errorMessage)
                AuthResult.Error(errorMessage)
            }
        }

        // ========== GOOGLE AUTH V10 ==========

        suspend fun signInWithGoogle(idToken: String): AuthResult {
            return try {
                Log.d(TAG, "Iniciando Google Auth con idToken")
                _authState.value = AuthState.Loading

                // 1. Crear credencial de Google
                val credential = GoogleAuthProvider.getCredential(idToken, null)

                // 2. Autenticar con Firebase
                val authResult = firebaseAuth.signInWithCredential(credential).await()
                val user = authResult.user

                if (user != null) {
                    Log.d(TAG, "Google Auth exitoso: ${user.email}")

                    // 3. Crear/actualizar usuario en base de datos local
                    val userEntity = userRepository.getOrCreateUser(
                        uid = user.uid,
                        email = user.email ?: "",
                        displayName = user.displayName ?: "",
                        photoUrl = user.photoUrl?.toString() ?: ""
                    )

                    // 4. Cargar configuración para este usuario
                    //loadUserConfiguration(user.uid, userEntity.esPremium)
                    loadUserConfigurationHybrid(user.uid) // ✅ esPremium: true


                    _authState.value = AuthState.Authenticated(user)
                    AuthResult.Success(user)
                } else {
                    val error = "Error: Usuario nulo después de Google Auth"
                    Log.e(TAG, error)
                    _authState.value = AuthState.Error(error)
                    AuthResult.Error(error)
                }

            } catch (e: Exception) {
                val errorMessage = when (e.message) {
                    "An internal error has occurred. [ INVALID_IDP_RESPONSE ]" -> "Error de autenticación con Google"
                    "A network error (such as timeout, interrupted connection or unreachable host) has occurred." -> "Error de conexión"
                    else -> "Error en Google Auth: ${e.message}"
                }
                Log.e(TAG, errorMessage, e)
                _authState.value = AuthState.Error(errorMessage)
                AuthResult.Error(errorMessage)
            }
        }

        // ========== LOGOUT V10 ==========

        suspend fun logout(): AuthResult {
            return try {
                Log.d(TAG, "Cerrando sesión...")
                _authState.value = AuthState.Loading

                firebaseAuth.signOut()
                configuracionRepository.setUsuarioLogueado("usuario_default")

                // 🚨 CAMBIO: Forzar configuración por defecto inmediatamente
                ConfigurationManager.updateUserConfiguration(
                    idioma = "es",              // ✅ FORZAR español
                    fuente = "Montserrat",      // ✅ FORZAR Montserrat
                    temaOscuro = false,         // ✅ FORZAR tema claro
                    moneda = "€ Euro",          // ✅ FORZAR Euro
                    usuarioEmail = null,
                    usuarioId = null,
                    displayName = null,
                    isAuthenticated = false,
                    planUsuario = "FREE"
                )

                Log.d(TAG, "✅ Sesión cerrada y configuración reseteada")
                _authState.value = AuthState.Unauthenticated

                AuthResult.Success(null)

            } catch (e: Exception) {
                val errorMessage = "Error al cerrar sesión: ${e.message}"
                Log.e(TAG, errorMessage, e)
                _authState.value = AuthState.Error(errorMessage)
                AuthResult.Error(errorMessage)
            }
        }

        // ========== CONFIGURACIÓN V10 ==========
         suspend fun loadUserConfiguration(usuarioUid: String, esPremium: Boolean) {
            try {
                Log.d(TAG, "Cargando configuración para usuario: $usuarioUid")

                // 1. Cargar configuración global
                val configEntity = configuracionRepository.getConfiguracion()

                // 2. Actualizar configuración en BD para este usuario
                configuracionRepository.setUsuarioLogueado(usuarioUid)

                // 3. Obtener datos del usuario
                val userEntity = userRepository.getUserById(usuarioUid)

                if (configEntity != null && userEntity != null) {
                    // 4. ✅ CORRECCIÓN: Actualizar ConfigurationManager con TODOS los datos necesarios
                    ConfigurationManager.updateUserConfiguration(
                        idioma = configEntity.idioma,
                        fuente = configEntity.fuente,
                        temaOscuro = configEntity.temaOscuro,
                        moneda = configEntity.moneda,
                        usuarioEmail = userEntity.email,
                        usuarioId = usuarioUid,
                        displayName = userEntity.displayName,
                        planUsuario = if (userEntity.esPremium) "PREMIUM" else "FREE",
                        isAuthenticated = true  // ✅ ESTO ES LO QUE FALTABA
                    )

                    Log.d(TAG, "✅ Configuración cargada:")
                    Log.d(TAG, "   - usuario: $usuarioUid")
                    Log.d(TAG, "   - esPremium: ${userEntity.esPremium}")
                    Log.d(TAG, "   - isAuthenticated: true")  // ✅ AÑADIDO
                    Log.d(TAG, "   - idioma: ${configEntity.idioma}")
                    Log.d(TAG, "   - moneda: ${configEntity.moneda}")

                } else {
                    Log.e(TAG, "Error cargando configuración o usuario")
                    ConfigurationManager.resetToDefaults()
                }

            } catch (e: Exception) {
                Log.e(TAG, "Error cargando configuración de usuario", e)
                ConfigurationManager.resetToDefaults()
            }
        }

        /**
         * Actualiza configuración (solo si el usuario tiene permisos)
         */
        suspend fun updateConfiguration(
            idioma: String? = null,
            fuente: String? = null,
            temaOscuro: Boolean? = null,
            moneda: String? = null
        ): Boolean {
            return try {
                val currentUser = firebaseAuth.currentUser
                val canChangeAdvanced = ConfigurationManager.canChangeConfiguration()

                // Solo Premium puede cambiar idioma, fuente y moneda
                if (idioma != null && canChangeAdvanced) {
                    configuracionRepository.updateIdioma(idioma)
                    ConfigurationManager.setIdioma(idioma)
                }

                if (fuente != null && canChangeAdvanced) {
                    configuracionRepository.updateFuente(fuente)
                    ConfigurationManager.setFuente(fuente)
                }

                if (moneda != null && canChangeAdvanced) {
                    configuracionRepository.updateMoneda(moneda)
                    ConfigurationManager.setMoneda(moneda)
                }

                // Todos pueden cambiar tema
                if (temaOscuro != null) {
                    configuracionRepository.updateTemaOscuro(temaOscuro)
                    ConfigurationManager.setTemaOscuro(temaOscuro)
                }

                Log.d(TAG, "✅ Configuración actualizada")
                true

            } catch (e: Exception) {
                Log.e(TAG, "Error actualizando configuración", e)
                false
            }
        }

        /**
         * Actualiza el estado Premium del usuario actual
         */
        suspend fun updateUserPremium(esPremium: Boolean): Boolean {
            return try {
                val currentUser = firebaseAuth.currentUser ?: return false

                // Actualizar en base de datos
                userRepository.updateUserPremium(currentUser.uid, esPremium)

                // Actualizar ConfigurationManager
                ConfigurationManager.updateUserPremium(esPremium)

                Log.d(TAG, "✅ Estado Premium actualizado: $esPremium")
                true

            } catch (e: Exception) {
                Log.e(TAG, "Error actualizando estado Premium", e)
                false
            }
        }

        // ========== INFORMACIÓN USUARIO ==========

        fun getCurrentUserInfo(): Map<String, Any>? {
            val user = firebaseAuth.currentUser
            return if (user != null) {
                mapOf(
                    "uid" to user.uid,
                    "email" to (user.email ?: ""),
                    "displayName" to (user.displayName ?: ""),
                    "photoUrl" to (user.photoUrl?.toString() ?: ""),
                    "isEmailVerified" to user.isEmailVerified,
                    "creationTimestamp" to (user.metadata?.creationTimestamp ?: 0L),
                    "provider" to if (user.providerData.any { it.providerId == "google.com" }) "google" else "email"
                )
            } else null
        }

        // ========== MÉTODOS OBSOLETOS V10 (compatibilidad) ==========

        @Deprecated(
            "Usar updateConfiguration()",
            ReplaceWith("updateConfiguration(idioma, fuente, modoOscuro)")
        )
        suspend fun updateUserConfiguration(
            idioma: String,
            fuente: String,
            modoOscuro: Boolean,
            isPremium: Boolean
        ): Boolean {
            return updateConfiguration(idioma, fuente, modoOscuro)
        }

        @Deprecated(
            "Usar updateConfiguration(moneda = moneda)",
            ReplaceWith("updateConfiguration(moneda = moneda)")
        )
        suspend fun updateMoneda(moneda: String): Boolean {
            return updateConfiguration(moneda = moneda)
        }
    }

===== END
===== FILE: settings.gradle.kts
// app/src/main/java/es/nuskysoftware/marketsales/data/repository/CategoriaRepository.kt
package es.nuskysoftware.marketsales.data.repository

import android.content.Context
import android.util.Log
import com.google.firebase.firestore.FirebaseFirestore
import es.nuskysoftware.marketsales.data.local.dao.CategoriaDao
import es.nuskysoftware.marketsales.data.local.database.AppDatabase
import es.nuskysoftware.marketsales.data.local.entity.CategoriaEntity
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.ConnectivityObserver
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.tasks.await

/**
 * CategoriaRepository V11 - Market Sales
 *
 * ARQUITECTURA HÍBRIDA "RELOJ SUIZO":
 * - Local First: Toda operación se ejecuta primero en Room
 * - Sync When Possible: Sincronización automática cuando hay conexión
 * - Never Block UI: La interfaz nunca espera operaciones de red
 * - Graceful Degradation: Funcionamiento completo offline
 * - Filtrado por usuario: Cada usuario solo ve sus datos
 */
class CategoriaRepository(
    context: Context
) {
    private val categoriaDao: CategoriaDao = AppDatabase.getDatabase(context).categoriaDao()
    private val firestore = FirebaseFirestore.getInstance()
    private val connectivityObserver = ConnectivityObserver(context)
    private val repositoryScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

    companion object {
        private const val TAG = "CategoriaRepository"
    }

    init {
        // Sincronización automática cuando volvemos online
        repositoryScope.launch {
            connectivityObserver.isConnected.collect { online ->
                if (online) {
                    val userId = ConfigurationManager.getCurrentUserId()
                    if (userId != null) {
                        sincronizarCategoriasNoSincronizadas(userId)
                    }
                }
            }
        }
    }

    // ========== OPERACIONES PRINCIPALES ==========

    /**
     * Obtiene todas las categorías del usuario actual
     */
    fun getCategoriasUsuarioActual(): Flow<List<CategoriaEntity>> {
        val userId = ConfigurationManager.getCurrentUserId()
        return if (userId != null) {
            categoriaDao.getCategoriasByUser(userId)
        } else {
            flowOf(emptyList())
        }
    }

    /**
     * Crea una nueva categoría - PATRÓN HÍBRIDO
     */
    suspend fun crearCategoria(
        nombre: String,
        colorHex: String,
        orden: Int = 0
    ): String = withContext(Dispatchers.IO) {
        val userId = ConfigurationManager.getCurrentUserId()
            ?: throw IllegalStateException("No se puede crear categoría sin usuario")

        Log.d(TAG, "🔄 Creando categoría para usuario: $userId")

        val nuevaCategoria = CategoriaEntity(
            userId = userId,
            nombre = nombre,
            colorHex = colorHex,
            orden = orden,
            sincronizadoFirebase = false
        )

        try {
            // 1. GUARDAR EN ROOM PRIMERO (respuesta inmediata)
            categoriaDao.insertCategoria(nuevaCategoria)
            Log.d(TAG, "✅ Categoría guardada en Room: ${nuevaCategoria.nombre}")

            // 2. INTENTAR SINCRONIZAR CON FIREBASE
            sincronizarCategoriaConFirebase(nuevaCategoria)

            return@withContext nuevaCategoria.idCategoria

        } catch (e: Exception) {
            Log.e(TAG, "❌ Error creando categoría", e)
            throw e
        }
    }

    /**
     * Actualiza una categoría existente - PATRÓN HÍBRIDO
     */
    suspend fun actualizarCategoria(categoria: CategoriaEntity): Boolean = withContext(Dispatchers.IO) {
        try {
            val categoriaActualizada = categoria.copy(
                version = categoria.version + 1,
                lastModified = System.currentTimeMillis(),
                sincronizadoFirebase = false
            )

            // 1. ACTUALIZAR EN ROOM PRIMERO
            categoriaDao.updateCategoria(categoriaActualizada)
            Log.d(TAG, "✅ Categoría actualizada en Room: ${categoriaActualizada.nombre}")

            // 2. INTENTAR SINCRONIZAR CON FIREBASE
            sincronizarCategoriaConFirebase(categoriaActualizada)

            true
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error actualizando categoría", e)
            false
        }
    }

    /**
     * Elimina una categoría - PATRÓN HÍBRIDO
     */
    suspend fun eliminarCategoria(categoria: CategoriaEntity): Boolean = withContext(Dispatchers.IO) {
        try {
            // 1. ELIMINAR DE ROOM PRIMERO
            categoriaDao.deleteCategoria(categoria)
            Log.d(TAG, "✅ Categoría eliminada de Room: ${categoria.nombre}")

            // 2. INTENTAR ELIMINAR DE FIREBASE
            eliminarCategoriaDeFirebase(categoria.idCategoria)

            true
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error eliminando categoría", e)
            false
        }
    }

    /**
     * Obtiene categoría por ID
     */
    suspend fun getCategoriaById(id: String): CategoriaEntity? = withContext(Dispatchers.IO) {
        categoriaDao.getCategoriaById(id)
    }

    // ========== ESTRATEGIA HÍBRIDA INTELIGENTE ==========

    /**
     * Obtiene datos híbridos: combina lo mejor de Room y Firebase
     */
    suspend fun getHybridCategorias(userId: String): List<CategoriaEntity> = withContext(Dispatchers.IO) {
        try {
            // 1. Verificar cambios pendientes en Room
            val categoriasNoSincronizadas = categoriaDao.getCategoriasNoSincronizadasByUser(userId)

            if (categoriasNoSincronizadas.isNotEmpty()) {
                // HAY CAMBIOS PENDIENTES → Room es fuente de verdad
                Log.d(TAG, "📱 Usando Room (${categoriasNoSincronizadas.size} cambios pendientes)")
                return@withContext categoriaDao.getCategoriasByUser(userId).first()
            } else {
                // NO HAY CAMBIOS PENDIENTES → Intentar Firebase
                Log.d(TAG, "☁️ Intentando Firebase (sin cambios pendientes)")

                if (connectivityObserver.isConnected.first()) {
                    try {
                        val firebaseCategorias = descargarCategoriasDesdeFirebase(userId)
                        if (firebaseCategorias.isNotEmpty()) {
                            // Actualizar Room con datos frescos
                            firebaseCategorias.forEach { categoria ->
                                categoriaDao.insertOrUpdate(categoria.copy(sincronizadoFirebase = true))
                            }
                            Log.d(TAG, "✅ Datos frescos de Firebase aplicados")
                        }
                    } catch (e: Exception) {
                        Log.w(TAG, "⚠️ Error con Firebase, usando Room como fallback", e)
                    }
                }

                // Devolver datos de Room (actualizados o fallback)
                return@withContext categoriaDao.getCategoriasByUser(userId).first()
            }
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error en estrategia híbrida", e)
            // Fallback total a Room
            return@withContext categoriaDao.getCategoriasByUser(userId).first()
        }
    }

    // ========== SINCRONIZACIÓN CON FIREBASE ==========

    /**
     * Sincroniza una categoría específica con Firebase
     */
    private suspend fun sincronizarCategoriaConFirebase(categoria: CategoriaEntity) {
        try {
            if (!connectivityObserver.isConnected.first()) {
                Log.d(TAG, "⚠️ Sin conexión, categría quedará pendiente de sincronización")
                return
            }

            val datos = mapOf(
                "idCategoria" to categoria.idCategoria,
                "userId" to categoria.userId,
                "nombre" to categoria.nombre,
                "colorHex" to categoria.colorHex,
                "orden" to categoria.orden,
                "activa" to categoria.activa,
                "version" to categoria.version,
                "lastModified" to categoria.lastModified,
                "fechaSync" to System.currentTimeMillis()
            )

            firestore.collection("categorias")
                .document(categoria.idCategoria)
                .set(datos)
                .await()

            // Marcar como sincronizada en Room
            categoriaDao.marcarComoSincronizada(categoria.idCategoria)
            Log.d(TAG, "☁️ Categoría sincronizada con Firebase: ${categoria.nombre}")

        } catch (e: Exception) {
            Log.w(TAG, "⚠️ Error sincronizando con Firebase: ${categoria.nombre}", e)
            // La categoría queda marcada como no sincronizada para reintento posterior
        }
    }

    /**
     * Elimina categoría de Firebase
     */
    private suspend fun eliminarCategoriaDeFirebase(categoriaId: String) {
        try {
            if (connectivityObserver.isConnected.first()) {
                firestore.collection("categorias")
                    .document(categoriaId)
                    .delete()
                    .await()
                Log.d(TAG, "☁️ Categoría eliminada de Firebase: $categoriaId")
            }
        } catch (e: Exception) {
            Log.w(TAG, "⚠️ Error eliminando de Firebase: $categoriaId", e)
        }
    }

    /**
     * Sincroniza categorías no sincronizadas cuando hay conexión
     */
    private suspend fun sincronizarCategoriasNoSincronizadas(userId: String) {
        try {
            val pendientes = categoriaDao.getCategoriasNoSincronizadasByUser(userId)
            Log.d(TAG, "🔄 Sincronizando ${pendientes.size} categorías pendientes")

            pendientes.forEach { categoria ->
                sincronizarCategoriaConFirebase(categoria)
                delay(100) // Evitar saturar Firebase
            }
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error sincronizando pendientes", e)
        }
    }

    /**
     * Descarga categorías desde Firebase
     */
    private suspend fun descargarCategoriasDesdeFirebase(userId: String): List<CategoriaEntity> {
        return try {
            val snapshot = firestore.collection("categorias")
                .whereEqualTo("userId", userId)
                .whereEqualTo("activa", true)
                .get()
                .await()

            val categorias = snapshot.documents.mapNotNull { doc ->
                try {
                    val data = doc.data ?: return@mapNotNull null
                    CategoriaEntity(
                        idCategoria = data["idCategoria"] as? String ?: "",
                        userId = data["userId"] as? String ?: "",
                        nombre = data["nombre"] as? String ?: "",
                        colorHex = data["colorHex"] as? String ?: "#FFFFFF",
                        orden = (data["orden"] as? Long)?.toInt() ?: 0,
                        activa = data["activa"] as? Boolean ?: true,
                        version = data["version"] as? Long ?: 1L,
                        lastModified = data["lastModified"] as? Long ?: System.currentTimeMillis(),
                        sincronizadoFirebase = true
                    )
                } catch (e: Exception) {
                    Log.w(TAG, "⚠️ Error parseando categoría de Firebase", e)
                    null
                }
            }

            Log.d(TAG, "☁️ Descargadas ${categorias.size} categorías de Firebase")
            categorias

        } catch (e: Exception) {
            Log.e(TAG, "❌ Error descargando de Firebase", e)
            emptyList()
        }
    }

    // ========== UTILIDADES ==========

    /**
     * Verifica si existe una categoría con el mismo nombre
     */
    suspend fun existeCategoriaConNombre(nombre: String, excludeId: String = ""): Boolean {
        val userId = ConfigurationManager.getCurrentUserId() ?: return false
        return categoriaDao.existeCategoriaConNombre(userId, nombre, excludeId)
    }

    /**
     * Fuerza sincronización completa
     */
    suspend fun forzarSincronizacion(): Boolean = withContext(Dispatchers.IO) {
        try {
            val userId = ConfigurationManager.getCurrentUserId() ?: return@withContext false

            sincronizarCategoriasNoSincronizadas(userId)
            getHybridCategorias(userId) // Esto descargará datos frescos de Firebase

            true
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error en sincronización forzada", e)
            false
        }
    }
}
===== END
===== FILE: ConfiguracionRepository.kt
// app/src/main/java/es/nuskysoftware/marketsales/data/repository/ConfiguracionRepository.kt
package es.nuskysoftware.marketsales.data.repository

import android.content.Context
import android.util.Log
import com.google.firebase.firestore.FirebaseFirestore
import es.nuskysoftware.marketsales.data.local.dao.ConfiguracionDao
import es.nuskysoftware.marketsales.data.local.database.AppDatabase
import es.nuskysoftware.marketsales.data.local.entity.ConfiguracionEntity
import es.nuskysoftware.marketsales.utils.ConnectivityObserver
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.tasks.await
import java.text.SimpleDateFormat
import java.util.*

/**
 * ConfiguracionRepository V10 - SIMPLIFICADO PARA SISTEMA MONOUSUARIO
 *
 * CAMBIOS V10:
 * - Métodos actualizados para nueva estructura ConfiguracionEntity
 * - Agregados métodos para usuarioLogueado
 * - Sincronización con nuevos campos version/lastModified
 * - Eliminados métodos obsoletos (usuarioPassword, versionApp, etc.)
 */
class ConfiguracionRepository(
    context: Context
) {
    private val configuracionDao: ConfiguracionDao = AppDatabase.getDatabase(context).configuracionDao()
    private val firestore = FirebaseFirestore.getInstance()
    private val dateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())
    private val repositoryScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

    // Observador de red
    private val connectivityObserver = ConnectivityObserver(context)

    // Exponer configuración como StateFlow
    val configuracion = configuracionDao.getConfiguracionFlow()
        .stateIn(repositoryScope, SharingStarted.WhileSubscribed(5_000), null)

    init {
        // Cuando volvemos a estar online, reintentamos enviar pendientes
        repositoryScope.launch {
            connectivityObserver.isConnected.collect { online ->
                if (online) {
                    val cfg = configuracionDao.getConfiguracionSync()
                    if (cfg?.pendienteSync == true) {
                        sincronizarConFirebase(cfg)
                    }
                }
            }
        }
    }

    // ========== MÉTODOS PRINCIPALES V10 ==========

    /**
     * Obtiene la configuración actual
     */
    suspend fun getConfiguracion(): ConfiguracionEntity? = withContext(Dispatchers.IO) {
        configuracionDao.getConfiguracionSync()
    }

    /**
     * Crea configuración por defecto si no existe
     */
    suspend fun crearConfiguracionPorDefecto() = withContext(Dispatchers.IO) {
        val existente = configuracionDao.getConfiguracion()
        if (existente == null) {
            val porDefecto = ConfiguracionEntity(
                usuarioLogueado = "usuario_default",
                ultimoDispositivo = android.os.Build.MODEL,
                fechaUltimaSync = dateFormat.format(Date())
            )
            configuracionDao.insertOrUpdate(porDefecto)
            sincronizarConFirebase(porDefecto)
        } else {
            if (existente.fechaUltimaSync == null || existente.pendienteSync) {
                sincronizarConFirebase(existente)
            }
        }
    }

    // ========== CONFIGURACIÓN GLOBAL V10 ==========

    /**
     * Actualiza el idioma (común a todos los usuarios)
     */
    suspend fun updateIdioma(idioma: String) = withContext(Dispatchers.IO) {
        configuracionDao.updateIdioma(idioma)
        sincronizarCampoEspecifico("idioma", idioma)
    }

    /**
     * Actualiza el tema oscuro (común a todos los usuarios)
     */
    suspend fun updateTemaOscuro(esTemaOscuro: Boolean) = withContext(Dispatchers.IO) {
        configuracionDao.updateTemaOscuro(esTemaOscuro)
        sincronizarCampoEspecifico("temaOscuro", esTemaOscuro)
    }

    /**
     * Actualiza la fuente (común a todos los usuarios)
     */
    suspend fun updateFuente(fuente: String) = withContext(Dispatchers.IO) {
        configuracionDao.updateFuente(fuente)
        sincronizarCampoEspecifico("fuente", fuente)
    }

    /**
     * Actualiza la moneda (común a todos los usuarios)
     */
    suspend fun updateMoneda(moneda: String) = withContext(Dispatchers.IO) {
        configuracionDao.updateMoneda(moneda)
        sincronizarCampoEspecifico("moneda", moneda)
    }

    // ========== USUARIO LOGUEADO V10 ==========

    /**
     * Establece el usuario actualmente logueado
     */
    suspend fun setUsuarioLogueado(usuarioUid: String) = withContext(Dispatchers.IO) {
        configuracionDao.setUsuarioLogueado(usuarioUid)
        // No sincronizar este campo con Firebase (es solo local)
    }

    /**
     * Obtiene el usuario actualmente logueado
     */
    suspend fun getUsuarioLogueado(): String? = withContext(Dispatchers.IO) {
        configuracionDao.getUsuarioLogueado()
    }

    /**
     * Verifica si es usuario por defecto
     */
    suspend fun isUsuarioDefault(): Boolean = withContext(Dispatchers.IO) {
        configuracionDao.isUsuarioDefault()
    }

    // ========== SINCRONIZACIÓN V10 ==========

    /**
     * Sincroniza la configuración completa
     */
    suspend fun sincronizar() = withContext(Dispatchers.IO) {
        val cfg = configuracionDao.getConfiguracionSync() ?: return@withContext
        sincronizarConFirebase(cfg)
    }

    /**
     * Sincroniza la configuración completa con Firebase
     */
    private fun sincronizarConFirebase(config: ConfiguracionEntity) {
        try {
            val datos = mapOf(
                "idioma" to config.idioma,
                "temaOscuro" to config.temaOscuro,
                "fuente" to config.fuente,
                "moneda" to config.moneda,
                "numeroVersion" to config.numeroVersion,
                "ultimoDispositivo" to config.ultimoDispositivo,
                "fechaUltimaSync" to dateFormat.format(Date()),
                "version" to config.version,
                "lastModified" to System.currentTimeMillis(),
                "dispositivo" to android.os.Build.MODEL
            )

            // Usar "usuario_default" como documento para configuración global
            val docRef = firestore.collection("configuraciones")
                .document("configuracion_global")

            docRef.set(datos)
                .addOnSuccessListener {
                    repositoryScope.launch {
                        configuracionDao.updateFechaUltimaSync(dateFormat.format(Date()))
                        configuracionDao.updatePendienteSync(false)
                    }
                }
                .addOnFailureListener {
                    repositoryScope.launch {
                        configuracionDao.updatePendienteSync(true)
                    }
                }
        } catch (e: Exception) {
            repositoryScope.launch {
                configuracionDao.updatePendienteSync(true)
            }
        }
    }

    /**
     * Sincroniza un campo específico con Firebase
     */
    private suspend fun sincronizarCampoEspecifico(campo: String, valor: Any) {
        try {
            val datos = mapOf(
                campo to valor,
                "fechaUltimaSync" to dateFormat.format(Date()),
                "lastModified" to System.currentTimeMillis()
            )

            firestore.collection("configuraciones")
                .document("configuracion_global")
                .update(datos)
                .addOnSuccessListener {
                    repositoryScope.launch {
                        configuracionDao.updateFechaUltimaSync(dateFormat.format(Date()))
                        configuracionDao.updatePendienteSync(false)
                    }
                }
                .addOnFailureListener {
                    repositoryScope.launch {
                        configuracionDao.updatePendienteSync(true)
                    }
                }
        } catch (e: Exception) {
            repositoryScope.launch {
                configuracionDao.updatePendienteSync(true)
            }
        }
    }
    suspend fun getHybridConfiguracion(): ConfiguracionEntity? = withContext(Dispatchers.IO) {
        try {
            // 1. Verificar si hay cambios pendientes en Room
            val roomConfig = configuracionDao.getConfiguracionSync()
            val hasPendingChanges = roomConfig?.pendienteSync == true

            if (hasPendingChanges) {
                // ✅ HAY CAMBIOS PENDIENTES → Leer de Room (fuente de verdad)
                Log.d("ConfiguracionRepository", "📱 Leyendo configuración de ROOM (cambios pendientes)")
                return@withContext roomConfig
            } else {
                // ✅ NO HAY CAMBIOS PENDIENTES → Leer de Firebase (más actualizado)
                Log.d("ConfiguracionRepository", "☁️ Leyendo configuración de FIREBASE (sin cambios pendientes)")

                if (connectivityObserver.isConnected.first()) {
                    try {
                        val firebaseDoc = firestore.collection("configuraciones")
                            .document("configuracion_global")
                            .get()
                            .await()

                        if (firebaseDoc.exists()) {
                            val firebaseData = firebaseDoc.data!!

                            // Crear entidad híbrida: Firebase + datos locales importantes
                            val hybridConfig = roomConfig?.copy(
                                // Datos de Firebase (comunes)
                                moneda = firebaseData["moneda"] as? String ?: roomConfig.moneda,
                                idioma = firebaseData["idioma"] as? String ?: roomConfig.idioma,
                                fuente = firebaseData["fuente"] as? String ?: roomConfig.fuente,
                                temaOscuro = firebaseData["temaOscuro"] as? Boolean ?: roomConfig.temaOscuro,

                                // Datos locales (específicos del dispositivo)
                                usuarioLogueado = roomConfig.usuarioLogueado, // Mantener local
                                pendienteSync = false // Marcar como sincronizado
                            ) ?: ConfiguracionEntity(
                                moneda = firebaseData["moneda"] as? String ?: "€ Euro",
                                idioma = firebaseData["idioma"] as? String ?: "es",
                                fuente = firebaseData["fuente"] as? String ?: "Montserrat",
                                temaOscuro = firebaseData["temaOscuro"] as? Boolean ?: false
                            )

                            // Actualizar Room con datos frescos
                            configuracionDao.insertOrUpdate(hybridConfig)

                            Log.d("ConfiguracionRepository", "✅ Configuración fresca de Firebase aplicada")
                            return@withContext hybridConfig
                        }
                    } catch (e: Exception) {
                        Log.w("ConfiguracionRepository", "❌ Error leyendo Firebase, usando Room", e)
                    }
                }

                // Fallback: usar Room
                return@withContext roomConfig ?: ConfiguracionEntity()
            }

        } catch (e: Exception) {
            Log.e("ConfiguracionRepository", "Error en estrategia híbrida", e)
            // En caso de error, devolver lo que tengamos en Room o crear configuración por defecto
            val fallbackConfig = configuracionDao.getConfiguracionSync()
            return@withContext fallbackConfig ?: ConfiguracionEntity()
        }
    }
    // ========== MÉTODOS OBSOLETOS V10 (compatibilidad) ==========

    @Deprecated("Usar updateIdioma()", ReplaceWith("updateIdioma(idioma)"))
    suspend fun actualizarIdioma(idioma: String) = updateIdioma(idioma)

    @Deprecated("Usar updateTemaOscuro()", ReplaceWith("updateTemaOscuro(esTemaOscuro)"))
    suspend fun actualizarTema(esTemaOscuro: Boolean) = updateTemaOscuro(esTemaOscuro)

    @Deprecated("Usar updateFuente()", ReplaceWith("updateFuente(fuente)"))
    suspend fun actualizarFuente(fuente: String) = updateFuente(fuente)

    @Deprecated("Usar updateMoneda()", ReplaceWith("updateMoneda(moneda)"))
    suspend fun actualizarMoneda(moneda: String) = updateMoneda(moneda)

    @Deprecated("Campo eliminado en V10 - usar UserRepository", ReplaceWith("UserRepository.updateUserPassword()"))
    suspend fun actualizarPassword(password: String) {
        // No-op en V10
    }

    @Deprecated("Campo eliminado en V10 - usar UserRepository", ReplaceWith("UserRepository.updateUserPremium()"))
    suspend fun actualizarVersionApp(version: Int) {
        // No-op en V10
    }

    @Deprecated("Campo eliminado en V10 - usar UserRepository", ReplaceWith("UserRepository.updateUserEmail()"))
    suspend fun actualizarUsuarioEmail(email: String) {
        // No-op en V10
    }
}

===== END
===== FILE: MercadilloRepository.kt
// app/src/main/java/es/nuskysoftware/marketsales/data/repository/MercadilloRepository.kt
package es.nuskysoftware.marketsales.data.repository

import android.content.Context
import android.util.Log
import com.google.firebase.firestore.FirebaseFirestore
import es.nuskysoftware.marketsales.data.local.dao.MercadilloDao
import es.nuskysoftware.marketsales.data.local.dao.EstadisticaEstado
import es.nuskysoftware.marketsales.data.local.database.AppDatabase
import es.nuskysoftware.marketsales.data.local.entity.MercadilloEntity
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.ConnectivityObserver
import es.nuskysoftware.marketsales.utils.EstadosMercadillo
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.flatMapLatest
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.tasks.await
import java.text.SimpleDateFormat
import java.util.*

/**
 * MercadilloRepository V11 - Market Sales
 *
 * ARQUITECTURA HÍBRIDA "RELOJ SUIZO":
 * - Local First: Toda operación se ejecuta primero en Room
 * - Sync When Possible: Sincronización automática cuando hay conexión
 * - Never Block UI: La interfaz nunca espera operaciones de red
 * - Graceful Degradation: Funcionamiento completo offline
 * - Estados automáticos: Actualización automática de estados según lógica de negocio
 * - Filtrado por usuario: Cada usuario solo ve sus datos
 */
class MercadilloRepository(
    context: Context
) {
    private val mercadilloDao: MercadilloDao = AppDatabase.getDatabase(context).mercadilloDao()
    private val firestore = FirebaseFirestore.getInstance()
    private val connectivityObserver = ConnectivityObserver(context)
    private val repositoryScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

    // Formateadores de fecha
    private val dateFormat = SimpleDateFormat("dd-MM-yyyy", Locale.getDefault())
    private val timeFormat = SimpleDateFormat("HH:mm", Locale.getDefault())

    companion object {
        private const val TAG = "MercadilloRepository"
    }

    init {
        // Sincronización automática cuando volvemos online
        repositoryScope.launch {
            connectivityObserver.isConnected.collect { online ->
                if (online) {
                    val userId = ConfigurationManager.getCurrentUserId()
                    if (userId != null) {
                        sincronizarMercadillosNoSincronizados(userId)
                        actualizarEstadosAutomaticos(userId)
                    }
                }
            }
        }

        // Actualización periódica de estados (cada 5 minutos)
        repositoryScope.launch {
            while (true) {
                delay(5 * 60 * 1000) // 5 minutos
                val userId = ConfigurationManager.getCurrentUserId()
                if (userId != null) {
                    actualizarEstadosAutomaticos(userId)
                }
            }
        }
    }

    /**
     * Obtiene el próximo mercadillo para un usuario específico
     */
    suspend fun getProximoMercadilloPorUsuario(userId: String, fechaActual: String): MercadilloEntity? = withContext(Dispatchers.IO) {
        Log.d(TAG, "🔍 Buscando próximo mercadillo para usuario: $userId en fecha: $fechaActual")
        return@withContext mercadilloDao.getProximoMercadillo(userId, fechaActual)
    }

    /**
     * Obtiene todos los mercadillos del usuario actual - VERSION REACTIVA
     */
    fun getMercadillosUsuarioActual(): Flow<List<MercadilloEntity>> {
        return ConfigurationManager.usuarioLogueado.flatMapLatest { userId ->
            val effectiveUserId = when {
                userId == null || userId == "usuario_default" -> "usuario_default"
                else -> userId
            }
            Log.d(TAG, "🔄 Usuario cambió a: $effectiveUserId - Recargando mercadillos")
            mercadilloDao.getMercadillosByUser(effectiveUserId)
        }
    }

    /**
     * Obtiene mercadillos de un mes específico - VERSION REACTIVA
     */
    fun getMercadillosPorMes(ano: Int, mes: Int): Flow<List<MercadilloEntity>> {
        return ConfigurationManager.usuarioLogueado.flatMapLatest { userId ->
            val effectiveUserId = when {
                userId == null || userId == "usuario_default" -> "usuario_default"
                else -> userId
            }
            Log.d(TAG, "🔄 Mercadillos mes $mes/$ano para usuario: $effectiveUserId")
            val mesPattern = "${String.format("%02d", mes)}-$ano"
            mercadilloDao.getMercadillosByUserAndMes(effectiveUserId, "%$mesPattern")
        }
    }

    /**
     * Crea un nuevo mercadillo - PATRÓN HÍBRIDO
     */
    suspend fun crearMercadillo(
        fecha: String,
        lugar: String,
        organizador: String,
        esGratis: Boolean = true,
        importeSuscripcion: Double = 0.0,
        requiereMesa: Boolean = true,
        requiereCarpa: Boolean = true,
        hayPuntoLuz: Boolean = false,
        horaInicio: String = "09:00",
        horaFin: String = "14:00",
        saldoInicial: Double? = null // ✅ NUEVO PARÁMETRO OPCIONAL
    ): String = withContext(Dispatchers.IO) {
        val userId = ConfigurationManager.getCurrentUserId()
            ?: throw IllegalStateException("No se puede crear mercadillo sin usuario")

        Log.d(TAG, "🔄 Creando mercadillo para usuario: $userId")

        // Validar conflictos de fecha/hora
        if (mercadilloDao.existeMercadilloEnFechaHora(userId, fecha, horaInicio)) {
            throw IllegalArgumentException("Ya existe un mercadillo en esa fecha y hora")
        }

        val nuevoMercadillo = MercadilloEntity(
            userId = userId,
            fecha = fecha,
            lugar = lugar,
            organizador = organizador,
            esGratis = esGratis,
            importeSuscripcion = if (!esGratis) importeSuscripcion else 0.0,
            requiereMesa = requiereMesa,
            requiereCarpa = requiereCarpa,
            hayPuntoLuz = hayPuntoLuz,
            horaInicio = horaInicio,
            horaFin = horaFin,
            saldoInicial = saldoInicial, // ✅ ASIGNAR SALDO INICIAL
            estado = if (saldoInicial != null) {
                EstadosMercadillo.Estado.PROGRAMADO_TOTAL.codigo // Con saldo = TOTAL
            } else {
                EstadosMercadillo.Estado.PROGRAMADO_PARCIAL.codigo // Sin saldo = PARCIAL
            },
            sincronizadoFirebase = false
        )

        try {
            // 1. GUARDAR EN ROOM PRIMERO (respuesta inmediata)
            mercadilloDao.insertMercadillo(nuevoMercadillo)
            Log.d(TAG, "✅ Mercadillo guardado en Room: $lugar - $fecha${if (saldoInicial != null) " (Saldo: €$saldoInicial)" else ""}")

            // 2. INTENTAR SINCRONIZAR CON FIREBASE
            sincronizarMercadilloConFirebase(nuevoMercadillo)

            return@withContext nuevoMercadillo.idMercadillo

        } catch (e: Exception) {
            Log.e(TAG, "❌ Error creando mercadillo", e)
            throw e
        }
    }

    /**
     * Actualiza un mercadillo existente - PATRÓN HÍBRIDO
     */
    suspend fun actualizarMercadillo(mercadillo: MercadilloEntity): Boolean = withContext(Dispatchers.IO) {
        try {
            val mercadilloActualizado = mercadillo.copy(
                version = mercadillo.version + 1,
                lastModified = System.currentTimeMillis(),
                sincronizadoFirebase = false
            )

            // 1. ACTUALIZAR EN ROOM PRIMERO
            mercadilloDao.updateMercadillo(mercadilloActualizado)
            Log.d(TAG, "✅ Mercadillo actualizado en Room: ${mercadilloActualizado.lugar}")

            // 2. INTENTAR SINCRONIZAR CON FIREBASE
            sincronizarMercadilloConFirebase(mercadilloActualizado)

            true
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error actualizando mercadillo", e)
            false
        }
    }

    /**
     * Elimina un mercadillo - PATRÓN HÍBRIDO
     */
    suspend fun eliminarMercadillo(mercadillo: MercadilloEntity): Boolean = withContext(Dispatchers.IO) {
        try {
            // 1. ELIMINAR DE ROOM PRIMERO
            mercadilloDao.deleteMercadillo(mercadillo)
            Log.d(TAG, "✅ Mercadillo eliminado de Room: ${mercadillo.lugar}")

            // 2. INTENTAR ELIMINAR DE FIREBASE
            eliminarMercadilloDeFirebase(mercadillo.idMercadillo)

            true
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error eliminando mercadillo", e)
            false
        }
    }

    /**
     * Obtiene mercadillo por ID
     */
    suspend fun getMercadilloById(id: String): MercadilloEntity? = withContext(Dispatchers.IO) {
        mercadilloDao.getMercadilloById(id)
    }

    // ========== GESTIÓN DE SALDOS ==========

    /**
     * Asigna saldo inicial a un mercadillo (manual o automático)
     */
    suspend fun asignarSaldoInicial(
        mercadilloId: String,
        saldoInicial: Double,
        esAsignacionAutomatica: Boolean = false
    ): Boolean = withContext(Dispatchers.IO) {
        try {
            mercadilloDao.asignarSaldoInicial(mercadilloId, saldoInicial)

            if (esAsignacionAutomatica) {
                Log.d(TAG, "✅ Saldo inicial asignado automáticamente: €$saldoInicial")
            } else {
                Log.d(TAG, "✅ Saldo inicial asignado manualmente: €$saldoInicial")
            }

            // Sincronizar cambio
            val mercadilloActualizado = mercadilloDao.getMercadilloById(mercadilloId)
            mercadilloActualizado?.let { sincronizarMercadilloConFirebase(it) }

            true
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error asignando saldo inicial", e)
            false
        }
    }

    /**
     * Asigna automáticamente saldo inicial desde el último mercadillo cerrado
     */
    suspend fun asignarSaldoInicialAutomatico(mercadilloId: String): Boolean = withContext(Dispatchers.IO) {
        try {
            val userId = ConfigurationManager.getCurrentUserId() ?: return@withContext false

            val ultimoMercadilloConSaldo = mercadilloDao.getUltimoMercadilloConSaldoFinal(userId)

            if (ultimoMercadilloConSaldo?.saldoFinal != null) {
                val exito = asignarSaldoInicial(
                    mercadilloId = mercadilloId,
                    saldoInicial = ultimoMercadilloConSaldo.saldoFinal,
                    esAsignacionAutomatica = true
                )

                if (exito) {
                    // Marcar el saldo del mercadillo anterior como asignado
                    mercadilloDao.marcarSaldoAsignado(ultimoMercadilloConSaldo.idMercadillo)
                }

                return@withContext exito
            } else {
                Log.d(TAG, "No hay mercadillos anteriores con saldo final para asignar")
                return@withContext false
            }
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error en asignación automática de saldo", e)
            false
        }
    }

    /**
     * Realiza el arqueo de caja de un mercadillo
     */
    suspend fun realizarArqueoCaja(
        mercadilloId: String,
        saldoFinal: Double,
        ventasEfectivo: Double,
        gastosEfectivo: Double
    ): Boolean = withContext(Dispatchers.IO) {
        try {
            val mercadillo = mercadilloDao.getMercadilloById(mercadilloId) ?: return@withContext false
            val saldoInicial = mercadillo.saldoInicial ?: return@withContext false

            val arqueoCaja = saldoInicial + ventasEfectivo - gastosEfectivo

            mercadilloDao.realizarArqueoCaja(mercadilloId, arqueoCaja, saldoFinal)

            Log.d(TAG, "✅ Arqueo de caja realizado: €$arqueoCaja")

            // Sincronizar cambio
            val mercadilloActualizado = mercadilloDao.getMercadilloById(mercadilloId)
            mercadilloActualizado?.let { sincronizarMercadilloConFirebase(it) }

            true
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error realizando arqueo de caja", e)
            false
        }
    }

    // ========== GESTIÓN DE ESTADOS AUTOMÁTICA ==========

    /**
     * Actualiza automáticamente los estados de todos los mercadillos del usuario
     */
    suspend fun actualizarEstadosAutomaticos(userId: String) {
        try {
            val mercadillos = mercadilloDao.getMercadillosByUser(userId).first()
            val fechaActual = dateFormat.format(Date())
            val horaActual = timeFormat.format(Date())

            Log.d(TAG, "🔄 Actualizando estados automáticos para ${mercadillos.size} mercadillos")

            mercadillos.forEach { mercadillo ->
                if (mercadillo.estado != EstadosMercadillo.Estado.CANCELADO.codigo) {
                    val estadoCalculado = EstadosMercadillo.calcularEstadoAutomatico(
                        saldoInicial = mercadillo.saldoInicial,
                        fecha = mercadillo.fecha,
                        horaFin = mercadillo.horaFin,
                        arqueoCaja = mercadillo.arqueoCaja,
                        pendienteAsignarSaldo = mercadillo.pendienteAsignarSaldo,
                        fechaActual = fechaActual,
                        horaActual = horaActual
                    )

                    if (estadoCalculado.codigo != mercadillo.estado) {
                        mercadilloDao.actualizarEstado(mercadillo.idMercadillo, estadoCalculado.codigo)
                        Log.d(TAG, "Estado actualizado: ${mercadillo.lugar} -> ${estadoCalculado.descripcion}")

                        // Marcar para sincronización
                        val mercadilloActualizado = mercadilloDao.getMercadilloById(mercadillo.idMercadillo)
                        mercadilloActualizado?.let { sincronizarMercadilloConFirebase(it) }
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error actualizando estados automáticos", e)
        }
    }

    /**
     * Cancela un mercadillo (solo si no tiene ventas)
     */
    suspend fun cancelarMercadillo(
        mercadilloId: String,
        tieneVentas: Boolean = false
    ): Boolean = withContext(Dispatchers.IO) {
        try {
            val mercadillo = mercadilloDao.getMercadilloById(mercadilloId) ?: return@withContext false
            val estado = EstadosMercadillo.Estado.fromCodigo(mercadillo.estado) ?: return@withContext false

            if (!EstadosMercadillo.puedeSerCancelado(estado, tieneVentas)) {
                Log.w(TAG, "No se puede cancelar el mercadillo: tiene ventas o estado no válido")
                return@withContext false
            }

            // Si tiene saldo inicial, se debería reasignar a otro mercadillo
            // (esta lógica se implementaría en el ViewModel/UI)

            mercadilloDao.cancelarMercadillo(mercadilloId)
            Log.d(TAG, "✅ Mercadillo cancelado: ${mercadillo.lugar}")

            // Sincronizar cambio
            val mercadilloActualizado = mercadilloDao.getMercadilloById(mercadilloId)
            mercadilloActualizado?.let { sincronizarMercadilloConFirebase(it) }

            true
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error cancelando mercadillo", e)
            false
        }
    }

    // ========== CONSULTAS ESPECÍFICAS ==========

    /**
     * Obtiene el próximo mercadillo - VERSION REACTIVA
     */
    suspend fun getProximoMercadillo(): MercadilloEntity? = withContext(Dispatchers.IO) {
        val userId = ConfigurationManager.getCurrentUserId() ?: "usuario_default"
        Log.d(TAG, "🔄 Obteniendo próximo mercadillo para usuario: $userId")
        val fechaActual = dateFormat.format(Date())
        mercadilloDao.getProximoMercadillo(userId, fechaActual)
    }

    /**
     * Obtiene mercadillos que requieren atención - VERSION REACTIVA
     */
    fun getMercadillosRequierenAtencion(): Flow<List<MercadilloEntity>> {
        return ConfigurationManager.usuarioLogueado.flatMapLatest { userId ->
            Log.d(TAG, "🔄 Usuario cambió: $userId - Recargando mercadillos que requieren atención")
            if (userId != null && userId != "usuario_default") {
                mercadilloDao.getMercadillosPendientesArqueo(userId)
            } else {
                flowOf(emptyList())
            }
        }
    }

    /**
     * Obtiene todos los mercadillos desde hoy en adelante para un usuario
     */
    suspend fun getMercadillosDesdeHoy(userId: String): List<MercadilloEntity> = withContext(Dispatchers.IO) {
        try {
            // Obtener fecha actual en formato dd-MM-yyyy
            val fechaActual = dateFormat.format(Date())

            // Usar la nueva consulta del DAO
            val mercadillos = mercadilloDao.getMercadillosDesdeHoy(userId, fechaActual)

            Log.d(TAG, "📅 Encontrados ${mercadillos.size} mercadillos desde $fechaActual para usuario $userId")

            return@withContext mercadillos

        } catch (e: Exception) {
            Log.e(TAG, "❌ Error obteniendo mercadillos desde hoy", e)
            return@withContext emptyList()
        }
    }

    /**
     * Obtiene estadísticas de mercadillos por estado
     */
    suspend fun getEstadisticasPorEstado(): Map<EstadosMercadillo.Estado, Int> = withContext(Dispatchers.IO) {
        val userId = ConfigurationManager.getCurrentUserId() ?: return@withContext emptyMap()

        try {
            val estadisticas = mercadilloDao.getEstadisticasPorEstado(userId)
            return@withContext estadisticas.associate { estadisticaEstado ->
                val estado = EstadosMercadillo.Estado.fromCodigo(estadisticaEstado.estado)
                    ?: EstadosMercadillo.Estado.PROGRAMADO_PARCIAL
                estado to estadisticaEstado.cantidad
            }
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error obteniendo estadísticas", e)
            return@withContext emptyMap()
        }
    }

    // ========== ESTRATEGIA HÍBRIDA INTELIGENTE ==========

    /**
     * Obtiene datos híbridos: combina lo mejor de Room y Firebase
     */
    suspend fun getHybridMercadillos(userId: String): List<MercadilloEntity> = withContext(Dispatchers.IO) {
        try {
            // 1. Verificar cambios pendientes en Room
            val mercadillosNoSincronizados = mercadilloDao.getMercadillosNoSincronizadosByUser(userId)

            if (mercadillosNoSincronizados.isNotEmpty()) {
                // HAY CAMBIOS PENDIENTES → Room es fuente de verdad
                Log.d(TAG, "📱 Usando Room (${mercadillosNoSincronizados.size} cambios pendientes)")
                return@withContext mercadilloDao.getMercadillosByUser(userId).first()
            } else {
                // NO HAY CAMBIOS PENDIENTES → Intentar Firebase
                Log.d(TAG, "☁️ Intentando Firebase (sin cambios pendientes)")

                if (connectivityObserver.isConnected.first()) {
                    try {
                        val firebaseMercadillos = descargarMercadillosDesdeFirebase(userId)
                        if (firebaseMercadillos.isNotEmpty()) {
                            // Actualizar Room con datos frescos
                            firebaseMercadillos.forEach { mercadillo ->
                                mercadilloDao.insertOrUpdate(mercadillo.copy(sincronizadoFirebase = true))
                            }
                            Log.d(TAG, "✅ Datos frescos de Firebase aplicados")
                        }
                    } catch (e: Exception) {
                        Log.w(TAG, "⚠️ Error con Firebase, usando Room como fallback", e)
                    }
                }

                // Devolver datos de Room (actualizados o fallback)
                return@withContext mercadilloDao.getMercadillosByUser(userId).first()
            }
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error en estrategia híbrida", e)
            // Fallback total a Room
            return@withContext mercadilloDao.getMercadillosByUser(userId).first()
        }
    }

    // ========== SINCRONIZACIÓN CON FIREBASE ==========

    /**
     * Sincroniza un mercadillo específico con Firebase
     */
    private suspend fun sincronizarMercadilloConFirebase(mercadillo: MercadilloEntity) {
        try {
            if (!connectivityObserver.isConnected.first()) {
                Log.d(TAG, "⚠️ Sin conexión, mercadillo quedará pendiente de sincronización")
                return
            }

            val datos = mapOf(
                "idMercadillo" to mercadillo.idMercadillo,
                "userId" to mercadillo.userId,
                "fecha" to mercadillo.fecha,
                "lugar" to mercadillo.lugar,
                "organizador" to mercadillo.organizador,
                "esGratis" to mercadillo.esGratis,
                "importeSuscripcion" to mercadillo.importeSuscripcion,
                "requiereMesa" to mercadillo.requiereMesa,
                "requiereCarpa" to mercadillo.requiereCarpa,
                "hayPuntoLuz" to mercadillo.hayPuntoLuz,
                "horaInicio" to mercadillo.horaInicio,
                "horaFin" to mercadillo.horaFin,
                "estado" to mercadillo.estado,
                "pendienteArqueo" to mercadillo.pendienteArqueo,
                "pendienteAsignarSaldo" to mercadillo.pendienteAsignarSaldo,
                "saldoInicial" to mercadillo.saldoInicial,
                "saldoFinal" to mercadillo.saldoFinal,
                "arqueoCaja" to mercadillo.arqueoCaja,
                "totalVentas" to mercadillo.totalVentas,
                "totalGastos" to mercadillo.totalGastos,
                "arqueoMercadillo" to mercadillo.arqueoMercadillo,
                "activo" to mercadillo.activo,
                "version" to mercadillo.version,
                "lastModified" to mercadillo.lastModified,
                "fechaSync" to System.currentTimeMillis()
            )

            firestore.collection("mercadillos")
                .document(mercadillo.idMercadillo)
                .set(datos)
                .await()

            // Marcar como sincronizado en Room
            mercadilloDao.marcarComoSincronizado(mercadillo.idMercadillo)
            Log.d(TAG, "☁️ Mercadillo sincronizado con Firebase: ${mercadillo.lugar}")

        } catch (e: Exception) {
            Log.w(TAG, "⚠️ Error sincronizando con Firebase: ${mercadillo.lugar}", e)
            // El mercadillo queda marcado como no sincronizado para reintento posterior
        }
    }

    /**
     * Elimina mercadillo de Firebase
     */
    private suspend fun eliminarMercadilloDeFirebase(mercadilloId: String) {
        try {
            if (connectivityObserver.isConnected.first()) {
                firestore.collection("mercadillos")
                    .document(mercadilloId)
                    .delete()
                    .await()
                Log.d(TAG, "☁️ Mercadillo eliminado de Firebase: $mercadilloId")
            }
        } catch (e: Exception) {
            Log.w(TAG, "⚠️ Error eliminando de Firebase: $mercadilloId", e)
        }
    }

    /**
     * Sincroniza mercadillos no sincronizados cuando hay conexión
     */
    private suspend fun sincronizarMercadillosNoSincronizados(userId: String) {
        try {
            val pendientes = mercadilloDao.getMercadillosNoSincronizadosByUser(userId)
            Log.d(TAG, "🔄 Sincronizando ${pendientes.size} mercadillos pendientes")

            pendientes.forEach { mercadillo ->
                sincronizarMercadilloConFirebase(mercadillo)
                delay(100) // Evitar saturar Firebase
            }
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error sincronizando pendientes", e)
        }
    }

    /**
     * Descarga mercadillos desde Firebase
     */
    private suspend fun descargarMercadillosDesdeFirebase(userId: String): List<MercadilloEntity> {
        return try {
            val snapshot = firestore.collection("mercadillos")
                .whereEqualTo("userId", userId)
                .whereEqualTo("activo", true)
                .get()
                .await()

            val mercadillos = snapshot.documents.mapNotNull { doc ->
                try {
                    val data = doc.data ?: return@mapNotNull null
                    MercadilloEntity(
                        idMercadillo = data["idMercadillo"] as? String ?: "",
                        userId = data["userId"] as? String ?: "",
                        fecha = data["fecha"] as? String ?: "",
                        lugar = data["lugar"] as? String ?: "",
                        organizador = data["organizador"] as? String ?: "",
                        esGratis = data["esGratis"] as? Boolean ?: true,
                        importeSuscripcion = (data["importeSuscripcion"] as? Number)?.toDouble() ?: 0.0,
                        requiereMesa = data["requiereMesa"] as? Boolean ?: true,
                        requiereCarpa = data["requiereCarpa"] as? Boolean ?: true,
                        hayPuntoLuz = data["hayPuntoLuz"] as? Boolean ?: false,
                        horaInicio = data["horaInicio"] as? String ?: "09:00",
                        horaFin = data["horaFin"] as? String ?: "14:00",
                        estado = (data["estado"] as? Long)?.toInt() ?: 1,
                        pendienteArqueo = data["pendienteArqueo"] as? Boolean ?: false,
                        pendienteAsignarSaldo = data["pendienteAsignarSaldo"] as? Boolean ?: false,
                        saldoInicial = (data["saldoInicial"] as? Number)?.toDouble(),
                        saldoFinal = (data["saldoFinal"] as? Number)?.toDouble(),
                        arqueoCaja = (data["arqueoCaja"] as? Number)?.toDouble(),
                        totalVentas = (data["totalVentas"] as? Number)?.toDouble() ?: 0.0,
                        totalGastos = (data["totalGastos"] as? Number)?.toDouble() ?: 0.0,
                        arqueoMercadillo = (data["arqueoMercadillo"] as? Number)?.toDouble(),
                        activo = data["activo"] as? Boolean ?: true,
                        version = data["version"] as? Long ?: 1L,
                        lastModified = data["lastModified"] as? Long ?: System.currentTimeMillis(),
                        sincronizadoFirebase = true
                    )
                } catch (e: Exception) {
                    Log.w(TAG, "⚠️ Error parseando mercadillo de Firebase", e)
                    null
                }
            }

            Log.d(TAG, "☁️ Descargados ${mercadillos.size} mercadillos de Firebase")
            mercadillos

        } catch (e: Exception) {
            Log.e(TAG, "❌ Error descargando de Firebase", e)
            emptyList()
        }
    }

    // ========== SINCRONIZACIÓN SIN ESTADOS AUTOMÁTICOS ==========

    /**
     * Sincroniza SIN recalcular estados automáticos
     */
    suspend fun sincronizarSinEstadosAutomaticos(): Boolean = withContext(Dispatchers.IO) {
        try {
            val userId = ConfigurationManager.getCurrentUserId() ?: return@withContext false

            // 1. Sincronizar pendientes
            sincronizarMercadillosNoSincronizados(userId)

            // 2. Descargar datos frescos de Firebase
            getHybridMercadillos(userId)

            // 3. NO llamar a actualizarEstadosAutomaticos(userId)

            Log.d(TAG, "✅ Sincronización completada SIN estados automáticos")
            true
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error en sincronización sin estados automáticos", e)
            false
        }
    }

    // ========== UTILIDADES ==========

    /**
     * Fuerza sincronización completa
     */
    suspend fun forzarSincronizacion(): Boolean = withContext(Dispatchers.IO) {
        try {
            val userId = ConfigurationManager.getCurrentUserId() ?: return@withContext false

            sincronizarMercadillosNoSincronizados(userId)
            getHybridMercadillos(userId) // Esto descargará datos frescos de Firebase
            actualizarEstadosAutomaticos(userId) // Actualizar estados tras sincronización

            true
        } catch (e: Exception) {
            false
        }
    }

    // Agregar en MercadilloRepository.kt:

    /**
     * Obtiene mercadillos de una fecha específica para validaciones
     */
    suspend fun getMercadillosPorFecha(userId: String, fecha: String): List<MercadilloEntity> = withContext(Dispatchers.IO) {
        return@withContext mercadilloDao.getMercadillosByUserAndFecha(userId, fecha)
    }
}

===== END
===== FILE: UserRepository.kt
// app/src/main/java/es/nuskysoftware/marketsales/data/repository/UserRepository.kt
package es.nuskysoftware.marketsales.data.repository

import android.content.ContentValues.TAG
import android.content.Context
import android.util.Log
import com.google.firebase.firestore.FirebaseFirestore
import es.nuskysoftware.marketsales.data.local.dao.UserDao
import es.nuskysoftware.marketsales.data.local.database.AppDatabase
import es.nuskysoftware.marketsales.data.local.entity.UserEntity
import es.nuskysoftware.marketsales.utils.ConnectivityObserver
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.tasks.await
import java.text.SimpleDateFormat
import java.util.*

/**
 * UserRepository V10 - SIMPLIFICADO PARA SISTEMA MONOUSUARIO
 *
 * CAMBIOS V10:
 * - Eliminado sistema multiusuario (empresas, invitaciones, roles)
 * - Eliminado configuración personal (ahora es global)
 * - Solo gestiona: datos básicos + esPremium + sincronización
 * - Agregado getOrCreateUser() para AuthRepository
 */
class UserRepository(
    context: Context
) {
    private val userDao: UserDao = AppDatabase.getDatabase(context).userDao()
    private val firestore = FirebaseFirestore.getInstance()
    private val dateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())
    private val repositoryScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

    // Observador de red
    private val connectivityObserver = ConnectivityObserver(context)

    // Exponer usuario actual como StateFlow
    val currentUser = userDao.getCurrentUserFlow()
        .stateIn(repositoryScope, SharingStarted.WhileSubscribed(5_000), null)

    init {
        // Cuando volvemos online, sincronizamos usuarios pendientes
        repositoryScope.launch {
            connectivityObserver.isConnected.collect { online ->
                if (online) {
                    val pendingUsers = userDao.getUsersPendingSync()
                    pendingUsers.forEach { user ->
                        sincronizarUsuarioConFirebase(user)
                    }
                }
            }
        }
    }

    // ========== MÉTODOS PRINCIPALES V10 ==========

    /**
     * ✅ NUEVO: Busca usuario existente o crea uno nuevo (para AuthRepository)
     */
    suspend fun getOrCreateUser(
        uid: String,
        email: String,
        displayName: String = "",
        photoUrl: String = "",
        esPremium: Boolean = false
    ): UserEntity = withContext(Dispatchers.IO) {
        try {
            // 1. Buscar usuario existente en Room
            val existingUser = userDao.getUserByIdSync(uid)
            if (existingUser != null) {
                // Actualizar datos básicos si han cambiado
                if (existingUser.email != email ||
                    existingUser.displayName != displayName ||
                    existingUser.photoUrl != photoUrl
                ) {

                    val updatedUser = existingUser.copy(
                        email = email,
                        displayName = displayName,
                        photoUrl = photoUrl
                    )
                    userDao.insertOrUpdate(updatedUser)
                    sincronizarUsuarioConFirebase(updatedUser)
                    return@withContext updatedUser
                }
                return@withContext existingUser
            }

            // 2. Si no existe, buscar en Firebase
            if (connectivityObserver.isConnected.first()) {
                try {
                    val document = firestore.collection("usuarios")
                        .document(uid)
                        .get()
                        .await()

                    if (document.exists()) {
                        val firebaseUser = mapFirebaseToUserEntity(uid, document.data!!)
                        userDao.insertOrUpdate(firebaseUser)
                        return@withContext firebaseUser
                    }
                } catch (e: Exception) {
                    // Si falla Firebase, crear usuario local
                }
            }

            // 3. Crear usuario nuevo
            val newUser = UserEntity(
                uid = uid,
                email = email,
                displayName = displayName,
                photoUrl = photoUrl,
                esPremium = esPremium
            )

            userDao.insertOrUpdate(newUser)
            sincronizarUsuarioConFirebase(newUser)

            return@withContext newUser

        } catch (e: Exception) {
            // En caso de error, crear usuario mínimo
            val fallbackUser = UserEntity(
                uid = uid,
                email = email,
                displayName = displayName,
                photoUrl = photoUrl,
                esPremium = esPremium
            )
            userDao.insertOrUpdate(fallbackUser)
            return@withContext fallbackUser
        }
    }

    /**
     * Obtiene un usuario por ID
     */
    suspend fun getUserById(uid: String): UserEntity? = withContext(Dispatchers.IO) {
        userDao.getUserByIdSync(uid)
    }

    /**
     * Actualiza el estado Premium del usuario
     */
    suspend fun updateUserPremium(uid: String, esPremium: Boolean) = withContext(Dispatchers.IO) {
        userDao.updateUserPremium(uid, esPremium)
        sincronizarCampoEspecifico(uid, "esPremium", esPremium)
    }

    /**
     * Actualiza el email del usuario
     */
    suspend fun updateUserEmail(uid: String, email: String) = withContext(Dispatchers.IO) {
        userDao.updateUserEmail(uid, email)
        sincronizarCampoEspecifico(uid, "email", email)
    }

    /**
     * Actualiza el nombre del usuario
     */
    suspend fun updateUserDisplayName(uid: String, displayName: String) =
        withContext(Dispatchers.IO) {
            userDao.updateUserDisplayName(uid, displayName)
            sincronizarCampoEspecifico(uid, "displayName", displayName)
        }

    /**
     * Actualiza la foto del usuario
     */
    suspend fun updateUserPhotoUrl(uid: String, photoUrl: String) = withContext(Dispatchers.IO) {
        userDao.updateUserPhotoUrl(uid, photoUrl)
        sincronizarCampoEspecifico(uid, "photoUrl", photoUrl)
    }

    /**
     * Busca usuario por email
     */
    suspend fun getUserByEmail(email: String): UserEntity? = withContext(Dispatchers.IO) {
        userDao.getUserByEmail(email)
    }

    /**
     * Obtiene todos los usuarios Premium
     */
    suspend fun getAllPremiumUsers(): List<UserEntity> = withContext(Dispatchers.IO) {
        userDao.getAllPremiumUsers()
    }

    /**
     * Obtiene todos los usuarios Free
     */
    suspend fun getAllFreeUsers(): List<UserEntity> = withContext(Dispatchers.IO) {
        userDao.getAllFreeUsers()
    }

    /**
     * Sincroniza un usuario específico
     */
    suspend fun sincronizar(userId: String) = withContext(Dispatchers.IO) {
        val user = userDao.getUserByIdSync(userId) ?: return@withContext
        sincronizarUsuarioConFirebase(user)
    }

    // ========== MÉTODOS DE SINCRONIZACIÓN V10 ==========

    /**
     * Sincroniza usuario completo con Firebase
     */
    private fun sincronizarUsuarioConFirebase(user: UserEntity) {
        try {
            val datos = mapOf(
                "uid" to user.uid,
                "email" to user.email,
                "displayName" to user.displayName,
                "photoUrl" to user.photoUrl,
                "esPremium" to user.esPremium,
                "version" to user.version,
                "lastModified" to user.lastModified,
                "fechaCreacion" to user.fechaCreacion,
                "fechaUltimaSync" to dateFormat.format(Date()),
                "activo" to user.activo
            )

            val docRef = firestore.collection("usuarios")
                .document(user.uid)

            docRef.set(datos)
                .addOnSuccessListener {
                    repositoryScope.launch {
                        userDao.markUserSyncSuccessful(user.uid, user.version + 1)
                        userDao.updateFechaUltimaSync(user.uid, dateFormat.format(Date()))
                    }
                }
                .addOnFailureListener {
                    repositoryScope.launch {
                        // El usuario queda marcado como no sincronizado hasta próximo intento
                    }
                }

        } catch (e: Exception) {
            // Error en sincronización, se reintentará cuando haya conexión
        }
    }

    /**
     * Sincroniza un campo específico del usuario
     */
    private suspend fun sincronizarCampoEspecifico(userId: String, campo: String, valor: Any) {
        try {
            val datos = mapOf(
                campo to valor,
                "lastModified" to System.currentTimeMillis(),
                "fechaUltimaSync" to dateFormat.format(Date())
            )

            firestore.collection("usuarios")
                .document(userId)
                .update(datos)
                .await()

            // Marcar como sincronizado
            userDao.markUserSyncSuccessful(userId, userDao.getUserVersion(userId) ?: 1L + 1)

        } catch (e: Exception) {
            // El campo queda marcado como no sincronizado
        }
    }

    // ========== MÉTODOS AUXILIARES ==========

    /**
     * Convierte datos de Firebase a UserEntity V10
     */
    private fun mapFirebaseToUserEntity(userId: String, data: Map<String, Any>): UserEntity {
        return UserEntity(
            uid = userId,
            email = data["email"] as? String ?: "",
            displayName = data["displayName"] as? String ?: "",
            photoUrl = data["photoUrl"] as? String ?: "",
            esPremium = data["esPremium"] as? Boolean ?: false,
            version = data["version"] as? Long ?: 1L,
            lastModified = data["lastModified"] as? Long ?: System.currentTimeMillis(),
            sincronizadoFirebase = true, // Viene de Firebase, está sincronizado
            fechaCreacion = data["fechaCreacion"] as? Long ?: System.currentTimeMillis(),
            fechaUltimaSync = dateFormat.format(Date()),
            activo = data["activo"] as? Boolean ?: true
        )
    }

    // ========== MÉTODOS OBSOLETOS V10 (compatibilidad) ==========

    @Deprecated(
        "Usar getOrCreateUser()",
        ReplaceWith("getOrCreateUser(userId, \"\", \"\", \"\", false)")
    )
    suspend fun loadUserData(userId: String): UserEntity? {
        return getOrCreateUser(userId, "", "", "", false)
    }

    @Deprecated(
        "Sistema multiusuario eliminado en V10",
        ReplaceWith("updateUserPremium(userId, premium)")
    )
    suspend fun updateUserPlan(userId: String, planUsuario: String, empresaId: String? = null) {
        updateUserPremium(userId, planUsuario == "PREMIUM")
    }

    @Deprecated(
        "Sistema multiusuario eliminado en V10",
        ReplaceWith("updateUserPremium(userId, true)")
    )
    suspend fun createCompany(userId: String, companyName: String, companyEmail: String): String {
        updateUserPremium(userId, true)
        return "empresa_${System.currentTimeMillis()}" // ID dummy para compatibilidad
    }

    @Deprecated(
        "Sistema multiusuario eliminado en V10",
        ReplaceWith("updateUserPremium(userId, true)")
    )
    suspend fun updateUserType(userId: String, tipoUsuario: String) {
        // En V10, solo distinguimos Premium/Free
        updateUserPremium(userId, tipoUsuario != "FREE")
    }

    @Deprecated("Sistema multiusuario eliminado en V10", ReplaceWith("false"))
    suspend fun inviteUserToCompany(
        email: String,
        empresaId: String,
        tipoUsuario: String
    ): Boolean {
        return false // No soportado en V10
    }

    @Deprecated(
        "Configuración personal eliminada en V10 - ahora global",
        ReplaceWith("ConfiguracionRepository.updateIdioma()")
    )
    suspend fun updateUserIdioma(userId: String, idioma: String) {
        // No-op en V10
    }

    @Deprecated(
        "Configuración personal eliminada en V10 - ahora global",
        ReplaceWith("ConfiguracionRepository.updateFuente()")
    )
    suspend fun updateUserFuente(userId: String, fuente: String) {
        // No-op en V10
    }

    @Deprecated(
        "Configuración personal eliminada en V10 - ahora global",
        ReplaceWith("ConfiguracionRepository.updateTemaOscuro()")
    )
    suspend fun updateUserModoOscuro(userId: String, modoOscuro: Boolean) {
        // No-op en V10
    }

    @Deprecated(
        "Configuración personal eliminada en V10 - ahora global",
        ReplaceWith("ConfiguracionRepository métodos individuales")
    )
    suspend fun updateUserConfiguration(
        userId: String,
        idioma: String,
        fuente: String,
        modoOscuro: Boolean
    ) {
        // No-op en V10 - La configuración ahora es global
    }
    // ========== REEMPLAZA el método getHybridUserData() en UserRepository.kt ==========

    suspend fun getHybridUserData(uid: String): UserEntity? = withContext(Dispatchers.IO) {
        try {
            // 1. Verificar si hay datos pendientes de sincronizar en Room
            val roomUser = userDao.getUserByIdSync(uid)
            val hasPendingChanges = roomUser?.sincronizadoFirebase == false

            if (hasPendingChanges) {
                // ✅ HAY CAMBIOS PENDIENTES → Leer de Room (fuente de verdad)
                Log.d("UserRepository", "📱 Leyendo de ROOM (cambios pendientes): $uid")
                return@withContext roomUser
            } else {
                // ✅ NO HAY CAMBIOS PENDIENTES → Leer de Firebase (más actualizado)
                Log.d("UserRepository", "☁️ Leyendo de FIREBASE (sin cambios pendientes): $uid")

                if (connectivityObserver.isConnected.first()) {
                    try {
                        val firebaseDoc = firestore.collection("usuarios")
                            .document(uid)
                            .get()
                            .await()

                        if (firebaseDoc.exists()) {
                            val firebaseUser = mapFirebaseToUserEntity(uid, firebaseDoc.data!!)

                            // Actualizar Room con datos frescos de Firebase
                            userDao.insertOrUpdate(firebaseUser.copy(sincronizadoFirebase = true))

                            Log.d("UserRepository", "✅ Datos frescos de Firebase aplicados a Room")
                            return@withContext firebaseUser
                        }
                    } catch (e: Exception) {
                        Log.w(
                            "UserRepository",
                            "❌ Error leyendo Firebase, usando Room como fallback",
                            e
                        )
                    }
                }

                // Fallback: usar Room si Firebase falla o no hay conexión
                return@withContext roomUser ?: getOrCreateUser(uid, "", "", "", false)
            }

        } catch (e: Exception) {
            Log.e("UserRepository", "Error en estrategia híbrida", e)
            // En caso de error, devolver lo que tengamos en Room o crear usuario básico
            val fallbackUser = userDao.getUserByIdSync(uid)
            return@withContext fallbackUser ?: getOrCreateUser(uid, "", "", "", false)
        }
    }
    // En UserRepository.kt
    suspend fun updateUserProfile(userId: String, displayName: String, email: String) {
        try {
            userDao.updateUserProfile(userId, displayName, email)
            Log.d(TAG, "✅ Perfil actualizado en Room: $displayName, $email")
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error actualizando perfil en Room", e)
        }
    }
    suspend fun updateUserProfileAndMarkDirty(userId: String, displayName: String, email: String) = withContext(Dispatchers.IO) {
        try {
            // 1. Actualizar los datos en Room
            userDao.updateUserProfile(userId, displayName, email)

            // 2. ✅ CLAVE: Marcar como NO SINCRONIZADO para que getHybridUserData use Room
            userDao.markUserNotSynced(userId)

            Log.d("UserRepository", "✅ Perfil actualizado y marcado como no sincronizado")
            Log.d("UserRepository", "   - displayName: $displayName")
            Log.d("UserRepository", "   - sincronizadoFirebase: false")

        } catch (e: Exception) {
            Log.e("UserRepository", "❌ Error actualizando perfil", e)
        }
    }
    suspend fun refreshUserData(uid: String) = withContext(Dispatchers.IO) {
        try {
            // Forzar lectura de Firebase y actualizar Room
            if (connectivityObserver.isConnected.first()) {
                val firebaseDoc = firestore.collection("usuarios")
                    .document(uid)
                    .get()
                    .await()

                if (firebaseDoc.exists()) {
                    val firebaseUser = mapFirebaseToUserEntity(uid, firebaseDoc.data!!)
                    userDao.insertOrUpdate(firebaseUser.copy(sincronizadoFirebase = true))
                    Log.d("UserRepository", "✅ Datos de usuario refrescados desde Firebase")
                }
            }
        } catch (e: Exception) {
            Log.w("UserRepository", "❌ Error refrescando datos de usuario", e)
        }
    }

    // Método auxiliar para obtener usuario actual (si no existe)
    suspend fun getCurrentUser(): UserEntity? = withContext(Dispatchers.IO) {
        currentUser.value
    }
}
===== END
===== FILE: VentasRepository.kt
// app/src/main/java/es/nuskysoftware/marketsales/data/repository/VentasRepository.kt
package es.nuskysoftware.marketsales.data.repository

import android.content.Context
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import es.nuskysoftware.marketsales.data.local.database.AppDatabase
import es.nuskysoftware.marketsales.data.local.dao.LineasVentaDao
import es.nuskysoftware.marketsales.data.local.dao.RecibosDao
import es.nuskysoftware.marketsales.data.local.entity.LineaVentaEntity
import es.nuskysoftware.marketsales.data.local.entity.ReciboEntity
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.tasks.await
import java.util.*

class VentasRepository(context: Context) {

    private val database = AppDatabase.getDatabase(context)
    private val recibosDao: RecibosDao = database.recibosDao()
    private val lineasVentaDao: LineasVentaDao = database.lineasVentaDao()
    private val firestore = FirebaseFirestore.getInstance()
    private val auth = FirebaseAuth.getInstance()

    // ✅ GUARDAR VENTA COMPLETA
    suspend fun guardarVenta(
        idMercadillo: String,
        lineas: List<LineaVentaUI>,
        metodoPago: String,
        total: Double
    ): Result<String> {
        return try {
            val userId = auth.currentUser?.uid ?: throw Exception("Usuario no autenticado")
            val reciboId = UUID.randomUUID().toString()
            val timestamp = System.currentTimeMillis()

            // Crear recibo
            val recibo = ReciboEntity(
                idRecibo = reciboId,
                idMercadillo = idMercadillo,
                idUsuario = userId,
                fechaHora = timestamp,
                metodoPago = metodoPago,
                totalTicket = total,
                estado = "COMPLETADO"
            )

            // Crear líneas
            val lineasEntity = lineas.mapIndexed { index, linea ->
                LineaVentaEntity(
                    idLinea = UUID.randomUUID().toString(),
                    idRecibo = reciboId,
                    idMercadillo = idMercadillo,
                    idUsuario = userId,
                    numeroLinea = index + 1,
                    tipoLinea = linea.tipoLinea.name,
                    descripcion = linea.descripcion,
                    idProducto = linea.idProducto,
                    cantidad = linea.cantidad,
                    precioUnitario = linea.precioUnitario,
                    subtotal = linea.subtotal,
                    idLineaOriginalAbonada = linea.idLineaOriginalAbonada
                )
            }

            // Guardar en Room primero
            recibosDao.insertarRecibo(recibo)
            lineasVentaDao.insertarLineas(lineasEntity)

            // Intentar guardar en Firebase
            try {
                firestore.collection("recibos")
                    .document(reciboId)
                    .set(recibo)
                    .await()

                lineasEntity.forEach { linea ->
                    firestore.collection("lineas_venta")
                        .document(linea.idLinea)
                        .set(linea)
                        .await()
                }
            } catch (e: Exception) {
                // Si falla Firebase, continúa (ya está en Room)
                println("Error guardando en Firebase: ${e.message}")
            }

            Result.success(reciboId)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    // ✅ OBTENER VENTAS DEL MERCADILLO
    fun obtenerVentasMercadillo(idMercadillo: String): Flow<List<ReciboEntity>> {
        return recibosDao.obtenerRecibosPorMercadillo(idMercadillo)
    }

    // ✅ OBTENER LÍNEAS DE UNA VENTA
    fun obtenerLineasVenta(idRecibo: String): Flow<List<LineaVentaEntity>> {
        return lineasVentaDao.obtenerLineasPorRecibo(idRecibo)
    }

    // ✅ CREAR ABONO
    suspend fun crearAbono(
        lineaOriginal: LineaVentaEntity,
        cantidadAbonar: Int,
        idMercadillo: String
    ): Result<String> {
        return try {
            val userId = auth.currentUser?.uid ?: throw Exception("Usuario no autenticado")
            val reciboId = UUID.randomUUID().toString()
            val timestamp = System.currentTimeMillis()

            // Recibo de abono
            val reciboAbono = ReciboEntity(
                idRecibo = reciboId,
                idMercadillo = idMercadillo,
                idUsuario = userId,
                fechaHora = timestamp,
                metodoPago = "ABONO",
                totalTicket = -(lineaOriginal.precioUnitario * cantidadAbonar),
                estado = "COMPLETADO"
            )

            // Línea de abono
            val lineaAbono = LineaVentaEntity(
                idLinea = UUID.randomUUID().toString(),
                idRecibo = reciboId,
                idMercadillo = idMercadillo,
                idUsuario = userId,
                numeroLinea = 1,
                tipoLinea = lineaOriginal.tipoLinea,
                descripcion = "ABONO: ${lineaOriginal.descripcion}",
                idProducto = lineaOriginal.idProducto,
                cantidad = -cantidadAbonar,
                precioUnitario = lineaOriginal.precioUnitario,
                subtotal = -(lineaOriginal.precioUnitario * cantidadAbonar),
                idLineaOriginalAbonada = lineaOriginal.idLinea
            )

            // Guardar en Room
            recibosDao.insertarRecibo(reciboAbono)
            lineasVentaDao.insertarLinea(lineaAbono)

            // Intentar guardar en Firebase
            try {
                firestore.collection("recibos")
                    .document(reciboId)
                    .set(reciboAbono)
                    .await()

                firestore.collection("lineas_venta")
                    .document(lineaAbono.idLinea)
                    .set(lineaAbono)
                    .await()
            } catch (e: Exception) {
                println("Error guardando abono en Firebase: ${e.message}")
            }

            Result.success(reciboId)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

// ✅ MODELOS DE UI
data class LineaVentaUI(
    val id: String = UUID.randomUUID().toString(),
    val tipoLinea: TipoLinea,
    val descripcion: String,
    val idProducto: String? = null,
    val cantidad: Int,
    val precioUnitario: Double,
    val subtotal: Double,
    val idLineaOriginalAbonada: String? = null
)

enum class TipoLinea { MANUAL, PRODUCTO }
enum class MetodoPago { EFECTIVO, BIZUM, TARJETA }
enum class PestanaVenta { MANUAL, PRODUCTOS }
===== END
===== FILE: BottomBarMercadillo.kt
// app/src/main/java/es/nuskysoftware/marketsales/ui/components/BottomBarMercadillo.kt
package es.nuskysoftware.marketsales.ui.components

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import es.nuskysoftware.marketsales.R
import es.nuskysoftware.marketsales.data.local.entity.MercadilloEntity
import es.nuskysoftware.marketsales.utils.StringResourceManager

/**
 * BottomBar para operaciones con mercadillos activos
 * Solo se muestra cuando hay mercadillos en estado EN_CURSO
 */
@Composable
fun BottomBarMercadillo(
    mercadilloActivo: MercadilloEntity?,
    onVentasClick: () -> Unit,
    onGastosClick: () -> Unit,
    onResumenClick: () -> Unit,
    onCambiarMercadillo: () -> Unit,
    currentLanguage: String,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .padding(8.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 8.dp),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surface
        ),
        shape = RoundedCornerShape(16.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(12.dp)
        ) {
            // Header con información del mercadillo activo
            mercadilloActivo?.let { mercadillo ->
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Column(modifier = Modifier.weight(1f)) {
                        Text(
                            text = "Mercadillo Activo:",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                        )
                        Text(
                            text = mercadillo.lugar,
                            style = MaterialTheme.typography.bodyMedium,
                            fontWeight = FontWeight.Bold,
                            color = MaterialTheme.colorScheme.primary
                        )
                    }

                    // Botón para cambiar mercadillo
                    TextButton(
                        onClick = onCambiarMercadillo,
                        modifier = Modifier.padding(start = 8.dp)
                    ) {
                        Text(
                            text = "Cambiar",
                            fontSize = 12.sp,
                            color = MaterialTheme.colorScheme.primary
                        )
                    }
                }

                Spacer(modifier = Modifier.height(12.dp))
            }

            // Botones de acciones
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                // Botón Ventas
                BottomBarButton(
                    icon = R.drawable.ic_ventas, // Nombre temporal del icono
                    text = "Ventas",
                    onClick = onVentasClick,
                    color = Color(0xFF4CAF50), // Verde
                    modifier = Modifier.weight(1f)
                )

                Spacer(modifier = Modifier.width(8.dp))

                // Botón Gastos
                BottomBarButton(
                    icon = R.drawable.ic_gastos, // Nombre temporal del icono
                    text = "Gastos",
                    onClick = onGastosClick,
                    color = Color(0xFFF44336), // Rojo
                    modifier = Modifier.weight(1f)
                )

                Spacer(modifier = Modifier.width(8.dp))

                // Botón Resumen
                BottomBarButton(
                    icon = R.drawable.ic_resumen, // Nombre temporal del icono
                    text = "Resumen",
                    onClick = onResumenClick,
                    color = Color(0xFF2196F3), // Azul
                    modifier = Modifier.weight(1f)
                )
            }
        }
    }
}

/**
 * Botón individual del BottomBar
 */
@Composable
private fun BottomBarButton(
    icon: Int,
    text: String,
    onClick: () -> Unit,
    color: Color,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .height(60.dp),
        onClick = onClick,
        colors = CardDefaults.cardColors(
            containerColor = color.copy(alpha = 0.1f)
        ),
        border = androidx.compose.foundation.BorderStroke(
            1.dp,
            color.copy(alpha = 0.3f)
        ),
        shape = RoundedCornerShape(12.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(8.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            Icon(
                painter = painterResource(id = icon),
                contentDescription = text,
                tint = color,
                modifier = Modifier.size(20.dp)
            )

            Spacer(modifier = Modifier.height(4.dp))

            Text(
                text = text,
                style = MaterialTheme.typography.bodySmall,
                color = color,
                fontWeight = FontWeight.Medium,
                textAlign = TextAlign.Center,
                fontSize = 10.sp
            )
        }
    }
}

/**
 * Diálogo para seleccionar mercadillo activo cuando hay múltiples en curso
 */
@Composable
fun DialogoSeleccionMercadilloActivo(
    mercadillosEnCurso: List<MercadilloEntity>,
    onMercadilloSeleccionado: (MercadilloEntity) -> Unit,
    onDismiss: () -> Unit,
    currentLanguage: String
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = {
            Text(
                text = "Seleccionar Mercadillo Activo",
                style = MaterialTheme.typography.titleLarge,
                fontWeight = FontWeight.Bold
            )
        },
        text = {
            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Text(
                    text = "Hay múltiples mercadillos en curso. Selecciona uno para realizar operaciones:",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                )

                Spacer(modifier = Modifier.height(8.dp))

                mercadillosEnCurso.forEach { mercadillo ->
                    Card(
                        modifier = Modifier
                            .fillMaxWidth(),
                        onClick = { onMercadilloSeleccionado(mercadillo) },
                        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),
                        colors = CardDefaults.cardColors(
                            containerColor = MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.3f)
                        )
                    ) {
                        Column(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(12.dp)
                        ) {
                            Text(
                                text = mercadillo.lugar,
                                style = MaterialTheme.typography.titleMedium,
                                fontWeight = FontWeight.Bold,
                                color = MaterialTheme.colorScheme.onSurface
                            )

                            Spacer(modifier = Modifier.height(4.dp))

                            Text(
                                text = "${mercadillo.organizador} • ${mercadillo.horaInicio} - ${mercadillo.horaFin}",
                                style = MaterialTheme.typography.bodyMedium,
                                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                            )

                            if (mercadillo.saldoInicial != null) {
                                Spacer(modifier = Modifier.height(4.dp))
                                Text(
                                    text = "💰 Saldo inicial: €${String.format("%.2f", mercadillo.saldoInicial)}",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = Color(0xFF4CAF50),
                                    fontWeight = FontWeight.Medium
                                )
                            }
                        }
                    }
                }
            }
        },
        confirmButton = { },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancelar")
            }
        }
    )
}
===== END
===== FILE: DialogSelectorColor.kt
// app/src/main/java/es/nuskysoftware/marketsales/ui/components/DialogSelectorColor.kt

package es.nuskysoftware.cajamercadillos.ui.components

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import com.github.skydoves.colorpicker.compose.AlphaSlider
import com.github.skydoves.colorpicker.compose.BrightnessSlider
import com.github.skydoves.colorpicker.compose.HsvColorPicker
import com.github.skydoves.colorpicker.compose.rememberColorPickerController

/**
 * DialogSelectorColor:
 * Diálogo reutilizable con selector de color basado en Skydoves.
 * Incluye:
 *  - HsvColorPicker (selector principal)
 *  - Sliders de brillo y opacidad
 *  - Botones Aceptar / Cancelar
 */
@Composable
fun DialogSelectorColor(
    onColorElegido: (Color) -> Unit,
    onCancelar: () -> Unit
) {
    val controller = rememberColorPickerController()

    AlertDialog(
        onDismissRequest = { onCancelar() },
        confirmButton = {
            TextButton(onClick = {
                onColorElegido(controller.selectedColor.value)
            }) {
                Text("Aceptar", color = Color.Black)
            }
        },
        dismissButton = {
            TextButton(onClick = onCancelar) {
                Text("Cancelar", color = Color.Black)
            }
        },
        title = { Text("Selecciona un color") },
        text = {
            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                // Selector principal
                HsvColorPicker(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(200.dp)
                        .padding(8.dp),
                    controller = controller,
                    onColorChanged = {}
                )
                // Control de transparencia
                AlphaSlider(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(8.dp),
                    controller = controller
                )
                // Control de brillo
                BrightnessSlider(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(8.dp),
                    controller = controller
                )
            }
        }
    )
}
===== END
===== FILE: IconoCarritoPersonalizado.kt
// app/src/main/java/es/nuskysoftware/marketsales/ui/components/IconoCarritoPersonalizado.kt

package es.nuskysoftware.marketsales.ui.composables

import androidx.compose.foundation.layout.size
import androidx.compose.material3.Icon
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.PathFillType
import androidx.compose.ui.graphics.SolidColor
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.StrokeJoin
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.graphics.vector.path
import androidx.compose.ui.unit.dp

// 🛒 ICONO CARRITO PERSONALIZADO (más grande y visible)
val IconoCarritoCustom: ImageVector
    get() {
        return ImageVector.Builder(
            name = "shopping_cart_custom",
            defaultWidth = 24.dp,
            defaultHeight = 24.dp,
            viewportWidth = 24f,
            viewportHeight = 24f
        ).apply {
            path(
                fill = SolidColor(Color.Black),
                fillAlpha = 1.0f,
                stroke = null,
                strokeAlpha = 1.0f,
                strokeLineWidth = 1.0f,
                strokeLineCap = StrokeCap.Butt,
                strokeLineJoin = StrokeJoin.Miter,
                strokeLineMiter = 1.0f,
                pathFillType = PathFillType.NonZero
            ) {
                // Carrito más grueso y visible
                moveTo(7f, 18f)
                curveTo(5.9f, 18f, 5f, 18.9f, 5f, 20f)
                curveTo(5f, 21.1f, 5.9f, 22f, 7f, 22f)
                curveTo(8.1f, 22f, 9f, 21.1f, 9f, 20f)
                curveTo(9f, 18.9f, 8.1f, 18f, 7f, 18f)
                close()

                moveTo(1f, 2f)
                verticalLineTo(4f)
                horizontalLineTo(3f)
                lineTo(6.6f, 11.59f)
                lineTo(5.25f, 14.04f)
                curveTo(5.09f, 14.32f, 5f, 14.65f, 5f, 15f)
                curveTo(5f, 16.1f, 5.9f, 17f, 7f, 17f)
                horizontalLineTo(19f)
                verticalLineTo(15f)
                horizontalLineTo(7.42f)
                curveTo(7.28f, 15f, 7.17f, 14.89f, 7.17f, 14.75f)
                lineTo(7.2f, 14.63f)
                lineTo(8.1f, 13f)
                horizontalLineTo(15.55f)
                curveTo(16.3f, 13f, 16.96f, 12.59f, 17.3f, 11.97f)
                lineTo(20.88f, 5f)
                horizontalLineTo(5.21f)
                lineTo(4.27f, 2f)
                horizontalLineTo(1f)
                close()

                moveTo(17f, 18f)
                curveTo(15.9f, 18f, 15f, 18.9f, 15f, 20f)
                curveTo(15f, 21.1f, 15.9f, 22f, 17f, 22f)
                curveTo(18.1f, 22f, 19f, 21.1f, 19f, 20f)
                curveTo(19f, 18.9f, 18.1f, 18f, 17f, 18f)
                close()
            }
        }.build()
    }

@Composable
fun IconoCarritoGrande(
    modifier: Modifier = Modifier,
    tint: Color = Color.Black
) {
    Icon(
        imageVector = IconoCarritoCustom,
        contentDescription = "Carrito de compras",
        modifier = modifier,
        tint = tint
    )
}
===== END

===== FILE: MenuHamburguesa.kt

// MenuHamburguesa.kt V10 - SIMPLIFICADO PARA SISTEMA MONOUSUARIO
// app/src/main/java/es/nuskysoftware/marketsales/ui/components/MenuHamburguesa.kt

package es.nuskysoftware.marketsales.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import es.nuskysoftware.marketsales.R
import es.nuskysoftware.marketsales.ui.viewmodel.AuthViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.AuthViewModelFactory
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.StringResourceManager
import kotlinx.coroutines.launch

@Composable
fun MenuHamburguesa(
    navController: NavController,
    drawerState: DrawerState
) {
    val scope = rememberCoroutineScope()
    val context = LocalContext.current

    // AuthViewModel para detectar estado de usuario
    val authViewModel: AuthViewModel = viewModel(factory = AuthViewModelFactory(context))
    val currentUser by authViewModel.currentUser.collectAsState()

    // Estados V10 simplificados
    val currentLanguage by ConfigurationManager.idioma.collectAsState()
    val esPremium by ConfigurationManager.esPremium.collectAsState()
    val isAuthenticated by ConfigurationManager.isAuthenticated.collectAsState()
    val estaAutenticado by ConfigurationManager.isAuthenticated.collectAsState()
    val usuarioEmail by ConfigurationManager.usuarioEmail.collectAsState()
    val displayName by ConfigurationManager.displayName.collectAsState()

    // Versión V10
    val versionText = if (esPremium) "Premium V10.0" else "Free V10.0"

    ModalDrawerSheet(
        modifier = Modifier.width(280.dp),
        drawerContainerColor = MaterialTheme.colorScheme.surface
    ) {
        // Header del menú V10
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .height(120.dp)
                .background(MaterialTheme.colorScheme.primary),
            contentAlignment = Alignment.CenterStart
        ) {
            Column(
                modifier = Modifier.padding(16.dp)
            ) {
                Text(
                    text = StringResourceManager.getString("app_name", currentLanguage),
                    fontSize = 24.sp,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.onPrimary
                )

                Text(
                    text = versionText,
                    fontSize = 14.sp,
                    color = MaterialTheme.colorScheme.onPrimary.copy(alpha = 0.8f)
                )

                // Información del usuario V10
                if (isAuthenticated && currentUser != null) {
                    Text(
                        text = "👤 ${usuarioEmail ?: displayName ?: "Usuario"}",
                        fontSize = 12.sp,
                        color = MaterialTheme.colorScheme.onPrimary.copy(alpha = 0.7f)
                    )
                } else {
                    Text(
                        text = "👤 Usuario Invitado",
                        fontSize = 12.sp,
                        color = MaterialTheme.colorScheme.onPrimary.copy(alpha = 0.7f)
                    )
                }
            }
        }

        Spacer(modifier = Modifier.height(8.dp))

        // Opciones del menú
        LazyColumn {
            // Opciones principales
            item {
                MenuOption(
                    iconRes = R.drawable.ic_store,
                    title = StringResourceManager.getString("mercadillos", currentLanguage),
                    onClick = {
                        scope.launch { drawerState.close() }
                        navController.navigate("mercadillos") {
                            popUpTo("mercadillos") { inclusive = true }
                        }
                    }
                )
            }

            item {
                MenuOption(
                    iconRes = R.drawable.ic_list,
                    title = StringResourceManager.getString("articulos", currentLanguage),
                    onClick = {
                        scope.launch { drawerState.close() }
                        navController.navigate("articulos")
                    }
                )
            }

            item {
                MenuOption(
                    iconRes = R.drawable.ic_category,
                    title = StringResourceManager.getString("categorias", currentLanguage),
                    onClick = {
                        scope.launch { drawerState.close() }
                        navController.navigate("categorias")
                    }
                )
            }

            item {
                MenuOption(
                    iconRes = R.drawable.ic_inventory,
                    title = StringResourceManager.getString("inventario", currentLanguage),
                    onClick = {
                        scope.launch { drawerState.close() }
                        navController.navigate("inventario")
                    }
                )
            }

            item {
                MenuOption(
                    iconRes = R.drawable.ic_list,
                    title = StringResourceManager.getString("listados", currentLanguage),
                    onClick = {
                        scope.launch { drawerState.close() }
                        navController.navigate("listados")
                    }
                )
            }

            item {
                HorizontalDivider(
                    modifier = Modifier.padding(vertical = 8.dp),
                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f)
                )
            }

            // Perfil (solo para usuarios autenticados)
           // if (isAuthenticated && currentUser != null) {
            if (estaAutenticado ) {
                item {
                    MenuOption(
                        iconRes = R.drawable.ic_account,
                        title = StringResourceManager.getString("perfil", currentLanguage),
                        onClick = {
                            scope.launch { drawerState.close() }
                            navController.navigate("perfil")
                        }
                    )
                }
            }

            // Configuración
            item {
                MenuOption(
                    iconRes = R.drawable.ic_settings,
                    title = StringResourceManager.getString("configuracion", currentLanguage),
                    onClick = {
                        scope.launch { drawerState.close() }
                        navController.navigate("configuracion")
                    }
                )
            }

            // Login/Logout condicional V10
            item {
                //if (isAuthenticated && currentUser != null) {
                if (estaAutenticado ) {
                    // Usuario autenticado - mostrar LOGOUT
                    MenuOption(
                        iconRes = R.drawable.ic_logout,
                        title = StringResourceManager.getString("cerrar_sesion", currentLanguage),
                        onClick = {
                            scope.launch {
                                drawerState.close()
                                authViewModel.logout()
                            }
                        }
                    )
                } else {
                    // Usuario NO autenticado - mostrar LOGIN
                    MenuOption(
                        iconRes = R.drawable.ic_login,
                        title = StringResourceManager.getString("iniciar_sesion", currentLanguage),
                        onClick = {
                            scope.launch { drawerState.close() }
                            navController.navigate("login")
                        }
                    )
                }
            }

            // Salir app
            item {
                MenuOption(
                    iconRes = R.drawable.ic_exit,
                    title = StringResourceManager.getString("salir", currentLanguage),
                    onClick = {
                        scope.launch { drawerState.close() }
                        (context as? androidx.activity.ComponentActivity)?.finishAffinity()
                    }
                )
            }
        }
    }
}

@Composable
private fun MenuOption(
    iconRes: Int,
    title: String,
    onClick: () -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onClick() }
            .padding(horizontal = 16.dp, vertical = 12.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Icon(
            painter = painterResource(id = iconRes),
            contentDescription = title,
            tint = MaterialTheme.colorScheme.onSurface,
            modifier = Modifier.size(24.dp)
        )

        Spacer(modifier = Modifier.width(16.dp))

        Text(
            text = title,
            fontSize = 16.sp,
            color = MaterialTheme.colorScheme.onSurface,
            fontWeight = FontWeight.Medium
        )
    }
}
===== END
===== FILE: settings.gradle.kts
// app/src/main/java/es/nuskysoftware/marketsales/ui/composables/CampoDescripcion.kt

package es.nuskysoftware.marketsales.ui.composables

import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier

@Composable
fun CampoDescripcion(
    descripcion: String,
    onDescripcionChange: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    OutlinedTextField(
        value = descripcion,
        onValueChange = onDescripcionChange,
        label = { Text("Descripción *") },
        placeholder = { Text("Ej: Llavero Delfín Madera") },
        modifier = modifier.fillMaxWidth(),
        singleLine = true,
        isError = descripcion.isBlank(),
        supportingText = {
            if (descripcion.isBlank()) {
                Text(
                    text = "La descripción es obligatoria",
                    color = MaterialTheme.colorScheme.error
                )
            }
        }
    )
}
===== END
===== FILE: CampoImporte.kt
// app/src/main/java/es/nuskysoftware/marketsales/ui/composables/CampoImporte.kt

package es.nuskysoftware.marketsales.ui.composables

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp

@Composable
fun CampoImporte(
    importe: String,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.background
        )
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth(),
                //.padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(
                text = "Importe",
                style = MaterialTheme.typography.bodyLarge,
                color = MaterialTheme.colorScheme.onPrimaryContainer
            )

            Spacer(modifier = Modifier.height(8.dp))

            Text(
                text = "${importe.replace('.', ',')} €",
                style = MaterialTheme.typography.displayLarge,
                fontWeight = FontWeight.Bold,
                color = MaterialTheme.colorScheme.onPrimaryContainer,
                textAlign = TextAlign.Center
            )
        }
    }
}
===== END
===== FILE: PestanaVentaManual.kt
// app/src/main/java/es/nuskysoftware/marketsales/ui/composables/PestanaVentaManual.kt

package es.nuskysoftware.marketsales.ui.composables

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.ShoppingCart
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import es.nuskysoftware.marketsales.ui.viewmodel.VentasViewModel

@Composable
fun PestanaVentaManual(
    ventasViewModel: VentasViewModel
) {
    val uiState by ventasViewModel.uiState.collectAsState()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(6.dp)
    ) {
        // 🎯 CAMPO IMPORTE GRANDE (sin fondo gris - transparente)
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .padding(2.dp),
            contentAlignment = Alignment.Center
        ) {
            CampoImporte(
                importe = uiState.importeActual,
                modifier = Modifier.fillMaxWidth()
            )
        }

        Spacer(modifier = Modifier.height(6.dp))

        // 🎯 CAMPO DESCRIPCIÓN
        CampoDescripcion(
            descripcion = uiState.descripcionActual,
            onDescripcionChange = ventasViewModel::actualizarDescripcion,
            modifier = Modifier.fillMaxWidth()
        )

        Spacer(modifier = Modifier.height(6.dp))

        // 🎯 TECLADO NUMÉRICO TPV
        TecladoNumerico(
            onDigitClick = ventasViewModel::onDigitoPresionado,
            onClearClick = ventasViewModel::onBorrarDigito,
            onDoubleZeroClick = ventasViewModel::onDobleDecimalPresionado
        )

        Spacer(modifier = Modifier.height(24.dp))

        // 🎯 BOTÓN AÑADIR MÁS VENTAS (como en la imagen)
        Button(
            onClick = {
                if (uiState.descripcionActual.isNotBlank() &&
                    ventasViewModel.obtenerImporteComoDouble() > 0) {
                    ventasViewModel.añadirLineaManual()
                }
            },
            modifier = Modifier
                .fillMaxWidth()
                .height(56.dp),
            enabled = uiState.descripcionActual.isNotBlank() &&
                    ventasViewModel.obtenerImporteComoDouble() > 0,
            shape = RoundedCornerShape(12.dp),
            colors = ButtonDefaults.buttonColors(
                containerColor = MaterialTheme.colorScheme.primary
            )
        ) {
            Icon(
                imageVector = Icons.Default.Add,
                contentDescription = "Añadir",
                modifier = Modifier.size(24.dp)
            )
            Spacer(modifier = Modifier.width(8.dp))
            Text(
                text = "Añadir más ventas",
                fontSize = 16.sp,
                fontWeight = FontWeight.Medium
            )
        }

        Spacer(modifier = Modifier.height(32.dp)) // Más espacio antes de los botones finales

        // 🎯 BOTONES INFERIORES NEGRO Y CARRITO (dentro de la pestaña)
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp),
            horizontalArrangement = Arrangement.spacedBy(12.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // ✅ Botón REALIZAR CARGO NEGRO con total
            Button(
                onClick = { /* TODO: Navegación a cobro */ },
                modifier = Modifier
                    .weight(1f)
                    .height(56.dp),
                enabled = uiState.lineasTicket.isNotEmpty() && uiState.totalTicket > 0,
                shape = RoundedCornerShape(12.dp),
                colors = ButtonDefaults.buttonColors(
                    containerColor = Color.Black, // ✅ NEGRO
                    disabledContainerColor = MaterialTheme.colorScheme.surfaceVariant
                )
            ) {
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Text(
                        text = "Realizar cargo",
                        fontSize = 14.sp,
                        fontWeight = FontWeight.Medium,
                        color = Color.White // ✅ Texto blanco sobre negro
                    )
                    if (uiState.totalTicket > 0) {
                        Text(
                            text = "%.2f €".format(uiState.totalTicket),
                            fontSize = 12.sp,
                            fontWeight = FontWeight.Bold,
                            color = Color.White // ✅ Texto blanco sobre negro
                        )
                    }
                }
            }

            // ✅ Botón CARRITO MÁS GRANDE con icono más grande
            Button(
                onClick = { /* TODO: Mostrar resumen carrito */ },
                modifier = Modifier.size(64.dp), // ✅ Botón más grande
                shape = RoundedCornerShape(12.dp),
                colors = ButtonDefaults.buttonColors(
                    containerColor = MaterialTheme.colorScheme.primaryContainer
                )
            ) {
                Box {

                    IconoCarritoGrande(
                        modifier = Modifier.size(48.dp), // ✅ Icono SVG grande
                        tint = MaterialTheme.colorScheme.onPrimaryContainer
                    )
                    if (uiState.lineasTicket.isNotEmpty()) {
                        Badge(
                            modifier = Modifier.align(Alignment.TopEnd)
                        ) {
                            Text(
                                text = uiState.lineasTicket.size.toString(),
                                fontSize = 10.sp
                            )
                        }
                    }
                }
            }
        }

        Spacer(modifier = Modifier.height(16.dp)) // Espacio final
    }
}

===== END
===== FILE: TecladoNumerico.kt
// app/src/main/java/es/nuskysoftware/marketsales/ui/composables/TecladoNumerico.kt

package es.nuskysoftware.marketsales.ui.composables

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Backspace
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp

@Composable
fun TecladoNumerico(
    onDigitClick: (String) -> Unit,
    onClearClick: () -> Unit,
    onDoubleZeroClick: () -> Unit
) {
    Column(
        modifier = Modifier.fillMaxWidth(),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        // Fila 1: 1, 2, 3
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceEvenly
        ) {
            TeclaNumero("1", onDigitClick)
            TeclaNumero("2", onDigitClick)
            TeclaNumero("3", onDigitClick)
        }

        Spacer(modifier = Modifier.height(8.dp))

        // Fila 2: 4, 5, 6
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceEvenly
        ) {
            TeclaNumero("4", onDigitClick)
            TeclaNumero("5", onDigitClick)
            TeclaNumero("6", onDigitClick)
        }

        Spacer(modifier = Modifier.height(8.dp))

        // Fila 3: 7, 8, 9
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceEvenly
        ) {
            TeclaNumero("7", onDigitClick)
            TeclaNumero("8", onDigitClick)
            TeclaNumero("9", onDigitClick)
        }

        Spacer(modifier = Modifier.height(8.dp))

        // Fila 4: 00, 0, BORRAR
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceEvenly
        ) {
            // Botón 00 - Añade dos decimales automáticamente
            Button(
                onClick = { onDoubleZeroClick() },
                modifier = Modifier
                    .size(60.dp)
                    .weight(1f),
                shape = CircleShape,
                colors = ButtonDefaults.buttonColors(
                    containerColor = MaterialTheme.colorScheme.secondary
                )
            ) {
                Text(
                    text = "00",
                    fontSize = 18.sp,
                    fontWeight = FontWeight.Bold
                )
            }

            Spacer(modifier = Modifier.width(8.dp))

            TeclaNumero("0", onDigitClick)

            Spacer(modifier = Modifier.width(8.dp))

            // Botón BORRAR
            Button(
                onClick = onClearClick,
                modifier = Modifier
                    .size(60.dp)
                    .weight(1f),
                shape = RoundedCornerShape(8.dp),
                colors = ButtonDefaults.buttonColors(
                    containerColor = MaterialTheme.colorScheme.error
                )
            ) {
                Icon(
                    imageVector = Icons.Default.Backspace,
                    contentDescription = "Borrar",
                    tint = MaterialTheme.colorScheme.onError
                )
            }
        }
    }
}

@Composable
private fun RowScope.TeclaNumero(
    numero: String,
    onDigitClick: (String) -> Unit
) {
    Button(
        onClick = { onDigitClick(numero) },
        modifier = Modifier
            .size(60.dp)
            .weight(1f),
        //shape = RoundedCornerShape(8.dp),
        shape = CircleShape,
        colors = ButtonDefaults.buttonColors(
            containerColor = MaterialTheme.colorScheme.primary
        )
    ) {
        Text(
            text = numero,
            fontSize = 18.sp,
            fontWeight = FontWeight.Bold,
            color = MaterialTheme.colorScheme.onPrimary
        )
    }
}

===== END
===== FILE: PantallaAltaMercadillo.kt
// app/src/main/java/es/nuskysoftware/marketsales/ui/pantallas/PantallaAltaMercadillo.kt
// VERSIÓN COMPLETA CON DATEPICKER, TIMEPICKER Y DEBUG ESTADOS

package es.nuskysoftware.marketsales.ui.pantallas

import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import es.nuskysoftware.marketsales.data.local.entity.MercadilloEntity
import es.nuskysoftware.marketsales.ui.viewmodel.MercadilloViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.MercadilloViewModelFactory
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.EstadosMercadillo
import es.nuskysoftware.marketsales.utils.StringResourceManager
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PantallaAltaMercadillo(
    navController: NavController,
    mercadilloId: String? = null, // null = crear, no-null = editar
    fechaPreseleccionada: String? = null // ✅ NUEVO PARÁMETRO PARA FECHA DEL CALENDARIO
) {
    val context = LocalContext.current
    val mercadilloViewModel: MercadilloViewModel = viewModel(
        factory = MercadilloViewModelFactory(context)
    )

    // Estados del ViewModel
    val uiState by mercadilloViewModel.uiState.collectAsState()
    val currentLanguage by ConfigurationManager.idioma.collectAsState()

    val esEdicion = mercadilloId != null
    val mercadilloParaEditar by mercadilloViewModel.mercadilloParaEditar.collectAsState()

    // Estados del formulario
    var fecha by remember { mutableStateOf(fechaPreseleccionada ?: "") }
    var lugar by remember { mutableStateOf("") }
    var organizador by remember { mutableStateOf("") }
    var esGratis by remember { mutableStateOf(true) }
    var importeSuscripcion by remember { mutableStateOf("") }
    var requiereMesa by remember { mutableStateOf(true) }
    var requiereCarpa by remember { mutableStateOf(true) }
    var hayPuntoLuz by remember { mutableStateOf(false) }
    var horaInicio by remember { mutableStateOf("09:00") }
    var horaFin by remember { mutableStateOf("14:00") }
    var saldoInicial by remember { mutableStateOf("") }

    // ✅ ESTADO PARA DEBUG DE ESTADOS (SOLO EN EDICIÓN)
    var estadoDebugSeleccionado by remember { mutableStateOf<EstadosMercadillo.Estado?>(null) }

    // ✅ ESTADOS PARA DIÁLOGOS DE FECHA Y HORA
    var mostrarDatePicker by remember { mutableStateOf(false) }
    var mostrarTimePickerInicio by remember { mutableStateOf(false) }
    var mostrarTimePickerFin by remember { mutableStateOf(false) }

    val snackbarHostState = remember { SnackbarHostState() }
    val scope = rememberCoroutineScope()

    // Cargar mercadillo para edición
    LaunchedEffect(mercadilloId) {
        if (mercadilloId != null) {
            mercadilloViewModel.cargarMercadillo(mercadilloId)
        }
    }

    // Actualizar campos cuando se carga el mercadillo para edición
    LaunchedEffect(mercadilloParaEditar) {
        mercadilloParaEditar?.let { mercadillo ->
            fecha = mercadillo.fecha
            lugar = mercadillo.lugar
            organizador = mercadillo.organizador
            esGratis = mercadillo.esGratis
            importeSuscripcion = if (mercadillo.importeSuscripcion > 0) mercadillo.importeSuscripcion.toString() else ""
            requiereMesa = mercadillo.requiereMesa
            requiereCarpa = mercadillo.requiereCarpa
            hayPuntoLuz = mercadillo.hayPuntoLuz
            horaInicio = mercadillo.horaInicio
            horaFin = mercadillo.horaFin
            saldoInicial = mercadillo.saldoInicial?.toString() ?: ""

            // ✅ CARGAR ESTADO ACTUAL PARA DEBUG
            estadoDebugSeleccionado = EstadosMercadillo.Estado.fromCodigo(mercadillo.estado)
        }
    }

    // Validar fecha preseleccionada
    LaunchedEffect(fechaPreseleccionada) {
        if (fechaPreseleccionada != null && fechaPreseleccionada.isNotBlank()) {
            val validacionFecha = mercadilloViewModel.validarFecha(fechaPreseleccionada)
            if (validacionFecha == null) {
                fecha = fechaPreseleccionada
            }
        }
    }

    // ✅ NUEVA VARIABLE PARA CONTROLAR EL CIERRE
    var deberiaNavegar by remember { mutableStateOf(false) }

    // Manejar mensajes del ViewModel
    LaunchedEffect(uiState.message) {
        uiState.message?.let { message ->
            snackbarHostState.showSnackbar(message)
            mercadilloViewModel.limpiarMensaje()

            // ✅ AMPLIAR LAS CONDICIONES PARA CERRAR LA PANTALLA
            if (message.contains("exitosamente") ||
                message.contains("creado") ||
                message.contains("actualizado") ||
                message.contains("Estado") ||
                message.contains("cambiado") ||
                message.contains("guardado") ||
                message.contains("saved") ||
                message.contains("success")) {

                // ✅ MARCAR QUE DEBE NAVEGAR
                deberiaNavegar = true
            }
        }
    }

    // ✅ EFECTO SEPARADO PARA LA NAVEGACIÓN
    LaunchedEffect(deberiaNavegar) {
        if (deberiaNavegar) {
            // ✅ PEQUEÑO DELAY para que se vea el mensaje
            kotlinx.coroutines.delay(800)
            navController.popBackStack()
        }
    }

    LaunchedEffect(uiState.error) {
        uiState.error?.let { error ->
            snackbarHostState.showSnackbar(error)
            mercadilloViewModel.limpiarError()
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        text = if (esEdicion) "Editar Mercadillo" else "Nuevo Mercadillo",
                        fontWeight = FontWeight.Bold
                    )
                },
                // ✅ SIN navigationIcon - NO HAY FLECHA ATRÁS
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary
                )
            )
        },
        snackbarHost = { SnackbarHost(snackbarHostState) }
    ) { paddingValues ->

        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {

            // ✅ FORMULARIO CON SCROLL
            LazyColumn(
                modifier = Modifier
                    .weight(1f)
                    .padding(horizontal = 16.dp),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {

                item { Spacer(modifier = Modifier.height(8.dp)) }

                // ✅ Campo fecha CON DATEPICKER
                item {
                    CampoFecha(
                        fecha = fecha,
                        onFechaChange = { fecha = it },
                        onMostrarDatePicker = { mostrarDatePicker = true },
                        esEdicion = esEdicion,
                        mercadilloParaEditar = mercadilloParaEditar
                    )
                }

                // Campo lugar
                item {
                    CampoTexto(
                        valor = lugar,
                        onValueChange = { lugar = it },
                        label = "Lugar",
                        placeholder = "Ej: Plaza Mayor"
                    )
                }

                // Campo organizador
                item {
                    CampoTexto(
                        valor = organizador,
                        onValueChange = { organizador = it },
                        label = "Organizador",
                        placeholder = "Ej: Ayuntamiento"
                    )
                }

                // Configuración económica
                item {
                    ConfiguracionEconomica(
                        esGratis = esGratis,
                        onEsGratisChange = { esGratis = it },
                        importeSuscripcion = importeSuscripcion,
                        onImporteSuscripcionChange = { importeSuscripcion = it }
                    )
                }

                // Configuración logística
                item {
                    ConfiguracionLogistica(
                        requiereMesa = requiereMesa,
                        onRequiereMesaChange = { requiereMesa = it },
                        requiereCarpa = requiereCarpa,
                        onRequiereCarpaChange = { requiereCarpa = it },
                        hayPuntoLuz = hayPuntoLuz,
                        onHayPuntoLuzChange = { hayPuntoLuz = it }
                    )
                }

                // ✅ Configuración horarios CON TIMEPICKERS
                item {
                    ConfiguracionHorarios(
                        horaInicio = horaInicio,
                        onHoraInicioChange = { horaInicio = it },
                        horaFin = horaFin,
                        onHoraFinChange = { horaFin = it },
                        onMostrarTimePickerInicio = { mostrarTimePickerInicio = true },
                        onMostrarTimePickerFin = { mostrarTimePickerFin = true }
                    )
                }

                // Campo saldo inicial
                item {
                    CampoSaldoInicial(
                        saldoInicial = saldoInicial,
                        onSaldoInicialChange = { saldoInicial = it }
                    )
                }

                // ✅ CAMPO DEBUG DE ESTADOS (SOLO EN EDICIÓN)
                if (esEdicion && mercadilloParaEditar != null) {
                    item {
                        Spacer(modifier = Modifier.height(8.dp))

                        HorizontalDivider(
                            color = Color.Red.copy(alpha = 0.3f),
                            thickness = 2.dp
                        )

                        Spacer(modifier = Modifier.height(16.dp))

                        CampoEstadoDebug(
                            estadoActual = mercadilloParaEditar!!.estado,
                            onEstadoChange = { nuevoEstado ->
                                estadoDebugSeleccionado = nuevoEstado
                            },
                            modifier = Modifier.fillMaxWidth()
                        )
                    }
                }

                item { Spacer(modifier = Modifier.height(24.dp)) }
            }

            // ✅ BOTONES FIJOS EN LA PARTE INFERIOR
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                horizontalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                // Botón Cancelar
                OutlinedButton(
                    onClick = {
                        // Limpiar el mercadillo para edición si existe
                        if (esEdicion) {
                            mercadilloViewModel.limpiarMercadilloParaEditar()
                        }
                        navController.popBackStack()
                    },
                    modifier = Modifier.weight(1f),
                    colors = ButtonDefaults.outlinedButtonColors(
                        contentColor = MaterialTheme.colorScheme.error
                    ),
                    border = BorderStroke(1.dp, MaterialTheme.colorScheme.error)
                ) {
                    Text("Cancelar")
                }

                // Botón Aceptar/Crear
                Button(
                    onClick = {
                        val saldoInicialDouble = saldoInicial.toDoubleOrNull()
                        val importeSuscripcionDouble = if (esGratis) 0.0 else importeSuscripcion.toDoubleOrNull() ?: 0.0

                        scope.launch {
                            try {
                                if (esEdicion && mercadilloId != null) {
                                    // ✅ NUEVA LÓGICA: Solo cambiar estado si realmente cambió
                                    val estadoOriginal = mercadilloParaEditar?.estado
                                    val estadoNuevo = estadoDebugSeleccionado?.codigo

                                    if (estadoNuevo != null && estadoOriginal != null && estadoNuevo != estadoOriginal) {
                                        // El estado cambió, actualizarlo primero
                                        mercadilloViewModel.cambiarEstadoMercadillo(
                                            mercadilloId = mercadilloId,
                                            nuevoEstado = estadoDebugSeleccionado!!
                                        )
                                    }

                                    // Actualizar el resto de campos
                                    mercadilloViewModel.actualizarMercadillo(
                                        mercadilloId = mercadilloId,
                                        fecha = fecha,
                                        lugar = lugar,
                                        organizador = organizador,
                                        esGratis = esGratis,
                                        importeSuscripcion = importeSuscripcionDouble,
                                        requiereMesa = requiereMesa,
                                        requiereCarpa = requiereCarpa,
                                        hayPuntoLuz = hayPuntoLuz,
                                        horaInicio = horaInicio,
                                        horaFin = horaFin,
                                        saldoInicial = saldoInicialDouble
                                    )
                                } else {
                                    mercadilloViewModel.crearMercadillo(
                                        fecha = fecha,
                                        lugar = lugar,
                                        organizador = organizador,
                                        esGratis = esGratis,
                                        importeSuscripcion = importeSuscripcionDouble,
                                        requiereMesa = requiereMesa,
                                        requiereCarpa = requiereCarpa,
                                        hayPuntoLuz = hayPuntoLuz,
                                        horaInicio = horaInicio,
                                        horaFin = horaFin,
                                        saldoInicial = saldoInicialDouble
                                    )
                                }

                                // ✅ ESPERAR UN MOMENTO Y LUEGO NAVEGAR DE VUELTA
                                kotlinx.coroutines.delay(1000)

                                // ✅ FORZAR LA NAVEGACIÓN SI NO SE HA CERRADO AUTOMÁTICAMENTE
                                if (!deberiaNavegar) {
                                    deberiaNavegar = true
                                }

                            } catch (e: Exception) {
                                // En caso de error, no navegar
                                println("Error al guardar: ${e.message}")
                            }
                        }
                    },
                    enabled = !uiState.loading && fecha.isNotBlank() && lugar.isNotBlank() && organizador.isNotBlank(),
                    modifier = Modifier.weight(1f)
                ) {
                    if (uiState.loading) {
                        CircularProgressIndicator(
                            modifier = Modifier.size(16.dp),
                            color = MaterialTheme.colorScheme.onPrimary
                        )
                    } else {
                        Text(if (esEdicion) "Actualizar" else "Crear")
                    }
                }
            }
        }

        // ✅ DIÁLOGOS DE FECHA Y HORA
        if (mostrarDatePicker) {
            DatePickerDialog(
                onDateSelected = { fechaSeleccionada ->
                    fecha = fechaSeleccionada
                    mostrarDatePicker = false
                },
                onDismiss = { mostrarDatePicker = false },
                currentLanguage = currentLanguage
            )
        }

        if (mostrarTimePickerInicio) {
            TimePickerDialog(
                onTimeSelected = { horaSeleccionada ->
                    horaInicio = horaSeleccionada
                    mostrarTimePickerInicio = false
                },
                onDismiss = { mostrarTimePickerInicio = false },
                initialTime = horaInicio,
                currentLanguage = currentLanguage
            )
        }

        if (mostrarTimePickerFin) {
            TimePickerDialog(
                onTimeSelected = { horaSeleccionada ->
                    horaFin = horaSeleccionada
                    mostrarTimePickerFin = false
                },
                onDismiss = { mostrarTimePickerFin = false },
                initialTime = horaFin,
                currentLanguage = currentLanguage
            )
        }
    }
}

// ✅ CAMPO DE SELECCIÓN DE ESTADO PARA DEBUG
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CampoEstadoDebug(
    estadoActual: Int,
    onEstadoChange: (EstadosMercadillo.Estado) -> Unit,
    modifier: Modifier = Modifier
) {
    var expanded by remember { mutableStateOf(false) }

    // ✅ ESTADO LOCAL que SÍ se actualiza visualmente
    var estadoSeleccionado by remember(estadoActual) {
        mutableStateOf(
            EstadosMercadillo.Estado.fromCodigo(estadoActual)
                ?: EstadosMercadillo.Estado.PROGRAMADO_PARCIAL
        )
    }

    Column(modifier = modifier) {
        Text(
            text = "🔧 Estado (DEBUG)",
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Medium,
            color = Color.Red
        )

        Spacer(modifier = Modifier.height(4.dp))

        ExposedDropdownMenuBox(
            expanded = expanded,
            onExpandedChange = { expanded = !expanded }
        ) {
            OutlinedTextField(
                // ✅ USAR EL ESTADO LOCAL en lugar de estadoActual
                value = "${estadoSeleccionado.codigo} - ${estadoSeleccionado.descripcion}",
                onValueChange = { },
                readOnly = true,
                trailingIcon = {
                    ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded)
                },
                colors = OutlinedTextFieldDefaults.colors(
                    focusedBorderColor = Color.Red,
                    unfocusedBorderColor = Color.Red.copy(alpha = 0.5f)
                ),
                modifier = Modifier
                    .menuAnchor()
                    .fillMaxWidth()
            )

            ExposedDropdownMenu(
                expanded = expanded,
                onDismissRequest = { expanded = false }
            ) {
                EstadosMercadillo.obtenerTodosLosEstados().forEach { estado ->
                    DropdownMenuItem(
                        text = {
                            Row(
                                verticalAlignment = Alignment.CenterVertically,
                                modifier = Modifier.fillMaxWidth()
                            ) {
                                // Círculo de color
                                Box(
                                    modifier = Modifier
                                        .size(12.dp)
                                        .background(
                                            EstadosMercadillo.obtenerColor(estado),
                                            CircleShape
                                        )
                                )

                                Spacer(modifier = Modifier.width(8.dp))

                                // Icono
                                Text(
                                    text = EstadosMercadillo.obtenerIcono(estado),
                                    fontSize = 14.sp
                                )

                                Spacer(modifier = Modifier.width(8.dp))

                                // Código y descripción
                                Text(
                                    text = "${estado.codigo} - ${estado.descripcion}",
                                    style = MaterialTheme.typography.bodyMedium
                                )
                            }
                        },
                        onClick = {
                            // ✅ ACTUALIZAR AMBOS: local y notificar cambio
                            estadoSeleccionado = estado
                            onEstadoChange(estado)
                            expanded = false
                        }
                    )
                }
            }
        }

        // Advertencia
        Text(
            text = "⚠️ Solo para debugging - Se eliminará en producción",
            style = MaterialTheme.typography.bodySmall,
            color = Color.Red.copy(alpha = 0.7f),
            fontSize = 10.sp
        )
    }
}

// ✅ COMPONENTES AUXILIARES PARA EL FORMULARIO

@Composable
fun CampoFecha(
    fecha: String,
    onFechaChange: (String) -> Unit,
    onMostrarDatePicker: () -> Unit,
    esEdicion: Boolean,
    mercadilloParaEditar: MercadilloEntity?
) {
    Column {
        Text(
            text = "Fecha",
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Medium
        )
        Spacer(modifier = Modifier.height(4.dp))
        OutlinedTextField(
            value = fecha,
            onValueChange = onFechaChange,
            placeholder = { Text("dd-MM-yyyy") },
            modifier = Modifier
                .fillMaxWidth()
                .clickable { onMostrarDatePicker() },
            readOnly = true,
            trailingIcon = {
                IconButton(onClick = onMostrarDatePicker) {
                    Text("📅", fontSize = 18.sp)
                }
            }
        )
    }
}

@Composable
fun CampoTexto(
    valor: String,
    onValueChange: (String) -> Unit,
    label: String,
    placeholder: String
) {
    Column {
        Text(
            text = label,
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Medium
        )
        Spacer(modifier = Modifier.height(4.dp))
        OutlinedTextField(
            value = valor,
            onValueChange = onValueChange,
            placeholder = { Text(placeholder) },
            modifier = Modifier.fillMaxWidth()
        )
    }
}

@Composable
fun ConfiguracionEconomica(
    esGratis: Boolean,
    onEsGratisChange: (Boolean) -> Unit,
    importeSuscripcion: String,
    onImporteSuscripcionChange: (String) -> Unit
) {
    Column {
        Text(
            text = "Configuración Económica",
            style = MaterialTheme.typography.titleMedium,
            fontWeight = FontWeight.Bold
        )
        Spacer(modifier = Modifier.height(8.dp))

        Row(verticalAlignment = Alignment.CenterVertically) {
            Switch(
                checked = esGratis,
                onCheckedChange = onEsGratisChange
            )
            Spacer(modifier = Modifier.width(8.dp))
            Text("Mercadillo gratuito")
        }

        if (!esGratis) {
            Spacer(modifier = Modifier.height(8.dp))
            OutlinedTextField(
                value = importeSuscripcion,
                onValueChange = onImporteSuscripcionChange,
                label = { Text("Importe suscripción (€)") },
                placeholder = { Text("0.00") },
                modifier = Modifier.fillMaxWidth()
            )
        }
    }
}

@Composable
fun ConfiguracionLogistica(
    requiereMesa: Boolean,
    onRequiereMesaChange: (Boolean) -> Unit,
    requiereCarpa: Boolean,
    onRequiereCarpaChange: (Boolean) -> Unit,
    hayPuntoLuz: Boolean,
    onHayPuntoLuzChange: (Boolean) -> Unit
) {
    Column {
        Text(
            text = "Configuración Logística",
            style = MaterialTheme.typography.titleMedium,
            fontWeight = FontWeight.Bold
        )
        Spacer(modifier = Modifier.height(8.dp))

        Row(verticalAlignment = Alignment.CenterVertically) {
            Checkbox(checked = requiereMesa, onCheckedChange = onRequiereMesaChange)
            Text("Requiere mesa")
        }

        Row(verticalAlignment = Alignment.CenterVertically) {
            Checkbox(checked = requiereCarpa, onCheckedChange = onRequiereCarpaChange)
            Text("Requiere carpa")
        }

        Row(verticalAlignment = Alignment.CenterVertically) {
            Checkbox(checked = hayPuntoLuz, onCheckedChange = onHayPuntoLuzChange)
            Text("Hay punto de luz")
        }
    }
}

@Composable
fun ConfiguracionHorarios(
    horaInicio: String,
    onHoraInicioChange: (String) -> Unit,
    horaFin: String,
    onHoraFinChange: (String) -> Unit,
    onMostrarTimePickerInicio: () -> Unit,
    onMostrarTimePickerFin: () -> Unit
) {
    Column {
        Text(
            text = "Horarios",
            style = MaterialTheme.typography.titleMedium,
            fontWeight = FontWeight.Bold
        )
        Spacer(modifier = Modifier.height(8.dp))

        Row(modifier = Modifier.fillMaxWidth()) {
            // ✅ Hora inicio CON TIMEPICKER
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = "Hora inicio",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                )
                OutlinedTextField(
                    value = horaInicio,
                    onValueChange = onHoraInicioChange,
                    placeholder = { Text("HH:mm") },
                    modifier = Modifier
                        .fillMaxWidth()
                        .clickable { onMostrarTimePickerInicio() },
                    readOnly = true,
                    trailingIcon = {
                        IconButton(onClick = onMostrarTimePickerInicio) {
                            Text("🕐", fontSize = 18.sp)
                        }
                    }
                )
            }

            Spacer(modifier = Modifier.width(8.dp))

            // ✅ Hora fin CON TIMEPICKER
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = "Hora fin",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                )
                OutlinedTextField(
                    value = horaFin,
                    onValueChange = onHoraFinChange,
                    placeholder = { Text("HH:mm") },
                    modifier = Modifier
                        .fillMaxWidth()
                        .clickable { onMostrarTimePickerFin() },
                    readOnly = true,
                    trailingIcon = {
                        IconButton(onClick = onMostrarTimePickerFin) {
                            Text("🕐", fontSize = 18.sp)
                        }
                    }
                )
            }
        }
    }
}

@Composable
fun CampoSaldoInicial(
    saldoInicial: String,
    onSaldoInicialChange: (String) -> Unit
) {
    Column {
        Text(
            text = "Saldo Inicial (Opcional)",
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Medium
        )
        Spacer(modifier = Modifier.height(4.dp))
        OutlinedTextField(
            value = saldoInicial,
            onValueChange = onSaldoInicialChange,
            placeholder = { Text("0.00") },
            modifier = Modifier.fillMaxWidth(),
            suffix = { Text("€") }
        )
    }
}

// ✅ IMPLEMENTACIÓN COMPLETA DE DATEPICKER Y TIMEPICKER

@Composable
private fun DatePickerDialog(
    onDateSelected: (String) -> Unit,
    onDismiss: () -> Unit,
    currentLanguage: String
) {
    val calendar = remember {
        Calendar.getInstance().apply {
            firstDayOfWeek = Calendar.MONDAY
            time = Date()
        }
    }

    var selectedDate by remember {
        mutableStateOf(calendar.clone() as Calendar)
    }

    var currentViewDate by remember {
        mutableStateOf(calendar.clone() as Calendar)
    }

    val dateFormat = SimpleDateFormat("dd-MM-yyyy", if (currentLanguage == "es") Locale("es", "ES") else Locale.ENGLISH)

    AlertDialog(
        onDismissRequest = onDismiss,
        title = {
            Text(
                text = StringResourceManager.getString("seleccionar_fecha", currentLanguage),
                style = MaterialTheme.typography.titleLarge,
                fontWeight = FontWeight.Bold
            )
        },
        text = {
            Column(
                horizontalAlignment = Alignment.CenterHorizontally,
                modifier = Modifier.width(320.dp)
            ) {
                SelectedDateDisplay(selectedDate, currentLanguage)

                Spacer(modifier = Modifier.height(16.dp))

                MonthYearNavigation(
                    currentViewDate = currentViewDate,
                    onMonthChange = { newDate ->
                        currentViewDate = newDate
                    },
                    currentLanguage = currentLanguage
                )

                Spacer(modifier = Modifier.height(16.dp))

                CalendarGrid(
                    currentViewDate = currentViewDate,
                    selectedDate = selectedDate,
                    onDateSelected = { newDate ->
                        selectedDate = newDate
                    },
                    currentLanguage = currentLanguage
                )
            }
        },
        confirmButton = {
            Button(
                onClick = {
                    val formattedDate = dateFormat.format(selectedDate.time)
                    onDateSelected(formattedDate)
                }
            ) {
                Text(StringResourceManager.getString("aceptar", currentLanguage))
            }
        },
        dismissButton = {
            OutlinedButton(onClick = onDismiss) {
                Text(StringResourceManager.getString("cancelar", currentLanguage))
            }
        }
    )
}

@Composable
private fun SelectedDateDisplay(
    selectedDate: Calendar,
    currentLanguage: String
) {
    val dayFormat = SimpleDateFormat("EEEE", if (currentLanguage == "es") Locale("es", "ES") else Locale.ENGLISH)
    val displayFormat = if (currentLanguage == "es") {
        SimpleDateFormat("d 'de' MMMM 'de' yyyy", Locale("es", "ES"))
    } else {
        SimpleDateFormat("MMMM d, yyyy", Locale.ENGLISH)
    }

    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.primaryContainer
        )
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(
                text = dayFormat.format(selectedDate.time).replaceFirstChar {
                    if (it.isLowerCase()) it.titlecase() else it.toString()
                },
                style = MaterialTheme.typography.bodyLarge,
                color = MaterialTheme.colorScheme.onPrimaryContainer
            )
            Text(
                text = displayFormat.format(selectedDate.time),
                style = MaterialTheme.typography.headlineSmall,
                color = MaterialTheme.colorScheme.onPrimaryContainer,
                fontWeight = FontWeight.Bold
            )
        }
    }
}

@Composable
private fun MonthYearNavigation(
    currentViewDate: Calendar,
    onMonthChange: (Calendar) -> Unit,
    currentLanguage: String
) {
    val monthFormat = if (currentLanguage == "es") {
        SimpleDateFormat("MMMM yyyy", Locale("es", "ES"))
    } else {
        SimpleDateFormat("MMMM yyyy", Locale.ENGLISH)
    }

    Row(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        IconButton(onClick = {
            val newDate = (currentViewDate.clone() as Calendar).apply {
                add(Calendar.MONTH, -1)
            }
            onMonthChange(newDate)
        }) {
            Text(
                text = "←",
                fontSize = 20.sp,
                color = MaterialTheme.colorScheme.primary,
                fontWeight = FontWeight.Bold
            )
        }

        Text(
            text = monthFormat.format(currentViewDate.time).replaceFirstChar {
                if (it.isLowerCase()) it.titlecase() else it.toString()
            },
            style = MaterialTheme.typography.titleMedium,
            fontWeight = FontWeight.Bold,
            color = MaterialTheme.colorScheme.onSurface
        )

        IconButton(onClick = {
            val newDate = (currentViewDate.clone() as Calendar).apply {
                add(Calendar.MONTH, 1)
            }
            onMonthChange(newDate)
        }) {
            Text(
                text = "→",
                fontSize = 20.sp,
                color = MaterialTheme.colorScheme.primary,
                fontWeight = FontWeight.Bold
            )
        }
    }
}

@Composable
private fun CalendarGrid(
    currentViewDate: Calendar,
    selectedDate: Calendar,
    onDateSelected: (Calendar) -> Unit,
    currentLanguage: String
) {
    val diasSemana = if (currentLanguage == "es") {
        listOf(
            StringResourceManager.getString("lunes", currentLanguage),
            StringResourceManager.getString("martes", currentLanguage),
            StringResourceManager.getString("miercoles", currentLanguage),
            StringResourceManager.getString("jueves", currentLanguage),
            StringResourceManager.getString("viernes", currentLanguage),
            StringResourceManager.getString("sabado", currentLanguage),
            StringResourceManager.getString("domingo", currentLanguage)
        )
    } else {
        listOf("M", "T", "W", "T", "F", "S", "S")
    }

    Column {
        Row(modifier = Modifier.fillMaxWidth()) {
            diasSemana.forEach { dia ->
                Text(
                    text = dia,
                    modifier = Modifier.weight(1f),
                    textAlign = TextAlign.Center,
                    style = MaterialTheme.typography.bodySmall,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.primary
                )
            }
        }

        Spacer(modifier = Modifier.height(8.dp))

        val year = currentViewDate.get(Calendar.YEAR)
        val month = currentViewDate.get(Calendar.MONTH)

        val firstDayOfMonth = (currentViewDate.clone() as Calendar).apply {
            set(Calendar.DAY_OF_MONTH, 1)
        }

        val firstDayOfWeek = (firstDayOfMonth.get(Calendar.DAY_OF_WEEK) + 5) % 7
        val daysInMonth = currentViewDate.getActualMaximum(Calendar.DAY_OF_MONTH)
        val totalCells = 42

        LazyVerticalGrid(
            columns = GridCells.Fixed(7),
            modifier = Modifier.height(240.dp),
            verticalArrangement = Arrangement.spacedBy(4.dp),
            horizontalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            items(totalCells) { index ->
                val dayNumber = index - firstDayOfWeek + 1

                if (dayNumber in 1..daysInMonth) {
                    val dayDate = (currentViewDate.clone() as Calendar).apply {
                        set(Calendar.DAY_OF_MONTH, dayNumber)
                    }

                    val isSelected = isSameDay(dayDate, selectedDate)
                    val isToday = isSameDay(dayDate, Calendar.getInstance())

                    DayCell(
                        day = dayNumber,
                        isSelected = isSelected,
                        isToday = isToday,
                        onClick = { onDateSelected(dayDate) }
                    )
                } else {
                    Box(modifier = Modifier.size(40.dp))
                }
            }
        }
    }
}

@Composable
private fun DayCell(
    day: Int,
    isSelected: Boolean,
    isToday: Boolean,
    onClick: () -> Unit
) {
    Box(
        modifier = Modifier
            .size(40.dp)
            .clickable { onClick() }
            .background(
                color = when {
                    isSelected -> MaterialTheme.colorScheme.primary
                    isToday -> MaterialTheme.colorScheme.primaryContainer
                    else -> Color.Transparent
                },
                shape = RoundedCornerShape(8.dp)
            ),
        contentAlignment = Alignment.Center
    ) {
        Text(
            text = day.toString(),
            style = MaterialTheme.typography.bodyMedium,
            color = when {
                isSelected -> MaterialTheme.colorScheme.onPrimary
                isToday -> MaterialTheme.colorScheme.onPrimaryContainer
                else -> MaterialTheme.colorScheme.onSurface
            },
            fontWeight = if (isSelected || isToday) FontWeight.Bold else FontWeight.Normal
        )
    }
}

private fun isSameDay(cal1: Calendar, cal2: Calendar): Boolean {
    return cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR)
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun TimePickerDialog(
    onTimeSelected: (String) -> Unit,
    onDismiss: () -> Unit,
    initialTime: String = "09:00",
    currentLanguage: String
) {
    val timeParts = initialTime.split(":")
    val initialHour = timeParts.getOrNull(0)?.toIntOrNull() ?: 9
    val initialMinute = timeParts.getOrNull(1)?.toIntOrNull() ?: 0

    val timePickerState = rememberTimePickerState(
        initialHour = initialHour,
        initialMinute = initialMinute,
        is24Hour = true
    )

    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text(StringResourceManager.getString("seleccionar_hora", currentLanguage)) },
        text = {
            Column(
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                TimePicker(
                    state = timePickerState,
                    modifier = Modifier.padding(16.dp)
                )
            }
        },
        confirmButton = {
            TextButton(
                onClick = {
                    val hour = String.format("%02d", timePickerState.hour)
                    val minute = String.format("%02d", timePickerState.minute)
                    onTimeSelected("$hour:$minute")
                }
            ) {
                Text(StringResourceManager.getString("aceptar", currentLanguage))
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text(StringResourceManager.getString("cancelar", currentLanguage))
            }
        }
    )
}
===== END
===== FILE: PantallaArticulos.kt
// app/src/main/java/es/nuskysoftware/marketsales/ui/pantallas/PantallaArticulos.kt
package es.nuskysoftware.marketsales.ui.pantallas

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.github.skydoves.colorpicker.compose.AlphaSlider
import com.github.skydoves.colorpicker.compose.BrightnessSlider
import com.github.skydoves.colorpicker.compose.HsvColorPicker
import com.github.skydoves.colorpicker.compose.rememberColorPickerController
import es.nuskysoftware.marketsales.R
import es.nuskysoftware.marketsales.data.local.entity.ArticuloEntity
import es.nuskysoftware.marketsales.ui.viewmodel.ArticuloViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.ArticuloViewModelFactory
import es.nuskysoftware.marketsales.ui.viewmodel.CategoriaViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.CategoriaViewModelFactory
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.FooterMarca
import es.nuskysoftware.marketsales.utils.StringResourceManager
import es.nuskysoftware.marketsales.utils.generarColorAleatorioPastel
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PantallaArticulos(
    navController: NavController? = null
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()

    // ViewModels con factory
    val articuloViewModel: ArticuloViewModel = viewModel(
        factory = ArticuloViewModelFactory(context)
    )
    val categoriaViewModel: CategoriaViewModel = viewModel(
        factory = CategoriaViewModelFactory(context)
    )

    // Estados de configuración
    val currentLanguage by ConfigurationManager.idioma.collectAsState()
    val esPremium by ConfigurationManager.esPremium.collectAsState()

    // Estados de los ViewModels
    val articulos by articuloViewModel.articulos.collectAsState()
    val categorias by categoriaViewModel.categorias.collectAsState()
    val articuloUiState by articuloViewModel.uiState.collectAsState()
    val tieneArticulos by articuloViewModel.tieneArticulos.collectAsState()

    // Estados locales del formulario
    var mostrarFormulario by remember { mutableStateOf(false) }
    var nombreArticulo by remember { mutableStateOf("") }
    var categoriaSeleccionada by remember { mutableStateOf("") }
    var precioVenta by remember { mutableStateOf("") }
    var precioCoste by remember { mutableStateOf("") }
    var stock by remember { mutableStateOf("") }
    var controlarStock by remember { mutableStateOf(false) }
    var controlarCoste by remember { mutableStateOf(false) }
    var favorito by remember { mutableStateOf(false) }
    var modoEdicion by remember { mutableStateOf<ArticuloEntity?>(null) }

    // Estados de diálogos
    var mostrarDialogoEliminar by remember { mutableStateOf(false) }
    var articuloAEliminar by remember { mutableStateOf<ArticuloEntity?>(null) }
    var mostrarSelectorCategoria by remember { mutableStateOf(false) }

    // Estados para nueva categoría
    var mostrarDialogoNuevaCategoria by remember { mutableStateOf(false) }
    var nombreNuevaCategoria by remember { mutableStateOf("") }
    var colorNuevaCategoria by remember { mutableStateOf(Color(0xFFD1C4E9)) }
    var mostrarColorPicker by remember { mutableStateOf(false) }

    val snackbarHostState = remember { SnackbarHostState() }

    // Función para limpiar formulario
    fun limpiarFormulario() {
        nombreArticulo = ""
        categoriaSeleccionada = ""
        precioVenta = ""
        precioCoste = ""
        stock = ""
        controlarStock = false
        controlarCoste = false
        favorito = false
        modoEdicion = null
    }

    // Manejar mensajes del ViewModel
    LaunchedEffect(articuloUiState.message) {
        articuloUiState.message?.let { message ->
            snackbarHostState.showSnackbar(message)
            articuloViewModel.limpiarMensaje()
        }
    }

    LaunchedEffect(articuloUiState.error) {
        articuloUiState.error?.let { error ->
            snackbarHostState.showSnackbar(error)
            articuloViewModel.limpiarError()
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        StringResourceManager.getString("articulos", currentLanguage),
                        fontWeight = FontWeight.Bold
                    )
                },
                navigationIcon = {
                    IconButton(onClick = { navController?.popBackStack() }) {
                        Icon(
                            painter = painterResource(id = R.drawable.ic_arrow_left),
                            contentDescription = StringResourceManager.getString("volver", currentLanguage)
                        )
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary,
                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary
                )
            )
        },
        snackbarHost = { SnackbarHost(snackbarHostState) },
        floatingActionButton = {
            if (!mostrarFormulario) {
                FloatingActionButton(
                    onClick = {
                        limpiarFormulario()
                        mostrarFormulario = true
                    },
                    shape = CircleShape,
                    containerColor = MaterialTheme.colorScheme.primary,
                    contentColor = MaterialTheme.colorScheme.onPrimary
                ) {
                    Icon(
                        imageVector = Icons.Default.Add,
                        contentDescription = StringResourceManager.getString("add_articulo", currentLanguage)
                    )
                }
            }
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            // ========== FORMULARIO DESLIZANTE ==========
            AnimatedVisibility(visible = mostrarFormulario) {
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    elevation = CardDefaults.cardElevation(defaultElevation = 8.dp),
                    colors = CardDefaults.cardColors(
                        containerColor = MaterialTheme.colorScheme.secondaryContainer
                    ),
                    shape = RoundedCornerShape(16.dp)
                ) {
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(20.dp)
                            .verticalScroll(rememberScrollState())
                    ) {
                        Text(
                            text = if (modoEdicion == null)
                                StringResourceManager.getString("nuevo_articulo", currentLanguage)
                            else
                                StringResourceManager.getString("editar_articulo", currentLanguage),
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold,
                            color = MaterialTheme.colorScheme.onSecondaryContainer
                        )

                        Spacer(modifier = Modifier.height(16.dp))

                        // Campo nombre
                        OutlinedTextField(
                            value = nombreArticulo,
                            onValueChange = { nombreArticulo = it },
                            label = { Text(StringResourceManager.getString("nombre", currentLanguage)) },
                            modifier = Modifier.fillMaxWidth(),
                            isError = nombreArticulo.isNotEmpty() && articuloViewModel.validarNombreArticulo(nombreArticulo) != null,
                            supportingText = {
                                articuloViewModel.validarNombreArticulo(nombreArticulo)?.let { error ->
                                    Text(
                                        text = error,
                                        color = MaterialTheme.colorScheme.error
                                    )
                                }
                            },
                            singleLine = true
                        )

                        Spacer(modifier = Modifier.height(12.dp))

                        // ========== SELECTOR DE CATEGORÍA MEJORADO ==========
                        OutlinedTextField(
                            value = categorias.find { it.idCategoria == categoriaSeleccionada }?.nombre ?: "",
                            onValueChange = { },
                            label = { Text(StringResourceManager.getString("categoria", currentLanguage)) },
                            modifier = Modifier.fillMaxWidth(),
                            readOnly = true,
                            trailingIcon = {
                                IconButton(onClick = { mostrarSelectorCategoria = true }) {
                                    Icon(
                                        painter = painterResource(id = R.drawable.ic_arrow_down),
                                        contentDescription = "Seleccionar categoría"
                                    )
                                }
                            }
                        )

                        Spacer(modifier = Modifier.height(12.dp))

                        // Precio de venta
                        OutlinedTextField(
                            value = precioVenta,
                            onValueChange = { precioVenta = it },
                            label = { Text(StringResourceManager.getString("precio_venta", currentLanguage)) },
                            modifier = Modifier.fillMaxWidth(),
                            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Decimal),
                            isError = precioVenta.isNotEmpty() && precioVenta.toDoubleOrNull()?.let {
                                articuloViewModel.validarPrecioVenta(it)
                            } != null,
                            supportingText = {
                                precioVenta.toDoubleOrNull()?.let { precio ->
                                    articuloViewModel.validarPrecioVenta(precio)?.let { error ->
                                        Text(
                                            text = error,
                                            color = MaterialTheme.colorScheme.error
                                        )
                                    }
                                }
                            },
                            singleLine = true
                        )

                        Spacer(modifier = Modifier.height(12.dp))

                        // ========== CAMPOS PREMIUM CON RESTRICCIONES ==========

                        // Control de coste
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Checkbox(
                                checked = controlarCoste,
                                onCheckedChange = {
                                    if (esPremium) {
                                        controlarCoste = it
                                    }
                                },
                                enabled = esPremium
                            )
                            Column(modifier = Modifier.weight(1f)) {
                                Text(
                                    text = StringResourceManager.getString("controlar_coste", currentLanguage),
                                    color = if (esPremium) MaterialTheme.colorScheme.onSurface else MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f)
                                )
                                if (!esPremium) {
                                    Text(
                                        text = StringResourceManager.getString("solo_premium_coste", currentLanguage),
                                        style = MaterialTheme.typography.bodySmall,
                                        color = MaterialTheme.colorScheme.error.copy(alpha = 0.7f)
                                    )
                                }
                            }
                        }

                        if (controlarCoste && esPremium) {
                            Spacer(modifier = Modifier.height(8.dp))
                            OutlinedTextField(
                                value = precioCoste,
                                onValueChange = { precioCoste = it },
                                label = { Text(StringResourceManager.getString("precio_coste", currentLanguage)) },
                                modifier = Modifier.fillMaxWidth(),
                                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Decimal),
                                singleLine = true
                            )
                        }

                        Spacer(modifier = Modifier.height(12.dp))

                        // Control de stock
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Checkbox(
                                checked = controlarStock,
                                onCheckedChange = {
                                    if (esPremium) {
                                        controlarStock = it
                                    }
                                },
                                enabled = esPremium
                            )
                            Column(modifier = Modifier.weight(1f)) {
                                Text(
                                    text = StringResourceManager.getString("controlar_stock", currentLanguage),
                                    color = if (esPremium) MaterialTheme.colorScheme.onSurface else MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f)
                                )
                                if (!esPremium) {
                                    Text(
                                        text = StringResourceManager.getString("solo_premium_stock", currentLanguage),
                                        style = MaterialTheme.typography.bodySmall,
                                        color = MaterialTheme.colorScheme.error.copy(alpha = 0.7f)
                                    )
                                }
                            }
                        }

                        if (controlarStock && esPremium) {
                            Spacer(modifier = Modifier.height(8.dp))
                            OutlinedTextField(
                                value = stock,
                                onValueChange = { stock = it },
                                label = { Text(StringResourceManager.getString("stock", currentLanguage)) },
                                modifier = Modifier.fillMaxWidth(),
                                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                                singleLine = true
                            )
                        }

                        Spacer(modifier = Modifier.height(12.dp))

                        // Favorito (disponible para todos)
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Checkbox(
                                checked = favorito,
                                onCheckedChange = { favorito = it }
                            )
                            Text(
                                text = StringResourceManager.getString("marcar_favorito", currentLanguage),
                                modifier = Modifier.weight(1f)
                            )
                        }

                        Spacer(modifier = Modifier.height(20.dp))

                        // Botones
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.spacedBy(12.dp)
                        ) {
                            Button(
                                onClick = {
                                    scope.launch {
                                        val validacionNombre = articuloViewModel.validarNombreArticulo(nombreArticulo)
                                        if (validacionNombre != null) {
                                            snackbarHostState.showSnackbar(validacionNombre)
                                            return@launch
                                        }

                                        val precio = precioVenta.toDoubleOrNull()
                                        if (precio == null) {
                                            snackbarHostState.showSnackbar("Precio de venta inválido")
                                            return@launch
                                        }

                                        if (categoriaSeleccionada.isEmpty()) {
                                            snackbarHostState.showSnackbar("Selecciona una categoría")
                                            return@launch
                                        }

                                        if (modoEdicion == null) {
                                            // Crear nuevo artículo
                                            articuloViewModel.crearArticulo(
                                                nombre = nombreArticulo,
                                                idCategoria = categoriaSeleccionada,
                                                precioVenta = precio,
                                                precioCoste = if (controlarCoste && esPremium && precioCoste.isNotEmpty()) precioCoste.toDoubleOrNull() else null,
                                                stock = if (controlarStock && esPremium && stock.isNotEmpty()) stock.toIntOrNull() else null,
                                                controlarStock = controlarStock && esPremium,
                                                controlarCoste = controlarCoste && esPremium,
                                                favorito = favorito
                                            )
                                        } else {
                                            // Actualizar artículo existente
                                            val articuloActualizado = modoEdicion!!.copy(
                                                nombre = nombreArticulo,
                                                idCategoria = categoriaSeleccionada,
                                                precioVenta = precio,
                                                precioCoste = if (controlarCoste && esPremium && precioCoste.isNotEmpty()) precioCoste.toDoubleOrNull() else null,
                                                stock = if (controlarStock && esPremium && stock.isNotEmpty()) stock.toIntOrNull() else null,
                                                controlarStock = controlarStock && esPremium,
                                                controlarCoste = controlarCoste && esPremium,
                                                favorito = favorito
                                            )
                                            articuloViewModel.actualizarArticulo(articuloActualizado)
                                        }

                                        // Limpiar y cerrar formulario
                                        limpiarFormulario()
                                        mostrarFormulario = false
                                    }
                                },
                                enabled = !articuloUiState.loading && nombreArticulo.isNotBlank() && precioVenta.isNotBlank(),
                                modifier = Modifier.weight(1f)
                            ) {
                                if (articuloUiState.loading) {
                                    CircularProgressIndicator(
                                        modifier = Modifier.size(16.dp),
                                        strokeWidth = 2.dp,
                                        color = MaterialTheme.colorScheme.onPrimary
                                    )
                                } else {
                                    Text(StringResourceManager.getString("guardar", currentLanguage))
                                }
                            }

                            OutlinedButton(
                                onClick = {
                                    limpiarFormulario()
                                    mostrarFormulario = false
                                },
                                modifier = Modifier.weight(1f)
                            ) {
                                Text(StringResourceManager.getString("cancelar", currentLanguage))
                            }
                        }
                    }
                }
            }

            // ========== CONTENIDO PRINCIPAL ==========
            Box(
                modifier = Modifier
                    .weight(1f)
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp)
            ) {
                if (!tieneArticulos) {
                    // Estado vacío
                    Column(
                        modifier = Modifier.fillMaxSize(),
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.Center
                    ) {
                        Icon(
                            painter = painterResource(id = R.drawable.ic_list),
                            contentDescription = null,
                            modifier = Modifier.size(64.dp),
                            tint = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.4f)
                        )

                        Spacer(modifier = Modifier.height(16.dp))

                        Text(
                            text = StringResourceManager.getString("pulsa_crear_primer_articulo", currentLanguage),
                            style = MaterialTheme.typography.titleMedium,
                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f),
                            textAlign = TextAlign.Center
                        )
                    }
                } else {
                    // Lista de artículos en Cards
                    LazyColumn(
                        modifier = Modifier.fillMaxSize(),
                        verticalArrangement = Arrangement.spacedBy(8.dp),
                        contentPadding = PaddingValues(vertical = 8.dp)
                    ) {
                        items(articulos) { articulo ->
                            ArticuloCard(
                                articulo = articulo,
                                categorias = categorias,
                                esPremium = esPremium,
                                onEditar = {
                                    // Cargar datos en el formulario
                                    modoEdicion = articulo
                                    nombreArticulo = articulo.nombre
                                    categoriaSeleccionada = articulo.idCategoria
                                    precioVenta = articulo.precioVenta.toString()
                                    precioCoste = articulo.precioCoste?.toString() ?: ""
                                    stock = articulo.stock?.toString() ?: ""
                                    controlarStock = articulo.controlarStock
                                    controlarCoste = articulo.controlarCoste
                                    favorito = articulo.favorito
                                    mostrarFormulario = true
                                },
                                onEliminar = {
                                    articuloAEliminar = articulo
                                    mostrarDialogoEliminar = true
                                }
                            )
                        }
                    }
                }
            }

            // ========== FOOTER ==========
            FooterMarca()
        }
    }

    // ========== DIÁLOGOS ==========

    // ========== SELECTOR DE CATEGORÍA MEJORADO ==========
    if (mostrarSelectorCategoria) {
        AlertDialog(
            onDismissRequest = { mostrarSelectorCategoria = false },
            title = { Text(StringResourceManager.getString("seleccionar_categoria", currentLanguage)) },
            text = {
                LazyColumn {
                    // Opción para crear nueva categoría
                    item {
                        Card(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 4.dp)
                                .clickable {
                                    mostrarSelectorCategoria = false
                                    mostrarDialogoNuevaCategoria = true
                                },
                            colors = CardDefaults.cardColors(
                                containerColor = MaterialTheme.colorScheme.primaryContainer
                            )
                        ) {
                            Row(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .padding(16.dp),
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Icon(
                                    imageVector = Icons.Default.Add,
                                    contentDescription = "Crear categoría",
                                    tint = MaterialTheme.colorScheme.onPrimaryContainer
                                )
                                Spacer(modifier = Modifier.width(12.dp))
                                Text(
                                    text = StringResourceManager.getString("crear_nueva_categoria", currentLanguage),
                                    color = MaterialTheme.colorScheme.onPrimaryContainer,
                                    fontWeight = FontWeight.Medium
                                )
                            }
                        }
                    }

                    // Lista de categorías existentes
                    items(categorias) { categoria ->
                        TextButton(
                            onClick = {
                                categoriaSeleccionada = categoria.idCategoria
                                mostrarSelectorCategoria = false
                            },
                            modifier = Modifier.fillMaxWidth()
                        ) {
                            Row(
                                verticalAlignment = Alignment.CenterVertically,
                                modifier = Modifier.fillMaxWidth()
                            ) {
                                // Círculo de color
                                Box(
                                    modifier = Modifier
                                        .size(16.dp)
                                        .clip(CircleShape)
                                        .background(Color(android.graphics.Color.parseColor(categoria.colorHex)))
                                )
                                Spacer(modifier = Modifier.width(12.dp))
                                Text(categoria.nombre)
                            }
                        }
                    }

                    if (categorias.isEmpty()) {
                        item {
                            Text(
                                text = StringResourceManager.getString("sin_categorias", currentLanguage),
                                color = MaterialTheme.colorScheme.onSurfaceVariant,
                                modifier = Modifier.padding(16.dp)
                            )
                        }
                    }
                }
            },
            confirmButton = {
                TextButton(onClick = { mostrarSelectorCategoria = false }) {
                    Text(StringResourceManager.getString("cancelar", currentLanguage))
                }
            }
        )
    }

    // ========== DIÁLOGO NUEVA CATEGORÍA ==========
    if (mostrarDialogoNuevaCategoria) {
        AlertDialog(
            onDismissRequest = {
                mostrarDialogoNuevaCategoria = false
                nombreNuevaCategoria = ""
                colorNuevaCategoria = Color(0xFFD1C4E9)
            },
            title = { Text(StringResourceManager.getString("nueva_categoria", currentLanguage)) },
            text = {
                Column {
                    OutlinedTextField(
                        value = nombreNuevaCategoria,
                        onValueChange = { nombreNuevaCategoria = it },
                        label = { Text(StringResourceManager.getString("nombre", currentLanguage)) },
                        modifier = Modifier.fillMaxWidth(),
                        singleLine = true
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    // Selector de color
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable { mostrarColorPicker = true }
                            .padding(vertical = 8.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = StringResourceManager.getString("seleccionar_color", currentLanguage),
                            modifier = Modifier.weight(1f)
                        )
                        Spacer(modifier = Modifier.width(16.dp))
                        Box(
                            modifier = Modifier
                                .size(32.dp)
                                .clip(CircleShape)
                                .background(colorNuevaCategoria)
                        )
                    }
                }
            },
            confirmButton = {
                TextButton(
                    onClick = {
                        if (nombreNuevaCategoria.isNotBlank()) {
                            scope.launch {
                                val colorFinal = if (colorNuevaCategoria == Color(0xFFD1C4E9)) {
                                    generarColorAleatorioPastel()
                                } else colorNuevaCategoria

                                val colorHex = String.format("#%06X", 0xFFFFFF and colorFinal.toArgb())

                                categoriaViewModel.crearCategoria(nombreNuevaCategoria, colorHex)

                                // Limpiar y cerrar
                                nombreNuevaCategoria = ""
                                colorNuevaCategoria = Color(0xFFD1C4E9)
                                mostrarDialogoNuevaCategoria = false
                            }
                        }
                    },
                    enabled = nombreNuevaCategoria.isNotBlank()
                ) {
                    Text(StringResourceManager.getString("crear", currentLanguage))
                }
            },
            dismissButton = {
                TextButton(onClick = {
                    mostrarDialogoNuevaCategoria = false
                    nombreNuevaCategoria = ""
                    colorNuevaCategoria = Color(0xFFD1C4E9)
                }) {
                    Text(StringResourceManager.getString("cancelar", currentLanguage))
                }
            }
        )
    }

    // ========== SELECTOR DE COLOR ==========
    if (mostrarColorPicker) {
        ColorPickerDialog(
            onColorElegido = { color ->
                colorNuevaCategoria = color
                mostrarColorPicker = false
            },
            onCancelar = { mostrarColorPicker = false }
        )
    }

    // Confirmación eliminar
    if (mostrarDialogoEliminar && articuloAEliminar != null) {
        AlertDialog(
            onDismissRequest = {
                mostrarDialogoEliminar = false
                articuloAEliminar = null
            },
            title = {
                Text(StringResourceManager.getString("eliminar_articulo", currentLanguage))
            },
            text = {
                Text(
                    StringResourceManager.getString("confirmar_eliminar_articulo", currentLanguage)
                        .replace("{nombre}", articuloAEliminar!!.nombre)
                )
            },
            confirmButton = {
                Button(
                    onClick = {
                        articuloViewModel.eliminarArticulo(articuloAEliminar!!)
                        mostrarDialogoEliminar = false
                        articuloAEliminar = null
                    },
                    colors = ButtonDefaults.buttonColors(
                        containerColor = MaterialTheme.colorScheme.error
                    )
                ) {
                    Text(
                        StringResourceManager.getString("eliminar", currentLanguage),
                        color = MaterialTheme.colorScheme.onError
                    )
                }
            },
            dismissButton = {
                OutlinedButton(
                    onClick = {
                        mostrarDialogoEliminar = false
                        articuloAEliminar = null
                    }
                ) {
                    Text(StringResourceManager.getString("cancelar", currentLanguage))
                }
            }
        )
    }
}


@Composable
private fun ArticuloCard(
    articulo: ArticuloEntity,
    categorias: List<es.nuskysoftware.marketsales.data.local.entity.CategoriaEntity>,
    esPremium: Boolean,
    onEditar: () -> Unit,
    onEliminar: () -> Unit
) {
    val categoria = categorias.find { it.idCategoria == articulo.idCategoria }

    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surface
        ),
        shape = RoundedCornerShape(12.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(modifier = Modifier.weight(1f)) {
                // Nombre del artículo
                Text(
                    text = articulo.nombre,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Medium,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )

                Spacer(modifier = Modifier.height(4.dp))

                // Categoría
                Text(
                    text = categoria?.nombre ?: "Sin categoría",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )

                // Precio de venta
                Text(
                    text = "Precio: ${articulo.precioVenta} €",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurface
                )

                // Información Premium
                if (esPremium) {
                    if (articulo.controlarStock && articulo.stock != null) {
                        Text(
                            text = "Stock: ${articulo.stock}",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                    if (articulo.controlarCoste && articulo.precioCoste != null) {
                        Text(
                            text = "Coste: ${articulo.precioCoste} €",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }

                // Indicador favorito
                if (articulo.favorito) {
                    Text(
                        text = "⭐ Favorito",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.primary
                    )
                }
            }

            // Botones de acción
            Row(
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                IconButton(onClick = onEditar) {
                    Icon(
                        painter = painterResource(id = R.drawable.ic_edit),
                        contentDescription = "Editar",
                        tint = MaterialTheme.colorScheme.primary
                    )
                }

                IconButton(onClick = onEliminar) {
                    Icon(
                        painter = painterResource(id = R.drawable.ic_delete),
                        contentDescription = "Eliminar",
                        tint = MaterialTheme.colorScheme.error
                    )
                }
            }
        }
    }
}


===== END
===== FILE: PantallaCategorias.kt
// app/src/main/java/es/nuskysoftware/marketsales/ui/pantallas/PantallaCategorias.kt
package es.nuskysoftware.marketsales.ui.pantallas

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.github.skydoves.colorpicker.compose.AlphaSlider
import com.github.skydoves.colorpicker.compose.BrightnessSlider
import com.github.skydoves.colorpicker.compose.HsvColorPicker
import com.github.skydoves.colorpicker.compose.rememberColorPickerController
import es.nuskysoftware.marketsales.R
import es.nuskysoftware.marketsales.data.local.entity.CategoriaEntity
import es.nuskysoftware.marketsales.ui.viewmodel.CategoriaViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.CategoriaViewModelFactory
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.FooterMarca
import es.nuskysoftware.marketsales.utils.StringResourceManager
import es.nuskysoftware.marketsales.utils.generarColorAleatorioPastel
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PantallaCategorias(
    navController: NavController? = null
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()

    // ViewModel con factory
    val categoriaViewModel: CategoriaViewModel = viewModel(
        factory = CategoriaViewModelFactory(context)
    )

    // Estados de configuración
    val currentLanguage by ConfigurationManager.idioma.collectAsState()

    // Estados del ViewModel
    val categorias by categoriaViewModel.categorias.collectAsState()
    val uiState by categoriaViewModel.uiState.collectAsState()
    val tieneCategorias by categoriaViewModel.tieneCategorias.collectAsState()

    // Estados locales
    var mostrarFormulario by remember { mutableStateOf(false) }
    var nombreCategoria by remember { mutableStateOf("") }
    var colorSeleccionado by remember { mutableStateOf(Color(0xFFD1C4E9)) }
    var modoEdicion by remember { mutableStateOf<CategoriaEntity?>(null) }

    var mostrarColorPicker by remember { mutableStateOf(false) }
    var mostrarDialogoEliminar by remember { mutableStateOf(false) }
    var categoriaAEliminar by remember { mutableStateOf<CategoriaEntity?>(null) }

    val snackbarHostState = remember { SnackbarHostState() }

    // Manejar mensajes del ViewModel
    LaunchedEffect(uiState.message) {
        uiState.message?.let { message ->
            snackbarHostState.showSnackbar(message)
            categoriaViewModel.limpiarMensaje()
        }
    }

    LaunchedEffect(uiState.error) {
        uiState.error?.let { error ->
            snackbarHostState.showSnackbar(error)
            categoriaViewModel.limpiarError()
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        StringResourceManager.getString("categorias", currentLanguage),
                        fontWeight = FontWeight.Bold
                    )
                },
                navigationIcon = {
                    IconButton(onClick = { navController?.popBackStack() }) {
                        Icon(
                            painter = painterResource(id = R.drawable.ic_arrow_left),
                            contentDescription = StringResourceManager.getString("volver", currentLanguage)
                        )
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary,
                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary
                )
            )
        },
        snackbarHost = { SnackbarHost(snackbarHostState) },
        floatingActionButton = {
            if (!mostrarFormulario) {
                FloatingActionButton(
                    onClick = {
                        mostrarFormulario = true
                        nombreCategoria = ""
                        colorSeleccionado = Color(0xFFD1C4E9)
                        modoEdicion = null
                    },
                    shape = CircleShape,
                    containerColor = MaterialTheme.colorScheme.primary,
                    contentColor = MaterialTheme.colorScheme.onPrimary
                ) {
                    Icon(
                        imageVector = Icons.Default.Add,
                        contentDescription = StringResourceManager.getString("add_categoria", currentLanguage)
                    )
                }
            }
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            // ========== FORMULARIO DESLIZANTE ==========
            AnimatedVisibility(visible = mostrarFormulario) {
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    elevation = CardDefaults.cardElevation(defaultElevation = 8.dp),
                    colors = CardDefaults.cardColors(
                        containerColor = MaterialTheme.colorScheme.secondaryContainer
                    ),
                    shape = RoundedCornerShape(16.dp)
                ) {
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(20.dp)
                    ) {
                        Text(
                            text = if (modoEdicion == null)
                                StringResourceManager.getString("nueva_categoria", currentLanguage)
                            else
                                StringResourceManager.getString("editar_categoria", currentLanguage),
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold,
                            color = MaterialTheme.colorScheme.onSecondaryContainer
                        )

                        Spacer(modifier = Modifier.height(16.dp))

                        // Campo nombre
                        OutlinedTextField(
                            value = nombreCategoria,
                            onValueChange = { nombreCategoria = it },
                            label = { Text(StringResourceManager.getString("nombre", currentLanguage)) },
                            modifier = Modifier.fillMaxWidth(),
                            isError = nombreCategoria.isNotEmpty() && categoriaViewModel.validarNombreCategoria(nombreCategoria) != null,
                            supportingText = {
                                categoriaViewModel.validarNombreCategoria(nombreCategoria)?.let { error ->
                                    Text(
                                        text = error,
                                        color = MaterialTheme.colorScheme.error
                                    )
                                }
                            },
                            singleLine = true
                        )

                        Spacer(modifier = Modifier.height(16.dp))

                        // Selector de color
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .clickable { mostrarColorPicker = true }
                                .padding(vertical = 8.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(
                                text = StringResourceManager.getString("seleccionar_color", currentLanguage),
                                style = MaterialTheme.typography.bodyLarge,
                                color = MaterialTheme.colorScheme.onSecondaryContainer,
                                modifier = Modifier.weight(1f)
                            )

                            Spacer(modifier = Modifier.width(16.dp))

                            Box(
                                modifier = Modifier
                                    .size(40.dp)
                                    .clip(CircleShape)
                                    .background(colorSeleccionado)
                            )
                        }

                        Spacer(modifier = Modifier.height(20.dp))

                        // Botones
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.spacedBy(12.dp)
                        ) {
                            Button(
                                onClick = {
                                    scope.launch {
                                        val validacionNombre = categoriaViewModel.validarNombreCategoria(nombreCategoria)
                                        if (validacionNombre != null) {
                                            snackbarHostState.showSnackbar(validacionNombre)
                                            return@launch
                                        }

                                        val colorFinal = if (colorSeleccionado == Color(0xFFD1C4E9)) {
                                            generarColorAleatorioPastel()
                                        } else colorSeleccionado

                                        val colorHex = String.format("#%06X", 0xFFFFFF and colorFinal.toArgb())

                                        if (modoEdicion == null) {
                                            categoriaViewModel.crearCategoria(nombreCategoria, colorHex)
                                        } else {
                                            val categoriaEditada = modoEdicion!!.copy(
                                                nombre = nombreCategoria,
                                                colorHex = colorHex
                                            )
                                            categoriaViewModel.actualizarCategoria(categoriaEditada)
                                        }

                                        // Limpiar formulario
                                        nombreCategoria = ""
                                        colorSeleccionado = Color(0xFFD1C4E9)
                                        modoEdicion = null
                                        mostrarFormulario = false
                                    }
                                },
                                enabled = !uiState.loading && nombreCategoria.isNotBlank(),
                                modifier = Modifier.weight(1f)
                            ) {
                                if (uiState.loading) {
                                    CircularProgressIndicator(
                                        modifier = Modifier.size(16.dp),
                                        strokeWidth = 2.dp,
                                        color = MaterialTheme.colorScheme.onPrimary
                                    )
                                } else {
                                    Text(StringResourceManager.getString("guardar", currentLanguage))
                                }
                            }

                            OutlinedButton(
                                onClick = {
                                    mostrarFormulario = false
                                    nombreCategoria = ""
                                    colorSeleccionado = Color(0xFFD1C4E9)
                                    modoEdicion = null
                                },
                                modifier = Modifier.weight(1f)
                            ) {
                                Text(StringResourceManager.getString("cancelar", currentLanguage))
                            }
                        }
                    }
                }
            }

            // ========== CONTENIDO PRINCIPAL ==========
            Box(
                modifier = Modifier
                    .weight(1f)
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp)
            ) {
                if (!tieneCategorias) {
                    // Estado vacío
                    Column(
                        modifier = Modifier.fillMaxSize(),
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.Center
                    ) {
                        Icon(
                            painter = painterResource(id = R.drawable.ic_category),
                            contentDescription = null,
                            modifier = Modifier.size(64.dp),
                            tint = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.4f)
                        )

                        Spacer(modifier = Modifier.height(16.dp))

                        Text(
                            text = StringResourceManager.getString("pulsa_crear_primera_categoria", currentLanguage),
                            style = MaterialTheme.typography.titleMedium,
                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f),
                            textAlign = TextAlign.Center
                        )
                    }
                } else {
                    // Lista de categorías en Cards
                    LazyColumn(
                        modifier = Modifier.fillMaxSize(),
                        verticalArrangement = Arrangement.spacedBy(8.dp),
                        contentPadding = PaddingValues(vertical = 8.dp)
                    ) {
                        items(categorias) { categoria ->
                            CategoriaCard(
                                categoria = categoria,
                                onEditar = {
                                    mostrarFormulario = true
                                    nombreCategoria = categoria.nombre
                                    colorSeleccionado = Color(android.graphics.Color.parseColor(categoria.colorHex))
                                    modoEdicion = categoria
                                },
                                onEliminar = {
                                    categoriaAEliminar = categoria
                                    mostrarDialogoEliminar = true
                                }
                            )
                        }
                    }
                }
            }

            // ========== FOOTER ==========
            FooterMarca()
        }
    }

    // ========== DIÁLOGOS ==========

    // Selector de color
    if (mostrarColorPicker) {
        ColorPickerDialog(
            onColorElegido = { color ->
                colorSeleccionado = color
                mostrarColorPicker = false
            },
            onCancelar = { mostrarColorPicker = false }
        )
    }

    // Confirmación eliminar
    if (mostrarDialogoEliminar && categoriaAEliminar != null) {
        AlertDialog(
            onDismissRequest = {
                mostrarDialogoEliminar = false
                categoriaAEliminar = null
            },
            title = {
                Text(StringResourceManager.getString("eliminar_categoria", currentLanguage))
            },
            text = {
                Text(
                    StringResourceManager.getString("confirmar_eliminar_categoria", currentLanguage)
                        .replace("{nombre}", categoriaAEliminar!!.nombre)
                )
            },
            confirmButton = {
                Button(
                    onClick = {
                        categoriaViewModel.eliminarCategoria(categoriaAEliminar!!)
                        mostrarDialogoEliminar = false
                        categoriaAEliminar = null
                    },
                    colors = ButtonDefaults.buttonColors(
                        containerColor = MaterialTheme.colorScheme.error
                    )
                ) {
                    Text(
                        StringResourceManager.getString("eliminar", currentLanguage),
                        color = MaterialTheme.colorScheme.onError
                    )
                }
            },
            dismissButton = {
                OutlinedButton(
                    onClick = {
                        mostrarDialogoEliminar = false
                        categoriaAEliminar = null
                    }
                ) {
                    Text(StringResourceManager.getString("cancelar", currentLanguage))
                }
            }
        )
    }
}

@Composable
private fun CategoriaCard(
    categoria: CategoriaEntity,
    onEditar: () -> Unit,
    onEliminar: () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surface
        ),
        shape = RoundedCornerShape(12.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Row(
                verticalAlignment = Alignment.CenterVertically,
                modifier = Modifier.weight(1f)
            ) {
                // Círculo de color
                Box(
                    modifier = Modifier
                        .size(24.dp)
                        .clip(CircleShape)
                        .background(Color(android.graphics.Color.parseColor(categoria.colorHex)))
                )

                Spacer(modifier = Modifier.width(16.dp))

                // Nombre
                Text(
                    text = categoria.nombre,
                    style = MaterialTheme.typography.bodyLarge,
                    fontWeight = FontWeight.Medium,
                    color = MaterialTheme.colorScheme.onSurface
                )
            }

            // Botones de acción
            Row(
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                IconButton(onClick = onEditar) {
                    Icon(
                        painter = painterResource(id = R.drawable.ic_edit),
                        contentDescription = "Editar",
                        tint = MaterialTheme.colorScheme.primary
                    )
                }

                IconButton(onClick = onEliminar) {
                    Icon(
                        painter = painterResource(id = R.drawable.ic_delete),
                        contentDescription = "Eliminar",
                        tint = MaterialTheme.colorScheme.error
                    )
                }
            }
        }
    }
}

@Composable
fun ColorPickerDialog(
    onColorElegido: (Color) -> Unit,
    onCancelar: () -> Unit
) {
    val controller = rememberColorPickerController()

    AlertDialog(
        onDismissRequest = onCancelar,
        title = { Text("Seleccionar color") },
        text = {
            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                // Selector principal
                HsvColorPicker(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(200.dp)
                        .padding(8.dp),
                    controller = controller,
                    onColorChanged = {}
                )

                // Control de transparencia
                AlphaSlider(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(8.dp),
                    controller = controller
                )

                // Control de brillo
                BrightnessSlider(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(8.dp),
                    controller = controller
                )
            }
        },
        confirmButton = {
            TextButton(onClick = {
                onColorElegido(controller.selectedColor.value)
            }) {
                Text("Aceptar", color = Color.Black) // ✅ NEGRO como solicitaste
            }
        },
        dismissButton = {
            TextButton(onClick = onCancelar) {
                Text("Cancelar", color = Color.Black) // ✅ NEGRO como solicitaste
            }
        }
    )
}
===== END
===== FILE: PantallaConfiguracion.kt
// app/src/main/java/es/nuskysoftware/marketsales/ui/pantallas/PantallaConfiguracion.kt

// PantallaConfiguracion.kt V10 - SIMPLIFICADO PARA SISTEMA MONOUSUARIO
package es.nuskysoftware.marketsales.ui.pantallas

import android.util.Log
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.runtime.rememberCoroutineScope
import androidx.navigation.NavController
import es.nuskysoftware.marketsales.R
import es.nuskysoftware.marketsales.data.repository.AuthRepository
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.FooterMarca
import es.nuskysoftware.marketsales.utils.StringResourceManager
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PantallaConfiguracion(
    navController: NavController? = null
) {
    val context = LocalContext.current
    val authRepo = remember { AuthRepository(context) }
    val scope = rememberCoroutineScope()


    // Estados V10 simplificados
    val currentLanguage by ConfigurationManager.idioma.collectAsState()
    val currentFont by ConfigurationManager.fuente.collectAsState()
    val isDarkTheme by ConfigurationManager.temaOscuro.collectAsState()
    val currentMoneda by ConfigurationManager.moneda.collectAsState()
    val esPremium by ConfigurationManager.esPremium.collectAsState()
    val usuarioEmail by ConfigurationManager.usuarioEmail.collectAsState()
    val isAuthenticated by ConfigurationManager.isAuthenticated.collectAsState()

    // Permisos V10 simplificados
    //val canChangeAdvanced = ConfigurationManager.canChangeConfiguration()
    val canChangeAdvanced = esPremium // En lugar de ConfigurationManager.canChangeConfiguration()

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        StringResourceManager.getString("configuracion", currentLanguage),
                        fontWeight = FontWeight.Bold
                    )
                },
                navigationIcon = {
                    IconButton(onClick = { navController?.popBackStack() }) {
                        Icon(
                            imageVector = Icons.Default.ArrowBack,
                            contentDescription = "Volver"
                        )
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary,
                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary
                )
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            LazyColumn(
                modifier = Modifier
                    .weight(1f)
                    .fillMaxWidth()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                // Información de cuenta V10
                item {
                    TarjetaInformacionCuenta(
                        email = usuarioEmail ?: if (isAuthenticated) "usuario@email.com" else "Usuario Invitado",
                        esPremium = esPremium,
                        isAuthenticated = isAuthenticated,
                        version = "V10.0",
                        language = currentLanguage
                    )
                }

                // Idioma (solo Premium)
                item {
                    OpcionConfiguracionV10(
                        iconRes = R.drawable.ic_language,
                        titulo = StringResourceManager.getString("idioma", currentLanguage),
                        valorActual = if (currentLanguage == "es") "Español" else "English",
                        opciones = listOf("es" to "Español", "en" to "English"),
                        habilitado = canChangeAdvanced,
                        onSeleccionar = { codigo ->
                            scope.launch {
                                authRepo.updateConfiguration(idioma = codigo)

                            }
                        }
                    )
                }

                // Fuente (solo Premium)
                item {
                    OpcionConfiguracionV10(
                        iconRes = R.drawable.ic_font,
                        titulo = StringResourceManager.getString("fuente", currentLanguage),
                        valorActual = currentFont,
                        opciones = listOf("Montserrat" to "Montserrat", "Poppins" to "Poppins", "Roboto" to "Roboto"),
                        habilitado = canChangeAdvanced,
                        onSeleccionar = { fuente ->
                            scope.launch {
                                authRepo.updateConfiguration(fuente = fuente)
                            }
                        }
                    )
                }

                // Tema Oscuro (todos pueden cambiar)
                item {
                    Card(
                        modifier = Modifier.fillMaxWidth(),
                        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),
                        elevation = CardDefaults.cardElevation(4.dp)
                    ) {
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(16.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                painter = painterResource(id = R.drawable.ic_palette),
                                contentDescription = "Tema",
                                tint = MaterialTheme.colorScheme.primary,
                                modifier = Modifier.size(24.dp)
                            )
                            Spacer(modifier = Modifier.width(16.dp))
                            Column(modifier = Modifier.weight(1f)) {
                                Text(
                                    text = StringResourceManager.getString("tema", currentLanguage),
                                    style = MaterialTheme.typography.bodyLarge,
                                    fontWeight = FontWeight.Medium
                                )
                                Text(
                                    text = if (isDarkTheme) "Oscuro" else "Claro",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                                )
                            }
                            Switch(
                                checked = isDarkTheme,
                                onCheckedChange = { nuevoValor ->
                                    scope.launch {
                                        authRepo.updateConfiguration(temaOscuro = nuevoValor)
                                    }
                                }
                            )
                        }
                    }
                }

                // Moneda (solo Premium)
                item {
                    val monedas = listOf(
                        "€ Euro" to "€ Euro",
                        "$ Dólar" to "$ Dólar",
                        "£ Libra" to "£ Libra",
                        "$ Peso Argentino" to "$ Peso Argentino",
                        "$ Peso Mexicano" to "$ Peso Mexicano",
                        "$ Peso Colombiano" to "$ Peso Colombiano",
                        "S/ Sol Peruano" to "S/ Sol Peruano",
                        "$ Peso Chileno" to "$ Peso Chileno",
                        "Bs Bolívar" to "Bs Bolívar",
                        "$ Real Brasileño" to "$ Real Brasileño"
                    )

                    OpcionConfiguracionV10(
                        iconRes = R.drawable.ic_money,
                        titulo = "Moneda",
                        valorActual = currentMoneda,
                        opciones = monedas,
                        habilitado = canChangeAdvanced,
                        onSeleccionar = { moneda ->
                            scope.launch {
                                authRepo.updateConfiguration(moneda = moneda)
                            }
                        }
                    )
                }

                // Sección desarrollo/testing


                // Reemplazar la sección de desarrollo/testing en PantallaConfiguracion.kt:

// Sección desarrollo/testing - ✅ TOGGLE PREMIUM ARREGLADO
                item {
                    Card(
                        modifier = Modifier.fillMaxWidth().clickable {
                            // ✅ CAMBIO: Usar función simplificada para desarrollo
                            ConfigurationManager.togglePremiumForDevelopment()
                        },
                        colors = CardDefaults.cardColors(
                            containerColor = if (esPremium) {
                                Color(0xFFFFD700).copy(alpha = 0.3f) // Dorado para Premium
                            } else {
                                MaterialTheme.colorScheme.secondaryContainer // Normal para Free
                            }
                        ),
                        elevation = CardDefaults.cardElevation(
                            defaultElevation = if (esPremium) 8.dp else 4.dp
                        )
                    ) {
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(16.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                painter = painterResource(
                                    id = if (esPremium) R.drawable.ic_info else R.drawable.ic_settings
                                ),
                                contentDescription = "Desarrollo",
                                tint = if (esPremium) {
                                    Color(0xFFFFD700) // Dorado para Premium
                                } else {
                                    MaterialTheme.colorScheme.onSecondaryContainer
                                },
                                modifier = Modifier.size(24.dp)
                            )
                            Spacer(modifier = Modifier.width(16.dp))
                            Column(modifier = Modifier.weight(1f)) {
                                Text(
                                    text = "🔧 Toggle Premium (Desarrollo)",
                                    style = MaterialTheme.typography.bodyLarge,
                                    fontWeight = FontWeight.Bold,
                                    color = if (esPremium) {
                                        Color(0xFFFFD700)
                                    } else {
                                        MaterialTheme.colorScheme.onSecondaryContainer
                                    }
                                )
                                Text(
                                    text = if (esPremium) "🚀 PREMIUM ACTIVO - Tap para FREE" else "✋ MODO FREE - Tap para PREMIUM",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = if (esPremium) {
                                        Color(0xFFFFD700).copy(alpha = 0.8f)
                                    } else {
                                        MaterialTheme.colorScheme.onSecondaryContainer.copy(alpha = 0.7f)
                                    }
                                )
                                if (esPremium) {
                                    Text(
                                        text = "• Idiomas adicionales\n• Fuentes personalizadas\n• Monedas múltiples",
                                        style = MaterialTheme.typography.bodySmall,
                                        fontSize = 10.sp,
                                        color = Color(0xFFFFD700).copy(alpha = 0.6f)
                                    )
                                }
                            }

                            // Indicador visual del estado
                            Card(
                                colors = CardDefaults.cardColors(
                                    containerColor = if (esPremium) Color(0xFFFFD700) else Color.Gray
                                ),
                                modifier = Modifier.padding(4.dp)
                            ) {
                                Text(
                                    text = if (esPremium) "PREMIUM" else "FREE",
                                    modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp),
                                    fontSize = 12.sp,
                                    fontWeight = FontWeight.Bold,
                                    color = Color.Black
                                )
                            }
                        }
                    }
                }

                // Promoción Premium para usuarios FREE
                if (!esPremium) {
                    item {
                        TarjetaPromocionPremium(language = currentLanguage)
                    }
                }
            }

            // Footer
            FooterMarca()
        }
    }
    // 🔍 LOG TEMPORAL para debugging
    LaunchedEffect(esPremium, canChangeAdvanced) {
        Log.d("PantallaConfiguracion", "🔍 Estado actual:")
        Log.d("PantallaConfiguracion", "   - esPremium: $esPremium")
        Log.d("PantallaConfiguracion", "   - canChangeAdvanced: $canChangeAdvanced")
        Log.d("PantallaConfiguracion", "   - isAuthenticated: $isAuthenticated")
    }
}

@Composable
private fun OpcionConfiguracionV10(
    iconRes: Int,
    titulo: String,
    valorActual: String,
    opciones: List<Pair<String, String>>,
    habilitado: Boolean,
    onSeleccionar: (String) -> Unit
) {
    var expanded by remember { mutableStateOf(false) }

    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = if (habilitado)
                MaterialTheme.colorScheme.surface
            else
                MaterialTheme.colorScheme.surface.copy(alpha = 0.5f)
        ),
        elevation = CardDefaults.cardElevation(if (habilitado) 4.dp else 2.dp)
    ) {
        Column {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .clickable(enabled = habilitado) {
                        if (habilitado) expanded = !expanded
                    }
                    .padding(16.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Icon(
                    painter = painterResource(id = iconRes),
                    contentDescription = titulo,
                    tint = if (habilitado)
                        MaterialTheme.colorScheme.primary
                    else
                        MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f),
                    modifier = Modifier.size(24.dp)
                )
                Spacer(modifier = Modifier.width(16.dp))
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = titulo,
                        style = MaterialTheme.typography.bodyLarge,
                        fontWeight = FontWeight.Medium,
                        color = if (habilitado)
                            MaterialTheme.colorScheme.onSurface
                        else
                            MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f)
                    )
                    Text(
                        text = valorActual,
                        style = MaterialTheme.typography.bodySmall,
                        color = if (habilitado)
                            MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                        else
                            MaterialTheme.colorScheme.onSurface.copy(alpha = 0.3f)
                    )
                    if (!habilitado) {
                        Text(
                            text = "Solo Premium",
                            style = MaterialTheme.typography.bodySmall,
                            color = Color.Red.copy(alpha = 0.7f)
                        )
                    }
                }
                if (habilitado) {
                    Icon(
                        painter = painterResource(
                            id = if (expanded) R.drawable.ic_arrow_up else R.drawable.ic_arrow_down
                        ),
                        contentDescription = "Expandir",
                        tint = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f),
                        modifier = Modifier.size(16.dp)
                    )
                }
            }
            if (expanded && habilitado) {
                Column(modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)) {
                    opciones.forEach { (codigo, nombre) ->
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .clickable {
                                    onSeleccionar(codigo)
                                    expanded = false
                                }
                                .padding(vertical = 8.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            RadioButton(
                                selected = valorActual == codigo,
                                onClick = {
                                    onSeleccionar(codigo)
                                    expanded = false
                                }
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text(nombre)
                        }
                    }
                }
            }
        }
    }
}

@Composable
private fun TarjetaInformacionCuenta(
    email: String,
    esPremium: Boolean,
    isAuthenticated: Boolean,
    version: String,
    language: String
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),
        elevation = CardDefaults.cardElevation(4.dp)
    ) {
        Column(modifier = Modifier.padding(16.dp)) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = StringResourceManager.getString("informacion_cuenta", language),
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
                Card(
                    colors = CardDefaults.cardColors(
                        containerColor = when {
                            !isAuthenticated -> Color(0xFFCCCCCC)
                            esPremium -> Color(0xFFFFD700)
                            else -> Color(0xFF90EE90)
                        }
                    ),
                    modifier = Modifier.padding(4.dp)
                ) {
                    Text(
                        text = when {
                            !isAuthenticated -> "INVITADO"
                            esPremium -> "PREMIUM"
                            else -> "FREE"
                        },
                        modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp),
                        fontSize = 12.sp,
                        fontWeight = FontWeight.Bold,
                        color = Color.Black
                    )
                }
            }
            Spacer(modifier = Modifier.height(8.dp))
            Text(
                text = email,
                style = MaterialTheme.typography.bodyLarge,
                color = MaterialTheme.colorScheme.onSurface
            )
            Text(
                text = "App $version",
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
            )
        }
    }
}

@Composable
private fun TarjetaPromocionPremium(language: String) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(containerColor = Color(0xFFFFD700).copy(alpha = 0.3f)),
        elevation = CardDefaults.cardElevation(6.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Icon(
                painter = painterResource(id = R.drawable.ic_info),
                contentDescription = "Premium",
                tint = Color(0xFFFFD700),
                modifier = Modifier.size(32.dp)
            )
            Spacer(modifier = Modifier.height(8.dp))
            Text(
                text = StringResourceManager.getString("promocion_premium", language),
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold,
                color = MaterialTheme.colorScheme.onSurface
            )
            Text(
                text = StringResourceManager.getString("desbloquea_funciones", language),
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.8f)
            )
        }
    }
}
===== END
===== FILE: PantallaLogin.kt
// app/src/main/java/es/nuskysoftware/marketsales/ui/pantallas/PantallaLogin.kt
package es.nuskysoftware.marketsales.ui.pantallas

import android.app.Activity
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardActions
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Email
import androidx.compose.material.icons.filled.Lock
import androidx.compose.material.icons.filled.Visibility
import androidx.compose.material.icons.filled.VisibilityOff
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.focus.FocusDirection
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalFocusManager
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.text.input.VisualTransformation
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.google.android.gms.auth.api.signin.GoogleSignIn
import com.google.android.gms.common.api.ApiException
import es.nuskysoftware.marketsales.R
import es.nuskysoftware.marketsales.data.repository.AuthState
import es.nuskysoftware.marketsales.ui.viewmodel.AuthViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.AuthViewModelFactory
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.StringResourceManager

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PantallaLogin(
    onNavigateToMain: () -> Unit = {}
) {
    val context = LocalContext.current
    val focusManager = LocalFocusManager.current

    // ✅ CORRECCIÓN: Pasar context al factory
    val authViewModel: AuthViewModel = viewModel(
        factory = AuthViewModelFactory(context)
    )

    val authState by authViewModel.authState.collectAsState()

    // Para forzar recomposición al cambiar idioma
    val currentLanguage by ConfigurationManager.idioma.collectAsState()

    // Estados locales
    var email by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }
    var isPasswordVisible by remember { mutableStateOf(false) }
    var isLoginMode by remember { mutableStateOf(true) } // true = Login, false = Registro
    var showError by remember { mutableStateOf(false) }
    var errorMessage by remember { mutableStateOf("") }

    // Validaciones
    val isEmailValid = email.contains("@") && email.contains(".")
    val isPasswordValid = password.length >= 6
    val isFormValid = isEmailValid && isPasswordValid

    // 🚀 GOOGLE AUTH V8 - CONFIGURACIÓN GOOGLE SIGN-IN ACTIVA
    val googleSignInClient = remember {
        try {
            es.nuskysoftware.marketsales.utils.GoogleAuthHelper.getGoogleSignInClient(context)
        } catch (e: Exception) {
            null // Si falla, Google Auth no disponible
        }
    }

    // Launcher para Google Sign-In
    val googleSignInLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.StartActivityForResult()
    ) { result ->
        if (result.resultCode == Activity.RESULT_OK) {
            val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)
            try {
                val account = task.getResult(ApiException::class.java)
                val idToken = account?.idToken
                if (idToken != null) {
                    authViewModel.signInWithGoogle(idToken)
                } else {
                    errorMessage = "Error obteniendo token de Google"
                    showError = true
                }
            } catch (e: ApiException) {
                errorMessage = "Error en Google Sign-In: ${e.message}"
                showError = true
            }
        }
    }

    // Navegar tras autenticación
    LaunchedEffect(authState) {
        when (authState) {
            is AuthState.Authenticated -> onNavigateToMain()
            is AuthState.Error -> {
                errorMessage = (authState as AuthState.Error).message
                showError = true
            }
            else -> { }
        }
    }

    fun handleAuthAction() {
        if (!isFormValid) return
        showError = false
        if (isLoginMode) authViewModel.loginWithEmail(email, password)
        else authViewModel.registerWithEmail(email, password)
    }

    // 🚀 GOOGLE AUTH V8 - FUNCIÓN PARA GOOGLE SIGN-IN ACTIVA
    fun handleGoogleSignIn() {
        if (googleSignInClient != null) {
            showError = false
            val signInIntent = googleSignInClient.signInIntent
            googleSignInLauncher.launch(signInIntent)
        } else {
            errorMessage = "Google Auth no disponible - Revisa configuración"
            showError = true
        }
    }

    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(
                brush = Brush.verticalGradient(
                    colors = listOf(
                        MaterialTheme.colorScheme.primary.copy(alpha = 0.1f),
                        MaterialTheme.colorScheme.surface
                    )
                )
            )
    ) {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .verticalScroll(rememberScrollState())
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            // Logo
            Card(
                modifier = Modifier
                    .size(100.dp)
                    .padding(bottom = 16.dp),
                shape = RoundedCornerShape(50.dp),
                elevation = CardDefaults.cardElevation(8.dp)
            ) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Image(
                        painter = painterResource(id = R.drawable.ic_store),
                        contentDescription = StringResourceManager.getString("app_name", currentLanguage),
                        modifier = Modifier.size(60.dp)
                    )
                }
            }

            // Título App
            Text(
                text = StringResourceManager.getString("app_name", currentLanguage),
                style = MaterialTheme.typography.headlineMedium.copy(
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.primary
                ),
                modifier = Modifier.padding(bottom = 8.dp)
            )

            // Subtítulo Login/Registro
            Text(
                text = if (isLoginMode)
                    StringResourceManager.getString("login_subtitle", currentLanguage)
                else
                    StringResourceManager.getString("register_subtitle", currentLanguage),
                style = MaterialTheme.typography.bodyLarge.copy(
                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                ),
                textAlign = TextAlign.Center,
                modifier = Modifier.padding(bottom = 32.dp)
            )

            // Formulario
            Card(
                modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp),
                elevation = CardDefaults.cardElevation(4.dp),
                shape = RoundedCornerShape(16.dp)
            ) {
                Column(
                    modifier = Modifier.fillMaxWidth().padding(24.dp),
                    verticalArrangement = Arrangement.spacedBy(16.dp)
                ) {
                    // Email
                    OutlinedTextField(
                        value = email,
                        onValueChange = {
                            email = it
                            showError = false
                        },
                        label = { Text(StringResourceManager.getString("email", currentLanguage)) },
                        placeholder = { Text(StringResourceManager.getString("email_placeholder", currentLanguage)) },
                        leadingIcon = { Icon(Icons.Default.Email, contentDescription = null) },
                        modifier = Modifier.fillMaxWidth(),
                        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email, imeAction = ImeAction.Next),
                        keyboardActions = KeyboardActions(onNext = { focusManager.moveFocus(FocusDirection.Down) }),
                        isError = email.isNotEmpty() && !isEmailValid,
                        supportingText = {
                            if (email.isNotEmpty() && !isEmailValid) {
                                Text(
                                    text = StringResourceManager.getString("email_invalid", currentLanguage),
                                    color = MaterialTheme.colorScheme.error
                                )
                            }
                        },
                        singleLine = true
                    )

                    // Contraseña
                    OutlinedTextField(
                        value = password,
                        onValueChange = {
                            password = it
                            showError = false
                        },
                        label = { Text(StringResourceManager.getString("password", currentLanguage)) },
                        placeholder = { Text(StringResourceManager.getString("password_placeholder", currentLanguage)) },
                        leadingIcon = { Icon(Icons.Default.Lock, contentDescription = null) },
                        trailingIcon = {
                            IconButton(onClick = { isPasswordVisible = !isPasswordVisible }) {
                                Icon(
                                    imageVector = if (isPasswordVisible) Icons.Default.Visibility else Icons.Default.VisibilityOff,
                                    contentDescription = if (isPasswordVisible)
                                        "Ocultar contraseña" else "Mostrar contraseña"
                                )
                            }
                        },
                        visualTransformation = if (isPasswordVisible) VisualTransformation.None else PasswordVisualTransformation(),
                        modifier = Modifier.fillMaxWidth(),
                        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password, imeAction = ImeAction.Done),
                        keyboardActions = KeyboardActions(onDone = {
                            focusManager.clearFocus()
                            if (isFormValid) handleAuthAction()
                        }),
                        isError = password.isNotEmpty() && !isPasswordValid,
                        supportingText = {
                            if (password.isNotEmpty() && !isPasswordValid) {
                                Text(
                                    text = StringResourceManager.getString("password_invalid", currentLanguage),
                                    color = MaterialTheme.colorScheme.error
                                )
                            }
                        },
                        singleLine = true
                    )

                    // Error genérico
                    if (showError && errorMessage.isNotEmpty()) {
                        Card(
                            modifier = Modifier.fillMaxWidth(),
                            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.errorContainer)
                        ) {
                            Text(
                                text = errorMessage,
                                color = MaterialTheme.colorScheme.onErrorContainer,
                                style = MaterialTheme.typography.bodyMedium,
                                modifier = Modifier.padding(12.dp)
                            )
                        }
                    }
                }
            }

            // Botón principal
            Button(
                onClick = { handleAuthAction() },
                modifier = Modifier.fillMaxWidth().height(56.dp),
                enabled = isFormValid && authState !is AuthState.Loading,
                shape = RoundedCornerShape(28.dp)
            ) {
                if (authState is AuthState.Loading) {
                    Row(verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                        CircularProgressIndicator(modifier = Modifier.size(20.dp), strokeWidth = 2.dp, color = MaterialTheme.colorScheme.onPrimary)
                        Text(StringResourceManager.getString("loading", currentLanguage), fontSize = 16.sp, fontWeight = FontWeight.Medium)
                    }
                } else {
                    Text(
                        text = if (isLoginMode)
                            StringResourceManager.getString("login_button", currentLanguage)
                        else
                            StringResourceManager.getString("register_button", currentLanguage),
                        fontSize = 16.sp,
                        fontWeight = FontWeight.Medium
                    )
                }
            }

            // Divisor
            Row(modifier = Modifier.fillMaxWidth().padding(vertical = 24.dp), verticalAlignment = Alignment.CenterVertically) {
                HorizontalDivider(modifier = Modifier.weight(1f))
                Text(
                    StringResourceManager.getString("or", currentLanguage),
                    modifier = Modifier.padding(horizontal = 16.dp),
                    style = MaterialTheme.typography.bodyMedium.copy(color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f))
                )
                HorizontalDivider(modifier = Modifier.weight(1f))
            }

            // 🚀 GOOGLE AUTH V8 - BOTÓN GOOGLE SIGN-IN MEJORADO
            if (googleSignInClient != null) {
                OutlinedButton(
                    onClick = { handleGoogleSignIn() },
                    modifier = Modifier.fillMaxWidth().height(56.dp),
                    enabled = authState !is AuthState.Loading,
                    shape = RoundedCornerShape(28.dp),
                    border = ButtonDefaults.outlinedButtonBorder.copy(
                        width = 2.dp,
                        brush = Brush.horizontalGradient(
                            colors = listOf(
                                MaterialTheme.colorScheme.primary,
                                MaterialTheme.colorScheme.secondary
                            )
                        )
                    )
                ) {
                    if (authState is AuthState.Loading) {
                        CircularProgressIndicator(
                            modifier = Modifier.size(20.dp),
                            strokeWidth = 2.dp,
                            color = MaterialTheme.colorScheme.primary
                        )
                    } else {
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                            horizontalArrangement = Arrangement.spacedBy(12.dp)
                        ) {
                            // Google Icon (usando un painterResource o puedes usar un ícono personalizado)
                            Icon(
                                painter = painterResource(id = R.drawable.ic_store), // Usar ícono de Google si tienes
                                contentDescription = "Google",
                                modifier = Modifier.size(20.dp),
                                tint = MaterialTheme.colorScheme.primary
                            )
                            Text(
                                text = if (isLoginMode)
                                    StringResourceManager.getString("google_signin", currentLanguage)
                                else
                                    StringResourceManager.getString("google_register", currentLanguage),
                                fontSize = 16.sp,
                                fontWeight = FontWeight.Medium,
                                color = MaterialTheme.colorScheme.primary
                            )
                        }
                    }
                }
            }

            Spacer(modifier = Modifier.height(32.dp))

            // Toggle Login/Registro
            TextButton(
                onClick = {
                    isLoginMode = !isLoginMode
                    showError = false
                    errorMessage = ""
                }
            ) {
                Text(
                    text = if (isLoginMode)
                        StringResourceManager.getString("go_to_register", currentLanguage)
                    else
                        StringResourceManager.getString("go_to_login", currentLanguage),
                    style = MaterialTheme.typography.bodyMedium.copy(
                        color = MaterialTheme.colorScheme.primary,
                        fontWeight = FontWeight.Medium
                    )
                )
            }

            // Beneficios del registro (solo en modo registro)
            if (!isLoginMode) {
                Spacer(modifier = Modifier.height(16.dp))
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(
                        containerColor = MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.3f)
                    ),
                    elevation = CardDefaults.cardElevation(2.dp)
                ) {
                    Column(modifier = Modifier.padding(16.dp)) {
                        Text(
                            text = StringResourceManager.getString("register_benefits_title", currentLanguage),
                            style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.Bold),
                            color = MaterialTheme.colorScheme.onSurface
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                        listOf("benefit_1", "benefit_2", "benefit_3", "benefit_4").forEach { benefit ->
                            Text(
                                text = StringResourceManager.getString(benefit, currentLanguage),
                                style = MaterialTheme.typography.bodySmall,
                                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.8f),
                                modifier = Modifier.padding(vertical = 2.dp)
                            )
                        }
                    }
                }
            }
        }
    }
}
===== END
===== FILE: PantallaMercadillos.kt
// app/src/main/java/es/nuskysoftware/marketsales/ui/pantallas/PantallaMercadillos.kt
// ACTUALIZACIÓN PARA INCLUIR BOTTOMBAR

package es.nuskysoftware.marketsales.ui.pantallas

import es.nuskysoftware.marketsales.ui.components.MenuHamburguesa
import es.nuskysoftware.marketsales.ui.components.BottomBarMercadillo
import es.nuskysoftware.marketsales.ui.components.DialogoSeleccionMercadilloActivo
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Info
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.DialogProperties
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import kotlinx.coroutines.launch
import es.nuskysoftware.marketsales.R
import es.nuskysoftware.marketsales.data.local.entity.MercadilloEntity
import es.nuskysoftware.marketsales.ui.viewmodel.MercadilloViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.MercadilloViewModelFactory
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.EstadosMercadillo
import es.nuskysoftware.marketsales.utils.FooterMarca
import es.nuskysoftware.marketsales.utils.StringResourceManager

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PantallaMercadillos(
    navController: NavController? = null
) {
    val context = LocalContext.current

    // ViewModel con factory
    val mercadilloViewModel: MercadilloViewModel = viewModel(
        factory = MercadilloViewModelFactory(context)
    )

    // Estados para el drawer
    val drawerState = rememberDrawerState(DrawerValue.Closed)
    val scope = rememberCoroutineScope()

    // Estados de configuración
    val currentLanguage by ConfigurationManager.idioma.collectAsState()

    // Estados del ViewModel
    val uiState by mercadilloViewModel.uiState.collectAsState()
    val calendarioState by mercadilloViewModel.calendarioState.collectAsState()
    val mercadillosPorDia by mercadilloViewModel.mercadillosPorDia.collectAsState()
    val proximoMercadillo by mercadilloViewModel.proximoMercadillo.collectAsState()
    val nombreMesActual by mercadilloViewModel.nombreMesActual.collectAsState()
    val tieneMercadillos by mercadilloViewModel.tieneMercadillos.collectAsState()

    // ✅ NUEVOS ESTADOS PARA BOTTOMBAR
    val mostrarBottomBar by mercadilloViewModel.mostrarBottomBar.collectAsState()
    val mercadillosEnCurso by mercadilloViewModel.mercadillosEnCurso.collectAsState()
    val mercadilloActivoParaOperaciones by mercadilloViewModel.mercadilloActivoParaOperaciones.collectAsState()

    // Estados locales
    var mostrarLeyenda by remember { mutableStateOf(false) }
    var mostrarDialogoSeleccion by remember { mutableStateOf(false) }
    var mercadillosParaSeleccionar by remember { mutableStateOf<List<MercadilloEntity>>(emptyList()) }

    // ✅ NUEVOS ESTADOS PARA MERCADILLOS PRÓXIMOS
    val mercadillosProximos by mercadilloViewModel.mercadillosProximos.collectAsState()
    val tieneMercadillosProximos by mercadilloViewModel.tieneMercadillosProximos.collectAsState()



    // ✅ NUEVOS ESTADOS PARA BOTTOMBAR
    var mostrarDialogoSeleccionActivo by remember { mutableStateOf(false) }
    var accionPendiente by remember { mutableStateOf<String?>(null) } // "ventas", "gastos", "resumen"

    val snackbarHostState = remember { SnackbarHostState() }

    // Función para manejar click en día del calendario
    fun manejarClickDiaCalendario(mercadillosDelDia: List<MercadilloEntity>) {
        when (mercadillosDelDia.size) {
            0 -> {
                // No hay mercadillos, no hacer nada
            }
            1 -> {
                // Un solo mercadillo → abrir directamente en edición
                val mercadillo = mercadillosDelDia.first()
                navController?.navigate("editar_mercadillo/${mercadillo.idMercadillo}")
            }
            else -> {
                // Múltiples mercadillos → mostrar diálogo de selección
                mercadillosParaSeleccionar = mercadillosDelDia
                mostrarDialogoSeleccion = true
            }
        }
    }

    // ✅ NUEVAS FUNCIONES PARA BOTTOMBAR
    fun manejarOperacion(tipoOperacion: String) {
        val (puedeNavegar, mercadillo) = when (tipoOperacion) {
            "ventas" -> mercadilloViewModel.manejarNavegacionVentas()
            "gastos" -> mercadilloViewModel.manejarNavegacionGastos()
            "resumen" -> mercadilloViewModel.manejarNavegacionResumen()
            else -> Pair(false, null)
        }

        if (puedeNavegar && mercadillo != null) {
            // Navegar directamente
            when (tipoOperacion) {
                "ventas" -> navController?.navigate("ventas/${mercadillo.idMercadillo}")
                "gastos" -> navController?.navigate("gastos/${mercadillo.idMercadillo}")
                "resumen" -> navController?.navigate("resumen/${mercadillo.idMercadillo}")
            }
        } else if (mercadillosEnCurso.size > 1) {
            // Mostrar diálogo de selección
            accionPendiente = tipoOperacion
            mostrarDialogoSeleccionActivo = true
        }
        // Si hay error, el ViewModel ya lo habrá mostrado en uiState.error
    }

    // Manejar mensajes del ViewModel
    LaunchedEffect(uiState.message) {
        uiState.message?.let { message ->
            snackbarHostState.showSnackbar(message)
            mercadilloViewModel.limpiarMensaje()
        }
    }

    LaunchedEffect(uiState.error) {
        uiState.error?.let { error ->
            snackbarHostState.showSnackbar(error)
            mercadilloViewModel.limpiarError()
        }
    }

    // ✅ ModalNavigationDrawer que envuelve todo
    ModalNavigationDrawer(
        drawerState = drawerState,
        drawerContent = {
            // Solo mostrar el menú si navController no es null
            navController?.let { nav ->
                MenuHamburguesa(
                    navController = nav,
                    drawerState = drawerState
                )
            }
        }
    ) {
        Scaffold(
            topBar = {
                TopAppBar(
                    title = {
                        Text(
                            StringResourceManager.getString("mercadillos", currentLanguage),
                            fontWeight = FontWeight.Bold
                        )
                    },
                    navigationIcon = {
                        IconButton(
                            onClick = {
                                scope.launch {
                                    drawerState.open()
                                }
                            }
                        ) {
                            Icon(
                                painter = painterResource(id = R.drawable.ic_menu),
                                contentDescription = StringResourceManager.getString("menu", currentLanguage)
                            )
                        }
                    },
                    colors = TopAppBarDefaults.topAppBarColors(
                        containerColor = MaterialTheme.colorScheme.primary,
                        titleContentColor = MaterialTheme.colorScheme.onPrimary,
                        navigationIconContentColor = MaterialTheme.colorScheme.onPrimary
                    )
                )
            },
            snackbarHost = { SnackbarHost(snackbarHostState) },
            floatingActionButton = {
                FloatingActionButton(
                    onClick = {
                        // Navegar a pantalla de crear mercadillo
                        navController?.navigate("alta_mercadillo")
                    },
                    shape = CircleShape,
                    containerColor = MaterialTheme.colorScheme.primary,
                    contentColor = MaterialTheme.colorScheme.onPrimary
                ) {
                    Icon(
                        imageVector = Icons.Default.Add,
                        contentDescription = StringResourceManager.getString("add_mercadillo", currentLanguage)
                    )
                }
            },
            // ✅ BOTTOMBAR CONDICIONAL
            bottomBar = {
                if (mostrarBottomBar) {
                    BottomBarMercadillo(
                        mercadilloActivo = mercadilloActivoParaOperaciones,
                        onVentasClick = { manejarOperacion("ventas") },
                        onGastosClick = { manejarOperacion("gastos") },
                        onResumenClick = { manejarOperacion("resumen") },
                        onCambiarMercadillo = { mercadilloViewModel.cambiarMercadilloActivo() },
                        currentLanguage = currentLanguage
                    )
                }
            }
        ) { paddingValues ->
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues)
                    .background(MaterialTheme.colorScheme.background)
            ) {
                // ========== CALENDARIO CON MERCADILLOS ==========
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(350.dp)
                        .padding(horizontal = 16.dp, vertical = 8.dp),
                    elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
                    colors = CardDefaults.cardColors(
                        containerColor = MaterialTheme.colorScheme.surface
                    )
                ) {
                    Column(
                        modifier = Modifier
                            .fillMaxSize()
                            .padding(16.dp)
                    ) {
                        // Header del calendario con navegación entre meses
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            // Flecha mes anterior
                            IconButton(
                                onClick = { mercadilloViewModel.navegarMesAnterior() }
                            ) {
                                Text(
                                    text = "←",
                                    fontSize = 20.sp,
                                    color = MaterialTheme.colorScheme.primary
                                )
                            }

                            // Título del mes y año
                            Text(
                                text = nombreMesActual,
                                style = MaterialTheme.typography.titleLarge,
                                fontWeight = FontWeight.Bold,
                                color = MaterialTheme.colorScheme.onSurface
                            )

                            // Flecha mes siguiente
                            IconButton(
                                onClick = { mercadilloViewModel.navegarMesSiguiente() }
                            ) {
                                Text(
                                    text = "→",
                                    fontSize = 20.sp,
                                    color = MaterialTheme.colorScheme.primary
                                )
                            }

                            // Botón de leyenda
                            IconButton(
                                onClick = { mostrarLeyenda = true },
                                modifier = Modifier.size(32.dp)
                            ) {
                                Icon(
                                    imageVector = Icons.Default.Info,
                                    contentDescription = StringResourceManager.getString("ver_leyenda", currentLanguage),
                                    tint = MaterialTheme.colorScheme.primary,
                                    modifier = Modifier.size(20.dp)
                                )
                            }
                        }

                        Spacer(modifier = Modifier.height(8.dp))

                        // Días de la semana
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.SpaceEvenly
                        ) {
                            listOf("L", "M", "X", "J", "V", "S", "D").forEach { dia ->
                                Text(
                                    text = dia,
                                    style = MaterialTheme.typography.bodySmall,
                                    fontWeight = FontWeight.Bold,
                                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f),
                                    modifier = Modifier.weight(1f),
                                    textAlign = TextAlign.Center
                                )
                            }
                        }

                        Spacer(modifier = Modifier.height(8.dp))

                        // Grid del calendario
                        CalendarioGrid(
                            ano = calendarioState.ano,
                            mes = calendarioState.mes,
                            mercadillosPorDia = mercadillosPorDia,
                            onDiaClick = { dia ->
                                val mercadillosDelDia = mercadillosPorDia[dia] ?: emptyList()
                                manejarClickDiaCalendario(mercadillosDelDia)
                            }
                        )
                    }
                }

                // ========== CARD PRÓXIMO MERCADILLO ==========

                    CardMercadillosProximos(
                        mercadillosProximos = mercadillosProximos,
                        onMercadilloClick = { mercadillo ->
                            navController?.navigate("editar_mercadillo/${mercadillo.idMercadillo}")
                        }
                    )
                }

                // ========== ESTADO VACÍO ==========

                if (!tieneMercadillos) {
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(32.dp),
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.Center
                    ) {
                        Icon(
                            painter = painterResource(id = R.drawable.ic_store),
                            contentDescription = null,
                            modifier = Modifier.size(64.dp),
                            tint = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.4f)
                        )

                        Spacer(modifier = Modifier.height(16.dp))

                        Text(
                            text = "No hay mercadillos programados",
                            style = MaterialTheme.typography.titleMedium,
                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f),
                            textAlign = TextAlign.Center
                        )

                        Spacer(modifier = Modifier.height(8.dp))

                        Text(
                            text = "Pulsa el botón + para crear tu primer mercadillo",
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f),
                            textAlign = TextAlign.Center
                        )
                    }
                }

                // ========== FOOTER ==========
                FooterMarca()
            }
        }

        // ========== DIÁLOGO DE LEYENDA ==========
        if (mostrarLeyenda) {
            LeyendaColoresDialog(
                onDismiss = { mostrarLeyenda = false },
                currentLanguage = currentLanguage
            )
        }

        // ========== DIÁLOGO DE SELECCIÓN DE MERCADILLOS (EDICIÓN) ==========
        if (mostrarDialogoSeleccion) {
            DialogoSeleccionMercadillo(
                mercadillos = mercadillosParaSeleccionar,
                onMercadilloSeleccionado = { mercadillo ->
                    mostrarDialogoSeleccion = false
                    navController?.navigate("editar_mercadillo/${mercadillo.idMercadillo}")
                },
                onDismiss = {
                    mostrarDialogoSeleccion = false
                },
                currentLanguage = currentLanguage
            )
        }

        // ✅ DIÁLOGO DE SELECCIÓN DE MERCADILLO ACTIVO (OPERACIONES)
        if (mostrarDialogoSeleccionActivo) {
            DialogoSeleccionMercadilloActivo(
                mercadillosEnCurso = mercadillosEnCurso,
                onMercadilloSeleccionado = { mercadillo ->
                    mercadilloViewModel.seleccionarMercadilloActivo(mercadillo)
                    mostrarDialogoSeleccionActivo = false

                    // Ejecutar la acción pendiente
                    accionPendiente?.let { accion ->
                        when (accion) {
                            "ventas" -> navController?.navigate("ventas/${mercadillo.idMercadillo}")
                            "gastos" -> navController?.navigate("gastos/${mercadillo.idMercadillo}")
                            "resumen" -> navController?.navigate("resumen/${mercadillo.idMercadillo}")
                        }
                        accionPendiente = null
                    }
                },
                onDismiss = {
                    mostrarDialogoSeleccionActivo = false
                    accionPendiente = null
                },
                currentLanguage = currentLanguage
            )
        }
    }


@Composable
private fun CalendarioGrid(
    ano: Int,
    mes: Int,
    mercadillosPorDia: Map<Int, List<MercadilloEntity>>,
    onDiaClick: (Int) -> Unit
) {
    // Calcular días del mes y día de inicio
    val diasDelMes = when (mes) {
        1, 3, 5, 7, 8, 10, 12 -> 31
        4, 6, 9, 11 -> 30
        2 -> if (ano % 4 == 0 && (ano % 100 != 0 || ano % 400 == 0)) 29 else 28
        else -> 31
    }

    // Calcular primer día del mes (0=lunes, 6=domingo)
    val calendar = java.util.Calendar.getInstance().apply {
        set(ano, mes - 1, 1) // Calendar.MONTH es 0-based
    }
    val primerDiaSemana = (calendar.get(java.util.Calendar.DAY_OF_WEEK) + 5) % 7

    LazyVerticalGrid(
        columns = GridCells.Fixed(7),
        modifier = Modifier.fillMaxWidth(),
        verticalArrangement = Arrangement.spacedBy(4.dp),
        horizontalArrangement = Arrangement.spacedBy(4.dp)
    ) {
        // Espacios vacíos para alinear el primer día del mes
        items(primerDiaSemana) {
            Box(modifier = Modifier.size(40.dp))
        }

        // Días del mes
        items((1..diasDelMes).toList()) { dia ->
            DiaCalendario(
                dia = dia,
                mercadillos = mercadillosPorDia[dia] ?: emptyList(),
                onClick = { onDiaClick(dia) }
            )
        }
    }
}

@Composable
private fun DiaCalendario(
    dia: Int,
    mercadillos: List<MercadilloEntity>,
    onClick: () -> Unit
) {
    // Obtener estados de los mercadillos y ordenar por prioridad
    val estados = mercadillos.map { mercadillo ->
        EstadosMercadillo.Estado.fromCodigo(mercadillo.estado)
            ?: EstadosMercadillo.Estado.PROGRAMADO_PARCIAL
    }.sortedBy { EstadosMercadillo.obtenerPrioridad(it) }

    Box(
        modifier = Modifier
            .size(40.dp)
            .clickable { onClick() }
            .background(
                color = if (estados.size == 1) {
                    // Si hay 1 mercadillo: fondo del color del estado
                    EstadosMercadillo.obtenerColor(estados.first())
                } else {
                    // Si hay 0 o múltiples: fondo normal
                    MaterialTheme.colorScheme.surface
                },
                shape = RoundedCornerShape(8.dp)
            ),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            // Número del día
            Text(
                text = dia.toString(),
                style = MaterialTheme.typography.bodySmall,
                color = if (estados.size == 1) {
                    EstadosMercadillo.obtenerColorTexto(estados.first())
                } else {
                    MaterialTheme.colorScheme.onSurface
                },
                fontWeight = if (mercadillos.isNotEmpty()) FontWeight.Bold else FontWeight.Normal
            )

            // Puntitos si hay múltiples mercadillos
            if (estados.size > 1) {
                Row(
                    horizontalArrangement = Arrangement.spacedBy(3.dp),
                    modifier = Modifier.padding(top = 2.dp)
                ) {
                    estados.take(2).forEach { estado ->
                        Box(
                            modifier = Modifier
                                .size(6.dp)
                                .background(
                                    EstadosMercadillo.obtenerColor(estado),
                                    CircleShape
                                )
                        )
                    }
                }
            }
        }
    }
}

@Composable
private fun LeyendaColoresDialog(
    onDismiss: () -> Unit,
    currentLanguage: String
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        properties = DialogProperties(usePlatformDefaultWidth = false),
        title = {
            Text(
                text = StringResourceManager.getString("leyenda_estados", currentLanguage),
                style = MaterialTheme.typography.titleLarge,
                fontWeight = FontWeight.Bold
            )
        },
        text = {
            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                EstadosMercadillo.obtenerTodosLosEstados().forEach { estado ->
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        // Círculo de color
                        Box(
                            modifier = Modifier
                                .size(16.dp)
                                .background(
                                    EstadosMercadillo.obtenerColor(estado),
                                    CircleShape
                                )
                        )

                        Spacer(modifier = Modifier.width(12.dp))

                        // Icono
                        Text(
                            text = EstadosMercadillo.obtenerIcono(estado),
                            fontSize = 16.sp
                        )

                        Spacer(modifier = Modifier.width(8.dp))

                        // Descripción
                        Text(
                            text = estado.descripcion,
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.onSurface
                        )
                    }
                }
            }
        },
        confirmButton = {
            TextButton(onClick = onDismiss) {
                Text(StringResourceManager.getString("entendido", currentLanguage))
            }
        }
    )
}

@Composable
private fun DialogoSeleccionMercadillo(
    mercadillos: List<MercadilloEntity>,
    onMercadilloSeleccionado: (MercadilloEntity) -> Unit,
    onDismiss: () -> Unit,
    currentLanguage: String
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = {
            Text(
                text = "Seleccionar mercadillo",
                style = MaterialTheme.typography.titleLarge,
                fontWeight = FontWeight.Bold
            )
        },
        text = {
            LazyColumn(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                items(mercadillos) { mercadillo ->
                    Card(
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable { onMercadilloSeleccionado(mercadillo) },
                        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
                    ) {
                        Column(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(12.dp)
                        ) {
                            // Título con lugar
                            Text(
                                text = mercadillo.lugar,
                                style = MaterialTheme.typography.titleMedium,
                                fontWeight = FontWeight.Bold,
                                color = MaterialTheme.colorScheme.onSurface
                            )

                            Spacer(modifier = Modifier.height(4.dp))

                            // Organizador y horario
                            Text(
                                text = "${mercadillo.organizador} • ${mercadillo.horaInicio} - ${mercadillo.horaFin}",
                                style = MaterialTheme.typography.bodyMedium,
                                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                            )

                            Spacer(modifier = Modifier.height(4.dp))

                            // Estado
                            val estado = EstadosMercadillo.Estado.fromCodigo(mercadillo.estado)
                            if (estado != null) {
                                Row(verticalAlignment = Alignment.CenterVertically) {
                                    Text(
                                        text = EstadosMercadillo.obtenerIcono(estado),
                                        fontSize = 12.sp
                                    )
                                    Spacer(modifier = Modifier.width(4.dp))
                                    Text(
                                        text = estado.descripcion,
                                        style = MaterialTheme.typography.bodySmall,
                                        color = EstadosMercadillo.obtenerColor(estado)
                                    )
                                }
                            }
                        }
                    }
                }
            }
        },
        confirmButton = { },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancelar")
            }
        }
    )
}
// AGREGAR ESTOS COMPONENTES A PantallaMercadillos.kt
// (después de los composables existentes como DiaCalendario, LeyendaColoresDialog, etc.)

/**
 * ✅ NUEVO COMPONENTE: Card con lista de mercadillos próximos
 * Reemplaza el card de "Próximo Mercadillo" por una lista completa
 */
@Composable
fun CardMercadillosProximos(
    mercadillosProximos: List<MercadilloEntity>,
    onMercadilloClick: (MercadilloEntity) -> Unit
) {
    if (mercadillosProximos.isNotEmpty()) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp, vertical = 4.dp),
            elevation = CardDefaults.cardElevation(defaultElevation = 6.dp),
            colors = CardDefaults.cardColors(
                containerColor = MaterialTheme.colorScheme.primaryContainer
            ),
            shape = RoundedCornerShape(12.dp)
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            ) {
                // ✅ HEADER con título y badge de cantidad
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        text = "Próximos Mercadillos",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.onPrimaryContainer
                    )

                    // Badge con número total
                    Badge(
                        containerColor = MaterialTheme.colorScheme.primary
                    ) {
                        Text(
                            text = mercadillosProximos.size.toString(),
                            color = MaterialTheme.colorScheme.onPrimary,
                            style = MaterialTheme.typography.bodySmall
                        )
                    }
                }

                Spacer(modifier = Modifier.height(12.dp))

                // ✅ LISTA de mercadillos (máximo 3 visibles + indicador)
                mercadillosProximos.take(3).forEachIndexed { index, mercadillo ->
                    MercadilloProximoItem(
                        mercadillo = mercadillo,
                        onClick = { onMercadilloClick(mercadillo) }
                    )

                    // Divisor entre elementos (excepto el último)
                    if (index < mercadillosProximos.take(3).size - 1) {
                        Spacer(modifier = Modifier.height(8.dp))
                        HorizontalDivider(
                            color = MaterialTheme.colorScheme.onPrimaryContainer.copy(alpha = 0.2f),
                            thickness = 1.dp
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                    }
                }

                // ✅ INDICADOR si hay más mercadillos
                if (mercadillosProximos.size > 3) {
                    Spacer(modifier = Modifier.height(12.dp))

                    Card(
                        modifier = Modifier.fillMaxWidth(),
                        colors = CardDefaults.cardColors(
                            containerColor = MaterialTheme.colorScheme.primary.copy(alpha = 0.1f)
                        ),
                        shape = RoundedCornerShape(8.dp)
                    ) {
                        Text(
                            text = "+ ${mercadillosProximos.size - 3} mercadillos más",
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.primary,
                            fontWeight = FontWeight.Medium,
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(8.dp),
                            textAlign = TextAlign.Center
                        )
                    }
                }
            }
        }
    }
}

/**
 * ✅ COMPONENTE INDIVIDUAL: Item de mercadillo en la lista
 */
@Composable
private fun MercadilloProximoItem(
    mercadillo: MercadilloEntity,
    onClick: () -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onClick() }
            .padding(vertical = 4.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Column(modifier = Modifier.weight(1f)) {
            // ✅ FECHA Y HORA (línea principal)
            Row(verticalAlignment = Alignment.CenterVertically) {
                Text(text = "📅 ", fontSize = 14.sp)
                Text(
                    text = "${mercadillo.fecha} • ${mercadillo.horaInicio}",
                    style = MaterialTheme.typography.bodyMedium,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.onPrimaryContainer
                )
            }

            Spacer(modifier = Modifier.height(4.dp))

            // ✅ LUGAR (línea secundaria)
            Row(verticalAlignment = Alignment.CenterVertically) {
                Text(text = "📍 ", fontSize = 14.sp)
                Text(
                    text = mercadillo.lugar,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onPrimaryContainer,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
            }

            Spacer(modifier = Modifier.height(2.dp))

            // ✅ ORGANIZADOR (línea terciaria)
            Row(verticalAlignment = Alignment.CenterVertically) {
                Text(text = "👥 ", fontSize = 12.sp)
                Text(
                    text = mercadillo.organizador,
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onPrimaryContainer.copy(alpha = 0.8f),
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
            }

            // ✅ ESTADO (línea de estado)
            val estado = EstadosMercadillo.Estado.fromCodigo(mercadillo.estado)
            if (estado != null) {
                Spacer(modifier = Modifier.height(4.dp))
                Row(verticalAlignment = Alignment.CenterVertically) {
                    // Círculo de color pequeño
                    Box(
                        modifier = Modifier
                            .size(8.dp)
                            .background(
                                EstadosMercadillo.obtenerColor(estado),
                                CircleShape
                            )
                    )
                    Spacer(modifier = Modifier.width(6.dp))
                    Text(
                        text = estado.descripcion,
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onPrimaryContainer.copy(alpha = 0.7f),
                        fontSize = 11.sp
                    )
                }
            }

            // ✅ SALDO INICIAL (si existe)
            if (mercadillo.saldoInicial != null) {
                Spacer(modifier = Modifier.height(2.dp))
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Text(text = "💰 ", fontSize = 12.sp)
                    Text(
                        text = "€${String.format("%.2f", mercadillo.saldoInicial)}",
                        style = MaterialTheme.typography.bodySmall,
                        color = Color(0xFF4CAF50),
                        fontWeight = FontWeight.Medium,
                        fontSize = 11.sp
                    )
                }
            }
        }

        // ✅ INDICADOR VISUAL para editar
        Column(
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            IconButton(
                onClick = onClick,
                modifier = Modifier.size(32.dp)
            ) {
                Text(
                    text = "→",
                    fontSize = 18.sp,
                    color = MaterialTheme.colorScheme.onPrimaryContainer,
                    fontWeight = FontWeight.Bold
                )
            }
        }
    }
}

===== END
===== FILE: PantallaPerfil.kt
// app/src/main/java/es/nuskysoftware/marketsales/ui/pantallas/PantallaPerfil.kt
package es.nuskysoftware.marketsales.ui.pantallas

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.text.KeyboardActions
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Email
import androidx.compose.material.icons.filled.Lock
import androidx.compose.material.icons.filled.Person
import androidx.compose.material.icons.filled.Visibility
import androidx.compose.material.icons.filled.VisibilityOff
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.focus.FocusDirection
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalFocusManager
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.text.input.VisualTransformation
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import kotlinx.coroutines.launch
import android.util.Log
import es.nuskysoftware.marketsales.R
import es.nuskysoftware.marketsales.data.repository.AuthState
import es.nuskysoftware.marketsales.ui.viewmodel.AuthViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.AuthViewModelFactory
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.FooterMarca
import es.nuskysoftware.marketsales.utils.StringResourceManager

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PantallaPerfil(
    navController: NavController? = null
) {
    val context = LocalContext.current
    val focusManager = LocalFocusManager.current
    val scope = rememberCoroutineScope()

    // AuthViewModel para manejar actualizaciones
    val authViewModel: AuthViewModel = viewModel(factory = AuthViewModelFactory(context))
    val authState by authViewModel.authState.collectAsState()
    val currentUser by authViewModel.currentUser.collectAsState()

    // Estados de ConfigurationManager
    val currentLanguage by ConfigurationManager.idioma.collectAsState()
    val usuarioEmail by ConfigurationManager.usuarioEmail.collectAsState()
    val displayName by ConfigurationManager.displayName.collectAsState()

    // Estados locales del formulario
    var nombre by remember { mutableStateOf(displayName ?: "") }
    var email by remember { mutableStateOf(usuarioEmail ?: "") }
    var passwordActual by remember { mutableStateOf("") }
    var passwordNueva by remember { mutableStateOf("") }
    var confirmarPassword by remember { mutableStateOf("") }

    var isPasswordActualVisible by remember { mutableStateOf(false) }
    var isPasswordNuevaVisible by remember { mutableStateOf(false) }
    var isConfirmarPasswordVisible by remember { mutableStateOf(false) }

    var showError by remember { mutableStateOf(false) }
    var showSuccess by remember { mutableStateOf(false) }
    var errorMessage by remember { mutableStateOf("") }
    var successMessage by remember { mutableStateOf("") }

    // Estado de carga para botones individuales
    var isUpdatingInfo by remember { mutableStateOf(false) }
    var isUpdatingPassword by remember { mutableStateOf(false) }

    // Actualizar campos cuando cambie el usuario
    LaunchedEffect(currentUser, displayName, usuarioEmail) {
        nombre = displayName ?: ""
        email = usuarioEmail ?: ""
    }

    // ✅ NUEVO: Actualizar campos cuando se muestre el mensaje de éxito
    LaunchedEffect(showSuccess) {
        if (showSuccess) {
            kotlinx.coroutines.delay(300)
            val updatedDisplayName = ConfigurationManager.displayName.value
            val updatedEmail = ConfigurationManager.usuarioEmail.value

            Log.d("PantallaPerfil", "🔄 ConfigurationManager.displayName: $updatedDisplayName")
            Log.d("PantallaPerfil", "🔄 Campo nombre antes: $nombre")

            if (updatedDisplayName != null) {
                nombre = updatedDisplayName
            }
            if (updatedEmail != null) {
                email = updatedEmail
            }

            Log.d("PantallaPerfil", "🔄 Campo nombre después: $nombre")
        }
    }

    // Validaciones
    val isNombreValid = nombre.isNotBlank()
    val isEmailValid = email.contains("@") && email.contains(".")
    val isPasswordActualValid = passwordActual.isNotBlank()
    val isPasswordNuevaValid = passwordNueva.length >= 6
    val isConfirmarPasswordValid = passwordNueva == confirmarPassword
    val canUpdateBasicInfo = isNombreValid && isEmailValid
    val canUpdatePassword = isPasswordActualValid && isPasswordNuevaValid && isConfirmarPasswordValid

    // Manejar estados de AuthViewModel
    LaunchedEffect(authState) {
        when (authState) {
            is AuthState.Error -> {
                errorMessage = (authState as AuthState.Error).message
                showError = true
                showSuccess = false
                isUpdatingInfo = false
                isUpdatingPassword = false
            }
            is AuthState.Authenticated -> {
                isUpdatingInfo = false
                isUpdatingPassword = false
            }
            else -> { }
        }
    }

    LaunchedEffect(displayName) {
        Log.d("PantallaPerfil", "🔄 ConfigurationManager.displayName: $displayName")
        if (!displayName.isNullOrBlank()) {
            Log.d("PantallaPerfil", "🔄 Campo nombre antes: $nombre")
            nombre = displayName ?: ""  // ✅ Manejar el nullable
            Log.d("PantallaPerfil", "🔄 Campo nombre después: $nombre")
        }
    }
    LaunchedEffect(currentUser, displayName, usuarioEmail) {
        nombre = displayName ?: currentUser?.displayName ?: ""
        email = usuarioEmail ?: currentUser?.email ?: ""
        Log.d("PantallaPerfil", "🔄 Campos actualizados - nombre: $nombre, email: $email")
    }
    // Función para actualizar información básica
    fun updateBasicInfo() {
        scope.launch {
            isUpdatingInfo = true
            showError = false
            showSuccess = false

            try {
                val result = authViewModel.updateUserProfile(
                    displayName = nombre,
                    email = email
                )

                if (result) {
                    successMessage = StringResourceManager.getString("informacion_actualizada", currentLanguage)
                    showSuccess = true
                } else {
                    errorMessage = StringResourceManager.getString("error_actualizar_informacion", currentLanguage)
                    showError = true
                }
            } catch (e: Exception) {
                errorMessage = StringResourceManager.getString("error_generico", currentLanguage).replace("{0}", e.message ?: "")
                showError = true
            } finally {
                isUpdatingInfo = false
            }
        }
    }

    // Función para cambiar contraseña
    fun updatePassword() {
        scope.launch {
            isUpdatingPassword = true
            showError = false
            showSuccess = false

            try {
                val result = authViewModel.updatePassword(
                    currentPassword = passwordActual,
                    newPassword = passwordNueva
                )

                if (result) {
                    successMessage = StringResourceManager.getString("contrasena_actualizada", currentLanguage)
                    showSuccess = true
                    // Limpiar campos
                    passwordActual = ""
                    passwordNueva = ""
                    confirmarPassword = ""
                } else {
                    errorMessage = StringResourceManager.getString("error_cambiar_contrasena", currentLanguage)
                    showError = true
                }
            } catch (e: Exception) {
                errorMessage = StringResourceManager.getString("error_generico", currentLanguage).replace("{0}", e.message ?: "")
                showError = true
            } finally {
                isUpdatingPassword = false
            }
        }
    }

    // Auto-ocultar mensajes después de 5 segundos
    LaunchedEffect(showSuccess) {
        if (showSuccess) {
            kotlinx.coroutines.delay(5000)
            showSuccess = false
        }
    }

    LaunchedEffect(showError) {
        if (showError) {
            kotlinx.coroutines.delay(5000)
            showError = false
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        StringResourceManager.getString("perfil", currentLanguage),
                        fontWeight = FontWeight.Bold
                    )
                },
                navigationIcon = {
                    IconButton(onClick = { navController?.popBackStack() }) {
                        Icon(
                            painter = painterResource(id = R.drawable.ic_arrow_left),
                            contentDescription = StringResourceManager.getString("volver", currentLanguage)
                        )
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary,
                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary
                )
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            Column(
                modifier = Modifier
                    .weight(1f)
                    .fillMaxWidth()
                    .verticalScroll(rememberScrollState())
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                // Información de cuenta
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),
                    elevation = CardDefaults.cardElevation(4.dp)
                ) {
                    Column(modifier = Modifier.padding(16.dp)) {
                        Text(
                            text = StringResourceManager.getString("informacion_cuenta", currentLanguage),
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                        Text(
                            text = StringResourceManager.getString("modificar_informacion", currentLanguage),
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                        )
                    }
                }

                // Mensajes de estado (arriba para mejor visibilidad)
                if (showError && errorMessage.isNotEmpty()) {
                    Card(
                        modifier = Modifier.fillMaxWidth(),
                        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.errorContainer)
                    ) {
                        Row(
                            modifier = Modifier.padding(12.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(
                                text = errorMessage,
                                color = MaterialTheme.colorScheme.onErrorContainer,
                                style = MaterialTheme.typography.bodyMedium,
                                modifier = Modifier.weight(1f)
                            )
                            TextButton(onClick = { showError = false }) {
                                Text("✕", color = MaterialTheme.colorScheme.onErrorContainer)
                            }
                        }
                    }
                }

                if (showSuccess && successMessage.isNotEmpty()) {
                    Card(
                        modifier = Modifier.fillMaxWidth(),
                        colors = CardDefaults.cardColors(containerColor = Color(0xFF4CAF50).copy(alpha = 0.1f))
                    ) {
                        Row(
                            modifier = Modifier.padding(12.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(
                                text = successMessage,
                                color = Color(0xFF4CAF50),
                                style = MaterialTheme.typography.bodyMedium,
                                modifier = Modifier.weight(1f)
                            )
                            TextButton(onClick = { showSuccess = false }) {
                                Text("✕", color = Color(0xFF4CAF50))
                            }
                        }
                    }
                }

                // Formulario de información básica
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),
                    elevation = CardDefaults.cardElevation(4.dp)
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp),
                        verticalArrangement = Arrangement.spacedBy(16.dp)
                    ) {
                        Text(
                            text = StringResourceManager.getString("informacion_personal", currentLanguage),
                            style = MaterialTheme.typography.titleSmall,
                            fontWeight = FontWeight.Bold
                        )

                        // Nombre
                        OutlinedTextField(
                            value = nombre,
                            onValueChange = {
                                nombre = it
                                showError = false
                                showSuccess = false
                            },
                            label = { Text(StringResourceManager.getString("nombre_completo", currentLanguage)) },
                            leadingIcon = { Icon(Icons.Default.Person, contentDescription = null) },
                            modifier = Modifier.fillMaxWidth(),
                            keyboardOptions = KeyboardOptions(
                                keyboardType = KeyboardType.Text,
                                imeAction = ImeAction.Next
                            ),
                            keyboardActions = KeyboardActions(
                                onNext = { focusManager.moveFocus(FocusDirection.Down) }
                            ),
                            isError = nombre.isNotEmpty() && !isNombreValid,
                            supportingText = {
                                if (nombre.isNotEmpty() && !isNombreValid) {
                                    Text(
                                        text = StringResourceManager.getString("nombre_vacio", currentLanguage),
                                        color = MaterialTheme.colorScheme.error
                                    )
                                }
                            },
                            singleLine = true,
                            enabled = !isUpdatingInfo
                        )

                        // Email
                        OutlinedTextField(
                            value = email,
                            onValueChange = {
                                email = it
                                showError = false
                                showSuccess = false
                            },
                            label = { Text(StringResourceManager.getString("correo_electronico", currentLanguage)) },
                            leadingIcon = { Icon(Icons.Default.Email, contentDescription = null) },
                            modifier = Modifier.fillMaxWidth(),
                            keyboardOptions = KeyboardOptions(
                                keyboardType = KeyboardType.Email,
                                imeAction = ImeAction.Done
                            ),
                            keyboardActions = KeyboardActions(
                                onDone = { focusManager.clearFocus() }
                            ),
                            isError = email.isNotEmpty() && !isEmailValid,
                            supportingText = {
                                if (email.isNotEmpty() && !isEmailValid) {
                                    Text(
                                        text = StringResourceManager.getString("email_invalido", currentLanguage),
                                        color = MaterialTheme.colorScheme.error
                                    )
                                }
                            },
                            singleLine = true,
                            enabled = !isUpdatingInfo
                        )

                        // Botón actualizar información básica
                        Button(
                            onClick = { updateBasicInfo() },
                            modifier = Modifier.fillMaxWidth(),
                            enabled = canUpdateBasicInfo && !isUpdatingInfo && !isUpdatingPassword
                        ) {
                            if (isUpdatingInfo) {
                                CircularProgressIndicator(
                                    modifier = Modifier.size(20.dp),
                                    strokeWidth = 2.dp,
                                    color = MaterialTheme.colorScheme.onPrimary
                                )
                                Spacer(modifier = Modifier.width(8.dp))
                                Text(StringResourceManager.getString("actualizando", currentLanguage))
                            } else {
                                Text(StringResourceManager.getString("actualizar_informacion", currentLanguage))
                            }
                        }
                    }
                }

                // Formulario de cambio de contraseña
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),
                    elevation = CardDefaults.cardElevation(4.dp)
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp),
                        verticalArrangement = Arrangement.spacedBy(16.dp)
                    ) {
                        Text(
                            text = StringResourceManager.getString("cambiar_contrasena_titulo", currentLanguage),
                            style = MaterialTheme.typography.titleSmall,
                            fontWeight = FontWeight.Bold
                        )

                        Text(
                            text = StringResourceManager.getString("cambiar_contrasena_descripcion", currentLanguage),
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                        )

                        // Contraseña actual
                        OutlinedTextField(
                            value = passwordActual,
                            onValueChange = {
                                passwordActual = it
                                showError = false
                                showSuccess = false
                            },
                            label = { Text(StringResourceManager.getString("contrasena_actual", currentLanguage)) },
                            leadingIcon = { Icon(Icons.Default.Lock, contentDescription = null) },
                            trailingIcon = {
                                IconButton(onClick = { isPasswordActualVisible = !isPasswordActualVisible }) {
                                    Icon(
                                        imageVector = if (isPasswordActualVisible) Icons.Default.Visibility else Icons.Default.VisibilityOff,
                                        contentDescription = if (isPasswordActualVisible)
                                            StringResourceManager.getString("ocultar_contrasena", currentLanguage)
                                        else
                                            StringResourceManager.getString("mostrar_contrasena", currentLanguage)
                                    )
                                }
                            },
                            visualTransformation = if (isPasswordActualVisible) VisualTransformation.None else PasswordVisualTransformation(),
                            modifier = Modifier.fillMaxWidth(),
                            keyboardOptions = KeyboardOptions(
                                keyboardType = KeyboardType.Password,
                                imeAction = ImeAction.Next
                            ),
                            keyboardActions = KeyboardActions(
                                onNext = { focusManager.moveFocus(FocusDirection.Down) }
                            ),
                            isError = passwordActual.isNotEmpty() && !isPasswordActualValid,
                            supportingText = {
                                if (passwordActual.isNotEmpty() && !isPasswordActualValid) {
                                    Text(
                                        text = StringResourceManager.getString("contrasena_actual_requerida", currentLanguage),
                                        color = MaterialTheme.colorScheme.error
                                    )
                                }
                            },
                            singleLine = true,
                            enabled = !isUpdatingPassword
                        )

                        // Nueva contraseña
                        OutlinedTextField(
                            value = passwordNueva,
                            onValueChange = {
                                passwordNueva = it
                                showError = false
                                showSuccess = false
                            },
                            label = { Text(StringResourceManager.getString("nueva_contrasena", currentLanguage)) },
                            leadingIcon = { Icon(Icons.Default.Lock, contentDescription = null) },
                            trailingIcon = {
                                IconButton(onClick = { isPasswordNuevaVisible = !isPasswordNuevaVisible }) {
                                    Icon(
                                        imageVector = if (isPasswordNuevaVisible) Icons.Default.Visibility else Icons.Default.VisibilityOff,
                                        contentDescription = if (isPasswordNuevaVisible)
                                            StringResourceManager.getString("ocultar_contrasena", currentLanguage)
                                        else
                                            StringResourceManager.getString("mostrar_contrasena", currentLanguage)
                                    )
                                }
                            },
                            visualTransformation = if (isPasswordNuevaVisible) VisualTransformation.None else PasswordVisualTransformation(),
                            modifier = Modifier.fillMaxWidth(),
                            keyboardOptions = KeyboardOptions(
                                keyboardType = KeyboardType.Password,
                                imeAction = ImeAction.Next
                            ),
                            keyboardActions = KeyboardActions(
                                onNext = { focusManager.moveFocus(FocusDirection.Down) }
                            ),
                            isError = passwordNueva.isNotEmpty() && !isPasswordNuevaValid,
                            supportingText = {
                                if (passwordNueva.isNotEmpty() && !isPasswordNuevaValid) {
                                    Text(
                                        text = StringResourceManager.getString("contrasena_minimo_caracteres", currentLanguage),
                                        color = MaterialTheme.colorScheme.error
                                    )
                                }
                            },
                            singleLine = true,
                            enabled = !isUpdatingPassword
                        )

                        // Confirmar contraseña
                        OutlinedTextField(
                            value = confirmarPassword,
                            onValueChange = {
                                confirmarPassword = it
                                showError = false
                                showSuccess = false
                            },
                            label = { Text(StringResourceManager.getString("confirmar_nueva_contrasena", currentLanguage)) },
                            leadingIcon = { Icon(Icons.Default.Lock, contentDescription = null) },
                            trailingIcon = {
                                IconButton(onClick = { isConfirmarPasswordVisible = !isConfirmarPasswordVisible }) {
                                    Icon(
                                        imageVector = if (isConfirmarPasswordVisible) Icons.Default.Visibility else Icons.Default.VisibilityOff,
                                        contentDescription = if (isConfirmarPasswordVisible)
                                            StringResourceManager.getString("ocultar_contrasena", currentLanguage)
                                        else
                                            StringResourceManager.getString("mostrar_contrasena", currentLanguage)
                                    )
                                }
                            },
                            visualTransformation = if (isConfirmarPasswordVisible) VisualTransformation.None else PasswordVisualTransformation(),
                            modifier = Modifier.fillMaxWidth(),
                            keyboardOptions = KeyboardOptions(
                                keyboardType = KeyboardType.Password,
                                imeAction = ImeAction.Done
                            ),
                            keyboardActions = KeyboardActions(
                                onDone = { focusManager.clearFocus() }
                            ),
                            isError = confirmarPassword.isNotEmpty() && !isConfirmarPasswordValid,
                            supportingText = {
                                if (confirmarPassword.isNotEmpty() && !isConfirmarPasswordValid) {
                                    Text(
                                        text = StringResourceManager.getString("contrasenas_no_coinciden", currentLanguage),
                                        color = MaterialTheme.colorScheme.error
                                    )
                                }
                            },
                            singleLine = true,
                            enabled = !isUpdatingPassword
                        )

                        // Botón cambiar contraseña
                        Button(
                            onClick = { updatePassword() },
                            modifier = Modifier.fillMaxWidth(),
                            enabled = canUpdatePassword && !isUpdatingPassword && !isUpdatingInfo
                        ) {
                            if (isUpdatingPassword) {
                                CircularProgressIndicator(
                                    modifier = Modifier.size(20.dp),
                                    strokeWidth = 2.dp,
                                    color = MaterialTheme.colorScheme.onPrimary
                                )
                                Spacer(modifier = Modifier.width(8.dp))
                                Text(StringResourceManager.getString("cambiando", currentLanguage))
                            } else {
                                Text(StringResourceManager.getString("cambiar_contrasena_btn", currentLanguage))
                            }
                        }
                    }
                }
            }

            // Footer
            FooterMarca()
        }
    }
}
===== END
===== FILE: PantallaVentas.kt
// app/src/main/java/es/nuskysoftware/marketsales/ui/pantallas/PantallaVentas.kt

package es.nuskysoftware.marketsales.ui.pantallas

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import es.nuskysoftware.marketsales.data.local.entity.MercadilloEntity
import es.nuskysoftware.marketsales.data.repository.PestanaVenta
import es.nuskysoftware.marketsales.ui.composables.PestanaVentaManual
import es.nuskysoftware.marketsales.ui.viewmodel.VentasViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.VentasViewModelFactory

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PantallaVentas(
    navController: NavController,
    mercadilloActivo: MercadilloEntity
) {
    val context = LocalContext.current
    val ventasViewModel: VentasViewModel = viewModel(
        factory = VentasViewModelFactory(context)
    )

    val uiState by ventasViewModel.uiState.collectAsState()
    val snackbarHostState = remember { SnackbarHostState() }

    // Inicializar ViewModel con IDs del mercadillo
    LaunchedEffect(mercadilloActivo) {
        ventasViewModel.inicializar(
            mercadilloId = mercadilloActivo.idMercadillo,
            usuarioId = mercadilloActivo.userId
        )
    }

    // Manejar errores
    LaunchedEffect(uiState.error) {
        uiState.error?.let { error ->
            snackbarHostState.showSnackbar(error)
            ventasViewModel.limpiarError()
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        text = "Nueva Venta - ${mercadilloActivo.lugar}",
                        fontWeight = FontWeight.Bold
                    )
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary
                )
            )
        },
        snackbarHost = { SnackbarHost(snackbarHostState) }
    ) { paddingValues ->

        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {

            // ✅ TABS: Manual y Productos
            TabRow(
                selectedTabIndex = when (uiState.pestanaActiva) {
                    PestanaVenta.MANUAL -> 0
                    PestanaVenta.PRODUCTOS -> 1
                }
            ) {
                Tab(
                    selected = uiState.pestanaActiva == PestanaVenta.MANUAL,
                    onClick = { ventasViewModel.cambiarPestana(PestanaVenta.MANUAL) },
                    text = { Text("Venta Manual") }
                )

                // TODO DÍA 2: Verificar si es usuario Premium
                Tab(
                    selected = uiState.pestanaActiva == PestanaVenta.PRODUCTOS,
                    onClick = { ventasViewModel.cambiarPestana(PestanaVenta.PRODUCTOS) },
                    text = { Text("Productos") },
                    enabled = true // TODO: verificar esPremium en DÍA 2
                )
            }

            // ✅ CONTENIDO SEGÚN PESTAÑA ACTIVA (botones incluidos en cada pestaña)
            when (uiState.pestanaActiva) {
                PestanaVenta.MANUAL -> {
                    PestanaVentaManual(
                        ventasViewModel = ventasViewModel
                    )
                }
                PestanaVenta.PRODUCTOS -> {
                    // TODO DÍA 2: PestanaVentaProductos con sus propios botones
                    PlaceholderContent("Pestaña Productos - Próximamente...")
                }
            }
        }
    }
}

@Composable
private fun PlaceholderContent(texto: String) {
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Text(
            text = texto,
            style = MaterialTheme.typography.headlineSmall,
            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)
        )
    }
}


===== END
===== FILE: PantallaSplash.kt
// app/src/main/java/es/nuskysoftware/marketsales/ui/pantallas/PantallaSplash.kt

package es.nuskysoftware.marketsales.ui.pantallas

import androidx.compose.animation.core.*
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.scale
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import es.nuskysoftware.marketsales.R

@Composable
fun PantallaSplash() {
    // Animación de escala
    val infiniteTransition = rememberInfiniteTransition(label = "splash_animation")
    val scale by infiniteTransition.animateFloat(
        initialValue = 0.8f,
        targetValue = 1.2f,
        animationSpec = infiniteRepeatable(
            animation = tween(1000, easing = EaseInOutCubic),
            repeatMode = RepeatMode.Reverse
        ),
        label = "scale_animation"
    )

    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(
                brush = Brush.verticalGradient(
                    colors = listOf(
                        MaterialTheme.colorScheme.primary,
                        MaterialTheme.colorScheme.primaryContainer
                    )
                )
            ),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            // Logo animado
            Card(
                modifier = Modifier
                    .size(120.dp)
                    .scale(scale),
                shape = RoundedCornerShape(60.dp),
                elevation = CardDefaults.cardElevation(defaultElevation = 8.dp),
                colors = CardDefaults.cardColors(
                    containerColor = MaterialTheme.colorScheme.surface
                )
            ) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Image(
                        painter = painterResource(id = R.drawable.ic_store),
                        contentDescription = "Market Sales Logo",
                        modifier = Modifier.size(80.dp)
                    )
                }
            }

            Spacer(modifier = Modifier.height(24.dp))

            // Título
            Text(
                text = "Market Sales",
                fontSize = 32.sp,
                fontWeight = FontWeight.Bold,
                color = MaterialTheme.colorScheme.onPrimary
            )

            Spacer(modifier = Modifier.height(8.dp))

            // Subtítulo
            Text(
                text = "Gestión de Mercadillos",
                fontSize = 16.sp,
                color = MaterialTheme.colorScheme.onPrimary.copy(alpha = 0.8f)
            )

            Spacer(modifier = Modifier.height(48.dp))

            // Indicador de carga
            CircularProgressIndicator(
                modifier = Modifier.size(32.dp),
                color = MaterialTheme.colorScheme.onPrimary,
                strokeWidth = 3.dp
            )
        }
    }
}
===== END
===== FILE: ColorUtils.kt
// app/src/main/java/es/nuskysoftware/marketsales/utils/ColorUtils.kt

package es.nuskysoftware.marketsales.ui.theme

import androidx.compose.material3.ColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.staticCompositionLocalOf
import androidx.compose.ui.graphics.Color

// ================= COLORES PRINCIPALES - VERDE PASTEL =================

// ------------------- Tema Claro - Verde Pastel MÁS SUAVE -------------------
val PrimaryLight = Color(0xFF81C784)        // Verde pastel más suave
val OnPrimaryLight = Color(0xFFFFFFFF)      // Blanco sobre verde
val SecondaryLight = Color(0xFFA5D6A7)      // Verde pastel muy claro
val OnSecondaryLight = Color(0xFF2E7D32)    // Verde oscuro sobre verde pastel
val BackgroundLight = Color(0xFFF1F8E9)     // Verde muy claro de fondo
val OnBackgroundLight = Color(0xFF1B5E20)   // Verde muy oscuro para texto

// ------------------- Tema Oscuro - Verde Pastel MÁS SUAVE -------------------
val PrimaryDark = Color(0xFF66BB6A)         // Verde pastel medio para oscuro
val OnPrimaryDark = Color(0xFF1B5E20)       // Verde muy oscuro sobre verde pastel
val SecondaryDark = Color(0xFF81C784)       // Verde pastel más claro
val OnSecondaryDark = Color(0xFF2E7D32)     // Verde oscuro sobre verde pastel
val BackgroundDark = Color(0xFF1B5E20)      // Verde muy oscuro de fondo
val OnBackgroundDark = Color(0xFFC8E6C9)    // Verde claro para texto

// ================= COLORES EXTENDIDOS PERSONALIZADOS =================

// ------------------- Extendidos Claro -------------------
val SuccessLight = Color(0xFF4CAF50)        // Verde éxito
val OnSuccessLight = Color(0xFFFFFFFF)      // Blanco sobre verde
val WarningLight = Color(0xFFFF9800)        // Naranja advertencia
val OnWarningLight = Color(0xFFFFFFFF)      // Blanco sobre naranja
val ErrorLight = Color(0xFFF44336)          // Rojo error
val OnErrorLight = Color(0xFFFFFFFF)        // Blanco sobre rojo
val InfoLight = Color(0xFF4CAF50)           // Verde información (en vez de azul)
val OnInfoLight = Color(0xFFFFFFFF)         // Blanco sobre verde info

val SurfaceLight = Color(0xFFFFFFFF)        // Superficie blanca
val OnSurfaceLight = Color(0xFF2E7D32)      // Verde oscuro sobre superficie
val SurfaceVariantLight = Color(0xFFC8E6C9) // Superficie variante verde claro
val OnSurfaceVariantLight = Color(0xFF1B5E20) // Verde muy oscuro sobre superficie variante

// ------------------- Extendidos Oscuro -------------------
val SuccessDark = Color(0xFF388E3C)         // Verde éxito oscuro
val OnSuccessDark = Color(0xFFFFFFFF)       // Blanco sobre verde oscuro
val WarningDark = Color(0xFFF57C00)         // Naranja advertencia oscuro
val OnWarningDark = Color(0xFFFFFFFF)       // Blanco sobre naranja oscuro
val ErrorDark = Color(0xFFD32F2F)           // Rojo error oscuro
val OnErrorDark = Color(0xFFFFFFFF)         // Blanco sobre rojo oscuro
val InfoDark = Color(0xFF388E3C)            // Verde información oscuro
val OnInfoDark = Color(0xFFFFFFFF)          // Blanco sobre verde info oscuro

val SurfaceDark = Color(0xFF2E7D32)         // Superficie verde oscuro
val OnSurfaceDark = Color(0xFFA5D6A7)       // Verde claro sobre superficie oscura
val SurfaceVariantDark = Color(0xFF1B5E20)  // Superficie variante verde muy oscuro
val OnSurfaceVariantDark = Color(0xFF81C784) // Verde pastel sobre superficie variante

// ================= CLASE PARA COLORES EXTENDIDOS =================

data class ExtendedColors(
    val success: Color,
    val onSuccess: Color,
    val warning: Color,
    val onWarning: Color,
    val error: Color,
    val onError: Color,
    val info: Color,
    val onInfo: Color,
    val surface: Color,
    val onSurface: Color,
    val surfaceVariant: Color,
    val onSurfaceVariant: Color
)

// ------------------- Instancias de colores extendidos -------------------
val LightExtendedColors = ExtendedColors(
    success = SuccessLight,
    onSuccess = OnSuccessLight,
    warning = WarningLight,
    onWarning = OnWarningLight,
    error = ErrorLight,
    onError = OnErrorLight,
    info = InfoLight,
    onInfo = OnInfoLight,
    surface = SurfaceLight,
    onSurface = OnSurfaceLight,
    surfaceVariant = SurfaceVariantLight,
    onSurfaceVariant = OnSurfaceVariantLight
)

val DarkExtendedColors = ExtendedColors(
    success = SuccessDark,
    onSuccess = OnSuccessDark,
    warning = WarningDark,
    onWarning = OnWarningDark,
    error = ErrorDark,
    onError = OnErrorDark,
    info = InfoDark,
    onInfo = OnInfoDark,
    surface = SurfaceDark,
    onSurface = OnSurfaceDark,
    surfaceVariant = SurfaceVariantDark,
    onSurfaceVariant = OnSurfaceVariantDark
)

// ================= COMPOSITION LOCAL PARA ACCESO GLOBAL =================

val LocalExtendedColors = staticCompositionLocalOf {
    LightExtendedColors
}

// ================= EXTENSIÓN PARA ACCESO FÁCIL =================

val ColorScheme.extended: ExtendedColors
    @Composable
    get() = LocalExtendedColors.current

// ================= COLORES ADICIONALES VERDE PASTEL =================

// Colores específicos de la aplicación
val PrimaryGreen = Color(0xFF4CAF50)
val SecondaryGreenLight = Color(0xFF81C784)
val AccentGreenPastel = Color(0xFFA5D6A7)
val WarningOrange = Color(0xFFFF9800)

// Verdes para fondos y bordes
val Green50 = Color(0xFFF1F8E9)
val Green100 = Color(0xFFC8E6C9)
val Green200 = Color(0xFFA5D6A7)
val Green300 = Color(0xFF81C784)
val Green400 = Color(0xFF66BB6A)
val Green500 = Color(0xFF4CAF50)
val Green600 = Color(0xFF43A047)
val Green700 = Color(0xFF388E3C)
val Green800 = Color(0xFF2E7D32)
val Green900 = Color(0xFF1B5E20)

// Colores verde pastel suave para Market Sales
val VerdePrimario = Color(0xFF90EE90)      // Verde claro pastel
val VerdeSecundario = Color(0xFF98FB98)     // Verde pálido
val VerdeTerciario = Color(0xFFAFEEAF)      // Verde muy claro

// Colores de fondo y superficie
val FondoClaro = Color(0xFFF5F5F5)          // Gris muy claro
val BlancoTexto = Color(0xFFFFFFFF)         // Blanco puro
val NegroTexto = Color(0xFF000000)          // Negro puro
val GrisOscuro = Color(0xFF424242)          // Gris oscuro para modo oscuro

// Colores adicionales
val GrisClaro = Color(0xFFE0E0E0)           // Gris claro para bordes
val AzulAccento = Color(0xFF2196F3)         // Azul para enlaces
val RojoError = Color(0xFFF44336)           // Rojo para errores
val VerdeExito = Color(0xFF4CAF50)          // Verde para éxito
===== END
===== FILE: ConfigurationManager.kt
// app/src/main/java/es/nuskysoftware/marketsales/utils/ConfigurationManager.kt
package es.nuskysoftware.marketsales.utils

import android.content.ContentValues.TAG
import android.util.Log
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow

/**
 * ✅ COMPLETO V10 - ConfigurationManager con TODOS los métodos necesarios
 */
object ConfigurationManager {

    // ========== ESTADOS V10 ==========
    private val _idioma = MutableStateFlow("es")
    private val _fuente = MutableStateFlow("Montserrat")
    private val _temaOscuro = MutableStateFlow(false)
    private val _moneda = MutableStateFlow("€ Euro")
    private val _usuarioLogueado = MutableStateFlow<String?>("usuario_default")
    // O si quieres que el valor inicial cuando nadie está logueado sea null:
    // private val _usuarioLogueado = MutableStateFlow<String?>(null)
    private val _usuarioEmail = MutableStateFlow<String?>(null)
    private val _displayName = MutableStateFlow<String?>(null)
    private val _versionApp = MutableStateFlow(0) // Para compatibilidad

    private val _isAuthenticated = MutableStateFlow(false)

    private var lastSuccessfulPremiumState: Boolean? = null

    private var lastUpdateTimestamp = 0L


    // ========== ESTADOS PÚBLICOS ==========
    val idioma: StateFlow<String> = _idioma.asStateFlow()
    val fuente: StateFlow<String> = _fuente.asStateFlow()
    val temaOscuro: StateFlow<Boolean> = _temaOscuro.asStateFlow()
    val moneda: StateFlow<String> = _moneda.asStateFlow()
    val usuarioEmail: StateFlow<String?> = _usuarioEmail.asStateFlow()
    val versionApp: StateFlow<Int> = _versionApp.asStateFlow()

    val isAuthenticated: StateFlow<Boolean> = _isAuthenticated.asStateFlow()
    val displayName: StateFlow<String?> = _displayName.asStateFlow()
    val usuarioLogueado: StateFlow<String?> = _usuarioLogueado.asStateFlow()

    private val _esPremium = MutableStateFlow(false)
    val esPremium: StateFlow<Boolean> = _esPremium.asStateFlow()

    /**
     * Toggle Premium para desarrollo - SIMPLIFICADO SIN PROTECCIONES
     */
    fun togglePremiumForDevelopment() {
        val newValue = !_esPremium.value

        Log.d("ConfigurationManager", "🔧 TOGGLE PREMIUM (Development):")
        Log.d("ConfigurationManager", "   - Antes: ${_esPremium.value}")
        Log.d("ConfigurationManager", "   - Después: $newValue")

        // Cambio directo sin protecciones para desarrollo
        _esPremium.value = newValue
        _versionApp.value = if (newValue) 1 else 0

        Log.d("ConfigurationManager", "✅ Premium toggled exitosamente")
    }

    /**
     * Establece estado premium directamente (para desarrollo)
     */
    fun setPremiumForDevelopment(isPremium: Boolean) {
        Log.d("ConfigurationManager", "🔧 SET PREMIUM (Development): ${_esPremium.value} → $isPremium")

        _esPremium.value = isPremium
        _versionApp.value = if (isPremium) 1 else 0

        Log.d("ConfigurationManager", "✅ Premium establecido: $isPremium")
    }

    // ========== MÉTODOS PRINCIPALES ==========
    fun updateUserConfigurationProtected(
        displayName: String? = null,
        usuarioEmail: String? = null,
        planUsuario: String = "FREE",
        isAuthenticated: Boolean = false,
        source: String = "unknown"
    ) {
        val currentTime = System.currentTimeMillis()

        // ✅ PROTECCIÓN: Si el displayName cambió hace menos de 5 segundos, no sobrescribir
        if (displayName != null && _displayName.value != displayName) {
            if (currentTime - lastUpdateTimestamp < 5000) {
                Log.w("ConfigurationManager", "🚫 PROTECCIÓN: Evitando sobrescribir displayName reciente")
                Log.w("ConfigurationManager", "   - Valor actual: ${_displayName.value}")
                Log.w("ConfigurationManager", "   - Valor que se quiere poner: $displayName")
                Log.w("ConfigurationManager", "   - Tiempo desde último cambio: ${currentTime - lastUpdateTimestamp}ms")
                return
            }
        }

        // Actualizar timestamp si hay cambio de displayName
        if (displayName != null && _displayName.value != displayName) {
            lastUpdateTimestamp = currentTime
            Log.d("ConfigurationManager", "🕒 Actualizando timestamp de protección")
        }

        // Llamar al método normal
        updateUserConfiguration(
            displayName = displayName,
            usuarioEmail = usuarioEmail,
            planUsuario = planUsuario,
            isAuthenticated = isAuthenticated
        )
    }
    /**
     * Obtiene el ID del usuario actual
     */
    fun getCurrentUserId(): String? {
        return _usuarioLogueado.value
    }

    // ========== MÉTODOS GET ==========
    fun getIdioma(): String = _idioma.value
    fun getFuente(): String = _fuente.value
    fun getModoOscuro(): Boolean = _temaOscuro.value
    fun getTemaOscuro(): Boolean = _temaOscuro.value
    fun getMoneda(): String = _moneda.value
    fun getUsuarioEmail(): String? = _usuarioEmail.value
    fun getUsuarioId(): String? = _usuarioLogueado.value.takeIf { it != "usuario_default" }
    fun getVersionApp(): Int = _versionApp.value
    fun getIsPremium(): Boolean = _esPremium.value

    // ========== MÉTODOS DE AUTENTICACIÓN ==========

    /**
     * Login de usuario
     */
    fun login(userId: String, email: String?, displayName: String? = null, isPremium: Boolean = false) {
        _usuarioLogueado.value = userId
        _usuarioEmail.value = email
        _displayName.value = displayName
       //_esPremium.value = isPremium
        setEsPremiumProtected(isPremium, "updateUserConfiguration")

        _versionApp.value = if (isPremium) 1 else 0
        _isAuthenticated.value = true
    }


    private fun setEsPremiumProtected(newValue: Boolean, source: String = "unknown") {
        val oldValue = _esPremium.value

        Log.d("ConfigurationManager", "🔄 INTENTO CAMBIO esPremium: $oldValue → $newValue")
        Log.d("ConfigurationManager", "   - Fuente: $source")
        Log.d("ConfigurationManager", "   - lastSuccessfulPremiumState: $lastSuccessfulPremiumState")
        Log.d("ConfigurationManager", "   - isAuthenticated: ${_isAuthenticated.value}")

        // 🛡️ PROTECCIÓN MEJORADA: Solo bloquear si usuario está autenticado
        if (oldValue == true && newValue == false && _isAuthenticated.value == true) {
            Log.e("ConfigurationManager", "🚨 BLOQUEANDO CAMBIO - Usuario autenticado premium")
            Thread.currentThread().stackTrace.take(15).forEach { frame ->
                Log.e("ConfigurationManager", "     at ${frame.className}.${frame.methodName}(${frame.fileName}:${frame.lineNumber})")
            }
            return
        }

        // ✅ PERMITIR logout cuando isAuthenticated = false
        if (oldValue == true && newValue == false && _isAuthenticated.value == false) {
            Log.w("ConfigurationManager", "✅ PERMITIENDO logout - Usuario no autenticado")
        }

        _esPremium.value = newValue
        Log.d("ConfigurationManager", "✅ esPremium cambiado: $oldValue → $newValue (fuente: $source)")
    }
    /**
     * Logout de usuario
     */

    fun logout() {
        Log.d("ConfigurationManager", "🚪 logout() llamado!")
        Log.d("ConfigurationManager", "   - esPremium antes: ${_esPremium.value}")
        Log.d("ConfigurationManager", "   - STACK TRACE:")
        Thread.currentThread().stackTrace.take(8).forEach { frame ->
            Log.d("ConfigurationManager", "     at ${frame.className}.${frame.methodName}(${frame.fileName}:${frame.lineNumber})")
        }

        // 🔓 Limpiar estado de protección en logout real
        lastSuccessfulPremiumState = null
        Log.d("ConfigurationManager", "   - Protección premium limpiada")

        // 🔄 Llamar a reset después de limpiar protección
        resetToDefaults()

        Log.d("ConfigurationManager", "   - esPremium después: ${_esPremium.value}")
        Log.d("ConfigurationManager", "   - ✅ Logout completado")
    }
    // ========== MÉTODOS DE CONFIGURACIÓN ==========

    /**
     * Verifica si el usuario puede cambiar configuración
     */
    fun canChangeConfiguration(): Boolean {
        return _esPremium.value
    }

    /**
     * Actualiza configuración global
     */
    fun updateGlobalConfiguration(
        idioma: String,
        fuente: String,
        temaOscuro: Boolean,
        moneda: String
    ) {
        _idioma.value = idioma
        _fuente.value = fuente
        _temaOscuro.value = temaOscuro
        _moneda.value = moneda
    }

    /**
     * Actualiza premium del usuario
     */
    fun updateUserPremium(isPremium: Boolean) {
        setEsPremiumProtected(isPremium, "updateUserConfiguration")
        _versionApp.value = if (isPremium) 1 else 0
    }

    // ========== MÉTODOS UPDATE EXISTENTES ==========
    fun updateConfiguration(
        idioma: String,
        fuente: String,
        modoOscuro: Boolean,
        isPremium: Boolean
    ) {
        _idioma.value = idioma
        _fuente.value = fuente
        _temaOscuro.value = modoOscuro
        setEsPremiumProtected(isPremium, "updateUserConfiguration")
        _versionApp.value = if (isPremium) 1 else 0
    }

    // Añade estos logs TEMPORALES en ConfigurationManager.kt en estos métodos:

    fun updateUserConfiguration(
        idioma: String = _idioma.value,
        fuente: String = _fuente.value,
        temaOscuro: Boolean = _temaOscuro.value,
        usuarioEmail: String? = _usuarioEmail.value,
        usuarioId: String? = null,
        planUsuario: String = "FREE",
        empresaId: String? = null,
        tipoUsuario: String? = null,
        displayName: String? = null,
        photoUrl: String? = null,
        isAuthenticated: Boolean = false,
        moneda: String = _moneda.value ,


        ) {
        // 🔍 LOG TEMPORAL
        Log.d("ConfigurationManager", "🔧 updateUserConfiguration llamado:")
        Log.d("ConfigurationManager", "   - planUsuario: $planUsuario")
        Log.d("ConfigurationManager", "   - isAuthenticated: $isAuthenticated")
        Log.d("ConfigurationManager", "   - esPremium antes: ${_esPremium.value}")

        Log.d("ConfigurationManager", "🔧 updateUserConfiguration - displayName recibido: $displayName")
        Log.d("ConfigurationManager", "🔧 _displayName.value antes: ${_displayName.value}")

        Log.d("ConfigurationManager", "🔧 FINAL updateUserConfiguration:")
        Log.d("ConfigurationManager", "   - displayName: ${_displayName.value}")
        Log.d("ConfigurationManager", "   - isAuthenticated: ${_isAuthenticated.value}")
        Log.d("ConfigurationManager", "   - esPremium: ${_esPremium.value}")


        // Actualizar valores de configuración
        _idioma.value = idioma
        _fuente.value = fuente
        _temaOscuro.value = temaOscuro
        _usuarioEmail.value = usuarioEmail
        _displayName.value = displayName
        _moneda.value = moneda
        _isAuthenticated.value = isAuthenticated

        // Calcular estado premium
        val isPremium = planUsuario == "PREMIUM" && isAuthenticated
        setEsPremiumProtected(isPremium, "updateUserConfiguration")
        _versionApp.value = if (isPremium) 1 else 0

        // Configurar usuario
        _usuarioLogueado.value = if (isAuthenticated && usuarioId != null) {
            usuarioId
        } else {
            "usuario_default"
        }

        // 💾 Guardar último estado premium válido para protección
        if (isPremium) {
            lastSuccessfulPremiumState = true
            Log.d("ConfigurationManager", "   - esPremium después: ${_esPremium.value}")
        }
        if (displayName != null) {
            _displayName.value = displayName
        }

        Log.d("ConfigurationManager", "🔧 _displayName.value después: ${_displayName.value}")

        // ... resto del código ...


        // 🔍 LOG TEMPORAL
        Log.d("ConfigurationManager", "   - esPremium después: ${_esPremium.value}")
        Log.d("ConfigurationManager", "   - STACK TRACE:")
        Thread.currentThread().stackTrace.take(8).forEach { frame ->
            Log.d("ConfigurationManager", "     at ${frame.className}.${frame.methodName}(${frame.fileName}:${frame.lineNumber})")
        }
    }

    fun forceUpdateDisplayName(newDisplayName: String) {
        Log.d(TAG, "🔧 forceUpdateDisplayName: ${_displayName.value} → $newDisplayName")
        _displayName.value = newDisplayName
        Log.d(TAG, "🔧 forceUpdateDisplayName DESPUÉS: ${_displayName.value}")
    }


    // ========== MÉTODOS SET ==========
    fun setIdioma(idioma: String) {
        _idioma.value = idioma
    }

    fun setFuente(fuente: String) {
        _fuente.value = fuente
    }

    fun setTemaOscuro(temaOscuro: Boolean) {
        _temaOscuro.value = temaOscuro
    }

    fun setModoOscuro(modoOscuro: Boolean) {
        _temaOscuro.value = modoOscuro
    }

    fun setUsuarioEmail(email: String?) {
        _usuarioEmail.value = email
    }

    fun setUsuarioLogueado(userId: String?) {
        _usuarioLogueado.value = userId ?: "usuario_default"
    }

    fun setUsuarioId(userId: String?) {
        setUsuarioLogueado(userId)
    }

    fun setMoneda(moneda: String) {
        _moneda.value = moneda
    }

    fun setIsPremium(isPremium: Boolean) {
        setEsPremiumProtected(isPremium, "updateUserConfiguration")
        _versionApp.value = if (isPremium) 1 else 0
    }

    fun setVersionApp(versionApp: Int) {
        _versionApp.value = versionApp
        setEsPremiumProtected(versionApp == 1, "setVersionApp")
    }


    fun resetToDefaults() {
        // 🔍 LOG TEMPORAL
        Log.d("ConfigurationManager", "🔄 resetToDefaults() llamado!")
        Log.d("ConfigurationManager", "   - esPremium antes: ${_esPremium.value}")
        Log.d("ConfigurationManager", "   - lastSuccessfulPremiumState: $lastSuccessfulPremiumState")
        Log.d("ConfigurationManager", "   - STACK TRACE:")
        Thread.currentThread().stackTrace.take(8).forEach { frame ->
            Log.d("ConfigurationManager", "     at ${frame.className}.${frame.methodName}(${frame.fileName}:${frame.lineNumber})")
        }

        // 🛡️ PROTECCIÓN: No resetear si hay un estado premium válido y el usuario está autenticado
        if (lastSuccessfulPremiumState == true && _isAuthenticated.value) {
            Log.w("ConfigurationManager", "🚫 EVITANDO RESET - Usuario premium autenticado detectado")
            return
        }

        // Resetear todos los valores a defaults
        _idioma.value = "es"
        _fuente.value = "Montserrat"
        _temaOscuro.value = false
        _moneda.value = "€ Euro"
        _usuarioLogueado.value = "usuario_default"
        _usuarioEmail.value = null
        _displayName.value = null
        setEsPremiumProtected(false, "resetToDefaults")
        _versionApp.value = 0
        _isAuthenticated.value = false

        // Limpiar estado de protección solo en logout real
        lastSuccessfulPremiumState = null

        Log.d("ConfigurationManager", "   - ✅ Reset completado")

        Log.d("ConfigurationManager", "   - esPremium después: ${_esPremium.value}")
        Log.d("ConfigurationManager", "   - ✅ Reset completado")
    }

    // ========== VERIFICACIONES ==========
    fun isUsuarioLogueado(): Boolean {
        return _usuarioLogueado.value != "usuario_default"
    }

    fun isPremium(): Boolean = _esPremium.value
    fun isFree(): Boolean = !_esPremium.value
}

===== END
===== FILE: ConnectivityObserver.kt
// app/src/main/java/es/nuskysoftware/marketsales/utils/ConnectivityObserver.kt
package es.nuskysoftware.marketsales.utils

import android.content.Context
import android.net.*
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow

/**
 * Observa el estado de la red (online/offline) usando ConnectivityManager
 * y expone un StateFlow<Boolean>.
 */
class ConnectivityObserver(context: Context) {

    private val cm = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
    private val _isConnected = MutableStateFlow(isCurrentlyConnected())
    val isConnected: StateFlow<Boolean> = _isConnected

    init {
        val request = NetworkRequest.Builder()
            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
            .build()

        cm.registerNetworkCallback(request, object : ConnectivityManager.NetworkCallback() {
            override fun onAvailable(network: Network) {
                _isConnected.value = true
            }
            override fun onLost(network: Network) {
                _isConnected.value = isCurrentlyConnected()
            }
        })
    }

    private fun isCurrentlyConnected(): Boolean {
        val n = cm.activeNetwork ?: return false
        val caps = cm.getNetworkCapabilities(n) ?: return false
        return caps.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
    }
}

===== END
===== FILE: EstadosMercadillo.kt
// app/src/main/java/es/nuskysoftware/marketsales/utils/EstadosMercadillo.kt
package es.nuskysoftware.marketsales.utils

import android.util.Log
import androidx.compose.ui.graphics.Color
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Locale

/**
 * EstadosMercadillo V11 - Market Sales
 *
 * ✅ Sistema centralizado para gestionar todos los estados de mercadillos
 * ✅ Incluye colores, descripciones y lógica relacionada
 * ✅ Estados automáticos basados en condiciones de negocio
 * ✅ Compatible con arquitectura híbrida "Reloj Suizo"
 */
object EstadosMercadillo {

    /**
     * Enum con todos los estados posibles de un mercadillo
     * Los códigos coinciden con el campo 'estado' en MercadilloEntity
     */
    enum class Estado(val codigo: Int, val descripcion: String) {
        PROGRAMADO_PARCIAL(1, "Programado parcialmente"),
        PROGRAMADO_TOTAL(2, "Programado totalmente"),
        EN_CURSO(3, "En curso"),
        PENDIENTE_ARQUEO(4, "Terminado (pendiente arqueo)"),
        PENDIENTE_ASIGNAR_SALDO(5, "Arqueo realizado (pendiente asignar saldo)"),
        CERRADO_COMPLETO(6, "Cerrado completamente"),
        CANCELADO(7, "Cancelado");

        companion object {
            /**
             * Obtiene el estado por su código
             */
            fun fromCodigo(codigo: Int): Estado? = values().find { it.codigo == codigo }

            /**
             * Obtiene el estado por defecto para nuevos mercadillos
             */
            fun getEstadoInicial(): Estado = PROGRAMADO_PARCIAL
        }
    }

    /**
     * Obtiene el color asociado a cada estado para la UI
     */
    fun obtenerColor(estado: Estado): Color {
        return when (estado) {
            Estado.PROGRAMADO_PARCIAL -> Color(0xFF81C7E8)      // Azul claro
            Estado.PROGRAMADO_TOTAL -> Color(0xFF1976D2)        // Azul oscuro
            Estado.EN_CURSO -> Color(0xFF4CAF50)                // Verde
            Estado.PENDIENTE_ARQUEO -> Color(0xFFFF9800)        // Naranja ⚠️
            Estado.PENDIENTE_ASIGNAR_SALDO -> Color(0xFFF44336) // Rojo ⚠️
            Estado.CERRADO_COMPLETO -> Color(0xFF2E7D32)        // Verde oscuro
            Estado.CANCELADO -> Color(0xFF757575)               // Gris
        }
    }

    /**
     * Obtiene el color de texto más apropiado para cada fondo
     */
    fun obtenerColorTexto(estado: Estado): Color {
        return when (estado) {
            Estado.PROGRAMADO_PARCIAL -> Color.Black
            Estado.PROGRAMADO_TOTAL -> Color.White
            Estado.EN_CURSO -> Color.White
            Estado.PENDIENTE_ARQUEO -> Color.Black
            Estado.PENDIENTE_ASIGNAR_SALDO -> Color.White
            Estado.CERRADO_COMPLETO -> Color.White
            Estado.CANCELADO -> Color.White
        }
    }

    /**
     * Devuelve todos los estados para mostrar en la leyenda
     */
    fun obtenerTodosLosEstados(): List<Estado> {
        return Estado.values().toList()
    }

    /**
     * Obtiene el icono/emoji representativo de cada estado
     */
    fun obtenerIcono(estado: Estado): String {
        return when (estado) {
            Estado.PROGRAMADO_PARCIAL -> "📋"
            Estado.PROGRAMADO_TOTAL -> "📅"
            Estado.EN_CURSO -> "🟢"
            Estado.PENDIENTE_ARQUEO -> "⚠️"
            Estado.PENDIENTE_ASIGNAR_SALDO -> "🔴"
            Estado.CERRADO_COMPLETO -> "✅"
            Estado.CANCELADO -> "❌"
        }
    }

    /**
     * Indica si el estado requiere atención urgente del usuario
     */
    fun requiereAtencion(estado: Estado): Boolean {
        return estado == Estado.PENDIENTE_ARQUEO || estado == Estado.PENDIENTE_ASIGNAR_SALDO
    }

    /**
     * Obtiene el orden de prioridad para mostrar en calendario cuando hay múltiples mercadillos
     * Menor número = mayor prioridad
     */
    fun obtenerPrioridad(estado: Estado): Int {
        return when (estado) {
            Estado.EN_CURSO -> 1                    // Máxima prioridad
            Estado.PENDIENTE_ARQUEO -> 2            // Urgente
            Estado.PENDIENTE_ASIGNAR_SALDO -> 3     // Urgente
            Estado.PROGRAMADO_TOTAL -> 4
            Estado.PROGRAMADO_PARCIAL -> 5
            Estado.CERRADO_COMPLETO -> 6
            Estado.CANCELADO -> 7                   // Mínima prioridad
        }
    }

    /**
     * Indica si un mercadillo puede ser cancelado
     * Solo se puede cancelar si no tiene ventas asociadas
     */
    fun puedeSerCancelado(estado: Estado, tieneVentas: Boolean): Boolean {
        return !tieneVentas && estado != Estado.CANCELADO && estado != Estado.CERRADO_COMPLETO
    }

    /**
     * Indica si se pueden asignar ventas a un mercadillo
     * Solo se pueden asignar ventas a mercadillos EN_CURSO
     */
    fun puedeRecibirVentas(estado: Estado): Boolean {
        return estado == Estado.EN_CURSO
    }

    /**
     * Calcula el estado automático basado en fecha, hora y datos del mercadillo
     */
    fun calcularEstadoAutomatico(
        saldoInicial: Double?,
        fecha: String,
        horaFin: String,
        arqueoCaja: Double?,
        pendienteAsignarSaldo: Boolean,
        fechaActual: String,
        horaActual: String
    ): Estado {
        try {
            val dateFormat = SimpleDateFormat("dd-MM-yyyy", Locale.getDefault())
            val timeFormat = SimpleDateFormat("HH:mm", Locale.getDefault())

            val fechaMercadillo = dateFormat.parse(fecha)
            val fechaHoy = dateFormat.parse(fechaActual)
            val horaFinMercadillo = timeFormat.parse(horaFin)
            val horaAhora = timeFormat.parse(horaActual)

            if (fechaMercadillo == null || fechaHoy == null || horaFinMercadillo == null || horaAhora == null) {
                return Estado.PROGRAMADO_PARCIAL
            }

            // Calcular ayer
            val calendar = Calendar.getInstance()
            calendar.time = fechaHoy
            calendar.add(Calendar.DAY_OF_MONTH, -1)
            val ayer = calendar.time

            // Si es anterior a ayer → mantener estado actual
            if (fechaMercadillo.before(ayer)) {
                return when {
                    arqueoCaja != null -> Estado.CERRADO_COMPLETO
                    pendienteAsignarSaldo -> Estado.PENDIENTE_ASIGNAR_SALDO
                    else -> if (saldoInicial != null) Estado.PROGRAMADO_TOTAL else Estado.PROGRAMADO_PARCIAL
                }
            }

            // Si es mañana o futuro → PROGRAMADO
            if (fechaMercadillo.after(fechaHoy)) {
                return if (saldoInicial != null) Estado.PROGRAMADO_TOTAL else Estado.PROGRAMADO_PARCIAL
            }

            // Si es HOY → ACTUAL
            if (fechaMercadillo.equals(fechaHoy)) {
                return Estado.EN_CURSO
            }

            // Si es AYER y son menos de las 5:00am → ACTUAL (mercadillos nocturnos)
            calendar.time = fechaHoy
            calendar.set(Calendar.HOUR_OF_DAY, 5)
            calendar.set(Calendar.MINUTE, 0)
            calendar.set(Calendar.SECOND, 0)
            val cincoAM = timeFormat.format(calendar.time)
            val cincoAMTime = timeFormat.parse(cincoAM)

            if (fechaMercadillo.equals(ayer) && horaAhora != null && cincoAMTime != null && horaAhora.before(cincoAMTime)) {
                return Estado.EN_CURSO
            }

            // Si es AYER y son las 5:00am o más tarde → PENDIENTE_ARQUEO
            if (fechaMercadillo.equals(ayer)) {
                return when {
                    arqueoCaja != null && pendienteAsignarSaldo -> Estado.PENDIENTE_ASIGNAR_SALDO
                    arqueoCaja != null -> Estado.CERRADO_COMPLETO
                    else -> Estado.PENDIENTE_ARQUEO
                }
            }

            // Por defecto
            return when {
                arqueoCaja != null && !pendienteAsignarSaldo -> Estado.CERRADO_COMPLETO
                arqueoCaja != null && pendienteAsignarSaldo -> Estado.PENDIENTE_ASIGNAR_SALDO
                else -> Estado.PENDIENTE_ARQUEO
            }

        } catch (e: Exception) {
            Log.e("EstadosMercadillo", "Error calculando estado automático", e)
            return if (saldoInicial != null) Estado.PROGRAMADO_TOTAL else Estado.PROGRAMADO_PARCIAL
        }
    }
}

===== END
===== FILE: FooterMarca.kt
// app/src/main/java/es/nuskysoftware/marketsales/utils/FooterMarca.kt
package es.nuskysoftware.marketsales.utils

import androidx.compose.foundation.layout.*
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp

@Composable
fun FooterMarca() {
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp)
            .windowInsetsPadding(WindowInsets.navigationBars) // ✅ Respeta barras de navegación
            .padding(vertical = 8.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(
            text = "© La Nusky Software",
            fontSize = 12.sp,
            fontWeight = FontWeight.Normal,
            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f),
            textAlign = TextAlign.Center
        )
    }
}
===== END
===== FILE: GoogleAuthHelper.kt
// app/src/main/java/es/nuskysoftware/marketsales/utils/GoogleAuthHelper.kt
package es.nuskysoftware.marketsales.utils

import android.content.Context
import com.google.android.gms.auth.api.signin.GoogleSignIn
import com.google.android.gms.auth.api.signin.GoogleSignInClient
import com.google.android.gms.auth.api.signin.GoogleSignInOptions
import es.nuskysoftware.marketsales.R

/**
 * Helper class para manejar Google Sign-In de forma centralizada
 * V8 - Google Auth implementation
 */
object GoogleAuthHelper {

    /**
     * Obtiene el cliente de Google Sign-In configurado
     */
    fun getGoogleSignInClient(context: Context): GoogleSignInClient {
        val webClientId = context.getString(R.string.web_client_id)

        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)
            .requestIdToken(webClientId)
            .requestEmail()
            .requestProfile()
            .build()

        return GoogleSignIn.getClient(context, gso)
    }

    /**
     * Verifica si hay un usuario ya logueado con Google
     */
    fun getLastSignedInAccount(context: Context) = GoogleSignIn.getLastSignedInAccount(context)

    /**
     * Cierra sesión de Google
     */
    fun signOut(context: Context, onComplete: () -> Unit = {}) {
        getGoogleSignInClient(context).signOut().addOnCompleteListener {
            onComplete()
        }
    }

    /**
     * Revoca el acceso de Google
     */
    fun revokeAccess(context: Context, onComplete: () -> Unit = {}) {
        getGoogleSignInClient(context).revokeAccess().addOnCompleteListener {
            onComplete()
        }
    }
}
===== END
===== FILE: StringResourceManager.kt
// app/src/main/java/es/nuskysoftware/marketsales/utils/StringResourceManager.kt

package es.nuskysoftware.marketsales.utils

import java.util.Locale

/**
 * Gestor de recursos de string que permite cambio dinámico de idioma
 * V11 - Con strings completos para PantallaPerfil + PantallaCategorias
 */
object StringResourceManager {

    fun getString(key: String, language: String = "es"): String {
        return when (language) {
            "en" -> getEnglishString(key)
            "es" -> getSpanishString(key)
            else -> getSpanishString(key)
        }
    }

    /**
     * Strings en español
     */
    private fun getSpanishString(key: String): String = when (key) {
        // Pantalla principal
        "app_name" -> "Market Sales"
        "mercadillos" -> "Mercadillos"
        "configuracion" -> "Configuración"
        "articulos" -> "Artículos"
        "categorias" -> "Categorías"
        "inventario" -> "Inventario"
        "listados" -> "Listados"
        "iniciar_sesion" -> "Iniciar Sesión"
        "cerrar_sesion" -> "Cerrar Sesión"
        "salir" -> "Salir"
        "perfil" -> "Perfil"

        // Configuración
        "informacion_cuenta" -> "Información de Cuenta"
        "cambiar_contrasena" -> "Cambiar Contraseña"
        "tema" -> "Tema"
        "fuente" -> "Fuente"
        "idioma" -> "Idioma"
        "moneda" -> "Moneda"
        "version_premium" -> "PREMIUM"
        "version_free" -> "FREE"
        "promocion_premium" -> "¡Actualiza a Premium!"
        "desbloquea_funciones" -> "Desbloquea todas las funciones"

        // Tema
        "tema_claro" -> "Claro"
        "tema_oscuro" -> "Oscuro"

        // Idiomas
        "espanol" -> "Español"
        "ingles" -> "English"

        // Fuentes
        "montserrat" -> "Montserrat"
        "poppins" -> "Poppins"
        "roboto" -> "Roboto"

        // Monedas
        "euro" -> "€ Euro"
        "dolar" -> "$ Dólar"
        "libra" -> "£ Libra"
        "yen" -> "¥ Yen"

        // ✅ PANTALLA PERFIL - STRINGS COMPLETOS
        "modificar_informacion" -> "Modifica tu información personal"
        "informacion_personal" -> "Información Personal"
        "nombre_completo" -> "Nombre completo"
        "correo_electronico" -> "Correo electrónico"
        "actualizar_informacion" -> "Actualizar Información"
        "actualizando" -> "Actualizando..."
        "cambiar_contrasena_titulo" -> "Cambiar Contraseña"
        "cambiar_contrasena_descripcion" -> "Deja en blanco si no quieres cambiar la contraseña"
        "contrasena_actual" -> "Contraseña actual"
        "nueva_contrasena" -> "Nueva contraseña"
        "confirmar_nueva_contrasena" -> "Confirmar nueva contraseña"
        "cambiando" -> "Cambiando..."
        "cambiar_contrasena_btn" -> "Cambiar Contraseña"

        // Validaciones
        "nombre_vacio" -> "El nombre no puede estar vacío"
        "email_invalido" -> "Email inválido"
        "contrasena_actual_requerida" -> "Contraseña actual requerida"
        "contrasena_minimo_caracteres" -> "La contraseña debe tener al menos 6 caracteres"
        "contrasenas_no_coinciden" -> "Las contraseñas no coinciden"

        // Mensajes de éxito/error
        "informacion_actualizada" -> "✅ Información actualizada correctamente"
        "contrasena_actualizada" -> "✅ Contraseña actualizada correctamente"
        "error_actualizar_informacion" -> "❌ Error al actualizar la información"
        "error_cambiar_contrasena" -> "❌ Error al cambiar la contraseña"
        "error_generico" -> "❌ Error: {0}"

        // Botones y acciones
        "volver" -> "Volver"
        "ocultar_contrasena" -> "Ocultar contraseña"
        "mostrar_contrasena" -> "Mostrar contraseña"

        // Diálogos
        "cambiar" -> "Cambiar"
        "cancelar" -> "Cancelar"
        "guardar" -> "Guardar"
        "aceptar" -> "Aceptar"
        "eliminar" -> "Eliminar"
        "contrasenas_no_coinciden_dialogo" -> "Las contraseñas no coinciden"
        "contrasena_muy_corta" -> "La contraseña debe tener al menos 6 caracteres"

        // Mensajes
        "funcion_premium" -> "Esta función está disponible solo en la versión Premium"
        "error_actualizacion" -> "Error al actualizar la configuración"

        // ✅ NUEVOS STRINGS PARA CATEGORÍAS
        "add_categoria" -> "Añadir categoría"
        "nueva_categoria" -> "Nueva Categoría"
        "editar_categoria" -> "Editar Categoría"
        "nombre" -> "Nombre"
        "seleccionar_color" -> "Seleccionar color"
        "pulsa_crear_primera_categoria" -> "Pulsa + para crear tu primera categoría"
        "eliminar_categoria" -> "Eliminar Categoría"
        "confirmar_eliminar_categoria" -> "¿Seguro que deseas eliminar \"{nombre}\"?"
        "categoria_creada" -> "Categoría creada exitosamente"
        "categoria_actualizada" -> "Categoría actualizada exitosamente"
        "categoria_eliminada" -> "Categoría eliminada exitosamente"
        "error_crear_categoria" -> "Error al crear la categoría"
        "error_actualizar_categoria" -> "Error al actualizar la categoría"
        "error_eliminar_categoria" -> "Error al eliminar la categoría"
        "nombre_categoria_requerido" -> "El nombre de la categoría es requerido"
        "nombre_categoria_muy_corto" -> "El nombre debe tener al menos 2 caracteres"
        "nombre_categoria_muy_largo" -> "El nombre no puede tener más de 50 caracteres"
        "categoria_nombre_duplicado" -> "Ya existe una categoría con ese nombre"
        "color_invalido" -> "Color inválido"
        "sincronizacion_completada" -> "Sincronización completada"
        "error_sincronizacion" -> "Error en sincronización"

        // Artículos - Pantalla principal
        "articulos" -> "Artículos"
        "add_articulo" -> "Añadir artículo"
        "nuevo_articulo" -> "Nuevo Artículo"
        "editar_articulo" -> "Editar Artículo"
        "pulsa_crear_primer_articulo" -> "Pulsa + para crear tu primer artículo"
        "eliminar_articulo" -> "Eliminar Artículo"
        "confirmar_eliminar_articulo" -> "¿Seguro que deseas eliminar \"{nombre}\"?"

        // Campos del formulario
        "precio_venta" -> "Precio de venta"
        "precio_coste" -> "Precio de coste"
        "stock" -> "Stock"
        "categoria" -> "Categoría"
        "seleccionar_categoria" -> "Seleccionar categoría"
        "sin_categorias" -> "No hay categorías disponibles"

        // Controles Premium
        "controlar_coste" -> "Controlar coste"
        "controlar_stock" -> "Controlar stock"
        "marcar_favorito" -> "Marcar como favorito"

        // Validaciones y mensajes
        "precio_venta_requerido" -> "El precio de venta es requerido"
        "precio_venta_invalido" -> "Precio de venta inválido"
        "categoria_requerida" -> "Selecciona una categoría"
        "articulo_creado" -> "Artículo creado exitosamente"
        "articulo_actualizado" -> "Artículo actualizado exitosamente"
        "articulo_eliminado" -> "Artículo eliminado exitosamente"
        "error_crear_articulo" -> "Error al crear el artículo"
        "error_actualizar_articulo" -> "Error al actualizar el artículo"
        "error_eliminar_articulo" -> "Error al eliminar el artículo"

        // Estados
        "sin_articulos" -> "No tienes artículos registrados"
        "cargando_articulos" -> "Cargando artículos..."
        "sincronizando_articulos" -> "Sincronizando artículos..."

        // Premium
        "solo_premium_stock" -> "Control de stock disponible solo en Premium"
        "solo_premium_coste" -> "Control de coste disponible solo en Premium"

        // ✅ AUTHENTICATION STRINGS PHASE 2
        "login_subtitle" -> "Inicia sesión en tu cuenta"
        "register_subtitle" -> "Crea tu nueva cuenta"
        "email" -> "Email"
        "email_placeholder" -> "tu@email.com"
        "email_invalid" -> "Email inválido"
        "password" -> "Contraseña"
        "password_placeholder" -> "Mínimo 6 caracteres"
        "password_invalid" -> "Mínimo 6 caracteres requeridos"
        "login_button" -> "Iniciar Sesión"
        "register_button" -> "Crear Cuenta"
        "loading" -> "Cargando..."
        "or" -> "o"
        "go_to_register" -> "¿No tienes cuenta? Crear cuenta"
        "go_to_login" -> "¿Ya tienes cuenta? Iniciar sesión"
        "register_benefits_title" -> "🚀 Beneficios de crear cuenta:"
        "benefit_1" -> "• Sincronización automática en todos tus dispositivos"
        "benefit_2" -> "• Configuración personalizada guardada"
        "benefit_3" -> "• Acceso a funciones Premium"
        "benefit_4" -> "• Respaldo seguro de tus datos"
        "welcome" -> "Bienvenido"
        "premium_user" -> "Usuario Premium"
        "free_user" -> "Usuario Gratuito"
        "not_authenticated" -> "No autenticado"
        "home" -> "Inicio"
        "markets" -> "Mercadillos"
        "add_market" -> "Añadir Mercadillo"
        "premium_features" -> "Funciones Premium"
        "upgrade_premium" -> "Actualizar a Premium"
        "about" -> "Acerca de"
        "logout" -> "Cerrar Sesión"
        "exit_app" -> "Salir de la App"
        "logout_title" -> "Cerrar Sesión"
        "logout_message" -> "¿Estás seguro de que deseas cerrar sesión?"
        "logout_confirm" -> "Cerrar Sesión"
        "exit_title" -> "Salir de la App"
        "exit_message" -> "¿Estás seguro de que deseas salir de Market Sales?"
        "exit_confirm" -> "Salir"
        "available_markets" -> "Mercadillos Disponibles"
        "premium_required" -> "Requiere Premium para acceso completo"
        "see_details" -> "Ver detalles"
        "edit" -> "Editar"
        "menu" -> "Menú"
        "premium" -> "Premium"
        "free" -> "Gratuito"

        // 🚀 GOOGLE AUTH V8 - NUEVOS STRINGS AGREGADOS
        "google_signin" -> "Continuar con Google"
        "google_register" -> "Registrarse con Google"
        "google_auth_error" -> "Error de autenticación con Google"
        "google_token_error" -> "Error obteniendo token de Google"
        "auth_provider_google" -> "Google"
        "auth_provider_email" -> "Email"
        "google_signin_success" -> "Autenticación con Google exitosa"
        "google_signin_failed" -> "Falló la autenticación con Google"

        // ✅ STRINGS PARA MERCADILLOS V11
        "add_mercadillo" -> "Añadir mercadillo"
        "nuevo_mercadillo" -> "Nuevo Mercadillo"
        "editar_mercadillo" -> "Editar Mercadillo"
        "ver_leyenda" -> "Ver leyenda"
        "leyenda_estados" -> "Leyenda de Estados"
        "entendido" -> "Entendido"
        "proximo_mercadillo" -> "Próximo Mercadillo"
        "sin_mercadillos" -> "No tienes mercadillos registrados"
        "pulsa_crear_primer_mercadillo" -> "Pulsa + para crear tu primer mercadillo"

        // Estados de mercadillos
        "estado_programado_parcial" -> "Programado parcialmente"
        "estado_programado_total" -> "Programado totalmente"
        "estado_en_curso" -> "En curso"
        "estado_pendiente_arqueo" -> "Terminado (pendiente arqueo)"
        "estado_pendiente_asignar_saldo" -> "Arqueo realizado (pendiente asignar saldo)"
        "estado_cerrado_completo" -> "Cerrado completamente"
        "estado_cancelado" -> "Cancelado"

        // Formulario de mercadillos
        "fecha_mercadillo" -> "Fecha del mercadillo"
        "lugar_mercadillo" -> "Lugar"
        "organizador_mercadillo" -> "Organizador"
        "hora_inicio" -> "Hora de inicio"
        "hora_fin" -> "Hora de fin"
        "es_gratis" -> "Es gratis"
        "importe_suscripcion" -> "Importe suscripción"
        "requiere_mesa" -> "Requiere mesa"
        "requiere_carpa" -> "Requiere carpa"
        "hay_punto_luz" -> "Hay punto de luz"

        // Validaciones mercadillos
        "fecha_requerida" -> "La fecha es requerida"
        "fecha_invalida" -> "Formato de fecha inválido (dd-MM-yyyy)"
        "lugar_requerido" -> "El lugar es requerido"
        "lugar_muy_corto" -> "El lugar debe tener al menos 3 caracteres"
        "lugar_muy_largo" -> "El lugar no puede tener más de 100 caracteres"
        "organizador_requerido" -> "El organizador es requerido"
        "organizador_muy_corto" -> "El organizador debe tener al menos 3 caracteres"
        "organizador_muy_largo" -> "El organizador no puede tener más de 100 caracteres"
        "hora_inicio_invalida" -> "Formato de hora de inicio inválido (HH:mm)"
        "hora_fin_invalida" -> "Formato de hora de fin inválido (HH:mm)"
        "horarios_invalidos" -> "La hora de inicio debe ser anterior a la hora de fin"
        "importe_negativo" -> "El importe no puede ser negativo"
        "importe_muy_alto" -> "El importe es demasiado alto"
        "mercadillo_existe_fecha_hora" -> "Ya existe un mercadillo en esa fecha y hora"

        // Mensajes mercadillos
        "mercadillo_creado" -> "Mercadillo creado exitosamente"
        "mercadillo_actualizado" -> "Mercadillo actualizado exitosamente"
        "mercadillo_eliminado" -> "Mercadillo eliminado exitosamente"
        "mercadillo_cancelado" -> "Mercadillo cancelado exitosamente"
        "error_crear_mercadillo" -> "Error creando mercadillo"
        "error_actualizar_mercadillo" -> "Error actualizando mercadillo"
        "error_eliminar_mercadillo" -> "Error eliminando mercadillo"
        "error_cancelar_mercadillo" -> "Error cancelando mercadillo"

        // Saldos y arqueos
        "saldo_inicial" -> "Saldo inicial"
        "saldo_final" -> "Saldo final"
        "asignar_saldo_inicial" -> "Asignar saldo inicial"
        "asignar_automaticamente" -> "Asignar automáticamente"
        "realizar_arqueo" -> "Realizar arqueo"
        "arqueo_caja" -> "Arqueo de caja"
        "saldo_asignado" -> "Saldo inicial asignado"
        "arqueo_realizado" -> "Arqueo de caja realizado exitosamente"
        "sin_saldo_anterior" -> "No hay mercadillos anteriores con saldo disponible"
        "saldo_negativo" -> "El saldo no puede ser negativo"
        "saldo_muy_alto" -> "El saldo es demasiado alto"

        // Confirmaciones
        "confirmar_eliminar_mercadillo" -> "¿Seguro que deseas eliminar este mercadillo?"
        "confirmar_cancelar_mercadillo" -> "¿Seguro que deseas cancelar este mercadillo?"
        "mercadillo_tiene_ventas" -> "No se puede cancelar: el mercadillo tiene ventas"
        "mercadillo_estado_no_valido" -> "No se puede cancelar: estado no válido"

        "informacion_basica" -> "Información Básica"
        "horarios" -> "Horarios"
        "configuracion_mercadillo" -> "Configuración"
        "crear_mercadillo" -> "Crear Mercadillo"
        "actualizar_mercadillo" -> "Actualizar Mercadillo"
        "guardando" -> "Guardando..."
        "saldo_inicial_ayuda" -> "Dinero disponible al inicio del mercadillo"
        "seleccionar_fecha" -> "Seleccionar fecha"
        "seleccionar_hora_inicio" -> "Seleccionar hora inicio"
        "seleccionar_hora_fin" -> "Seleccionar hora fin"

        // Validaciones específicas para el formulario
        "fecha_no_puede_estar_vacia" -> "La fecha no puede estar vacía"
        "lugar_no_puede_estar_vacio" -> "El lugar no puede estar vacío"
        "organizador_no_puede_estar_vacio" -> "El organizador no puede estar vacío"
        "formato_fecha_invalido" -> "Formato de fecha inválido (dd-MM-yyyy)"
        "formato_hora_inicio_invalido" -> "Formato de hora de inicio inválido (HH:mm)"
        "formato_hora_fin_invalido" -> "Formato de hora de fin inválido (HH:mm)"
        "hora_inicio_debe_ser_anterior" -> "La hora de inicio debe ser anterior a la hora de fin"
        "lugar_minimo_caracteres" -> "El lugar debe tener al menos 3 caracteres"
        "lugar_maximo_caracteres" -> "El lugar no puede tener más de 100 caracteres"
        "organizador_minimo_caracteres" -> "El organizador debe tener al menos 3 caracteres"
        "organizador_maximo_caracteres" -> "El organizador no puede tener más de 100 caracteres"
        "importe_no_puede_ser_negativo" -> "El importe no puede ser negativo"
        "importe_demasiado_alto" -> "El importe es demasiado alto"
        "saldo_inicial_no_puede_ser_negativo" -> "El saldo inicial no puede ser negativo"
        "saldo_inicial_demasiado_alto" -> "El saldo inicial es demasiado alto"

        "seleccionar_hora" -> "Seleccionar hora"
        "opcional" -> "(opcional)"
        "lunes" -> "L"
        "martes" -> "M"
        "miercoles" -> "X"
        "jueves" -> "J"
        "viernes" -> "V"
        "sabado" -> "S"
        "domingo" -> "D"

        else -> key
    }

    /**
     * Strings en inglés
     */
    private fun getEnglishString(key: String): String = when (key) {
        // Main screen
        "app_name" -> "Market Sales"
        "mercadillos" -> "Markets"
        "configuracion" -> "Settings"
        "articulos" -> "Articles"
        "categorias" -> "Categories"
        "inventario" -> "Inventory"
        "listados" -> "Reports"
        "iniciar_sesion" -> "Login"
        "cerrar_sesion" -> "Logout"
        "salir" -> "Exit"
        "perfil" -> "Profile"

        // Settings
        "informacion_cuenta" -> "Account Information"
        "cambiar_contrasena" -> "Change Password"
        "tema" -> "Theme"
        "fuente" -> "Font"
        "idioma" -> "Language"
        "moneda" -> "Currency"
        "version_premium" -> "PREMIUM"
        "version_free" -> "FREE"
        "promocion_premium" -> "Upgrade to Premium!"
        "desbloquea_funciones" -> "Unlock all features"

        // Theme
        "tema_claro" -> "Light"
        "tema_oscuro" -> "Dark"

        // Languages
        "espanol" -> "Español"
        "ingles" -> "English"

        // Fonts
        "montserrat" -> "Montserrat"
        "poppins" -> "Poppins"
        "roboto" -> "Roboto"

        // Currencies
        "euro" -> "€ Euro"
        "dolar" -> "$ Dollar"
        "libra" -> "£ Pound"
        "yen" -> "¥ Yen"

        // ✅ PROFILE SCREEN - COMPLETE STRINGS
        "modificar_informacion" -> "Change your personal information"
        "informacion_personal" -> "Personal Information"
        "nombre_completo" -> "Full name"
        "correo_electronico" -> "Email address"
        "actualizar_informacion" -> "Update Information"
        "actualizando" -> "Updating..."
        "cambiar_contrasena_titulo" -> "Change Password"
        "cambiar_contrasena_descripcion" -> "Leave blank if you don't want to change the password"
        "contrasena_actual" -> "Current password"
        "nueva_contrasena" -> "New password"
        "confirmar_nueva_contrasena" -> "Confirm new password"
        "cambiando" -> "Changing..."
        "cambiar_contrasena_btn" -> "Change Password"

        // Validations
        "nombre_vacio" -> "Name cannot be empty"
        "email_invalido" -> "Invalid email"
        "contrasena_actual_requerida" -> "Current password required"
        "contrasena_minimo_caracteres" -> "Password must be at least 6 characters"
        "contrasenas_no_coinciden" -> "Passwords don't match"

        // Success/Error messages
        "informacion_actualizada" -> "✅ Information updated successfully"
        "contrasena_actualizada" -> "✅ Password updated successfully"
        "error_actualizar_informacion" -> "❌ Error updating information"
        "error_cambiar_contrasena" -> "❌ Error changing password"
        "error_generico" -> "❌ Error: {0}"

        // Buttons and actions
        "volver" -> "Back"
        "ocultar_contrasena" -> "Hide password"
        "mostrar_contrasena" -> "Show password"

        // Dialogs
        "cambiar" -> "Change"
        "cancelar" -> "Cancel"
        "guardar" -> "Save"
        "aceptar" -> "Accept"
        "eliminar" -> "Delete"
        "contrasenas_no_coinciden_dialogo" -> "Passwords don't match"
        "contrasena_muy_corta" -> "Password must be at least 6 characters"

        // Messages
        "funcion_premium" -> "This feature is available only in Premium version"
        "error_actualizacion" -> "Error updating configuration"

        // ✅ NEW STRINGS FOR CATEGORIES
        "add_categoria" -> "Add category"
        "nueva_categoria" -> "New Category"
        "editar_categoria" -> "Edit Category"
        "nombre" -> "Name"
        "seleccionar_color" -> "Select color"
        "pulsa_crear_primera_categoria" -> "Tap + to create your first category"
        "eliminar_categoria" -> "Delete Category"
        "confirmar_eliminar_categoria" -> "Are you sure you want to delete \"{nombre}\"?"
        "categoria_creada" -> "Category created successfully"
        "categoria_actualizada" -> "Category updated successfully"
        "categoria_eliminada" -> "Category deleted successfully"
        "error_crear_categoria" -> "Error creating category"
        "error_actualizar_categoria" -> "Error updating category"
        "error_eliminar_categoria" -> "Error deleting category"
        "nombre_categoria_requerido" -> "Category name is required"
        "nombre_categoria_muy_corto" -> "Name must be at least 2 characters"
        "nombre_categoria_muy_largo" -> "Name cannot be more than 50 characters"
        "categoria_nombre_duplicado" -> "A category with that name already exists"
        "color_invalido" -> "Invalid color"
        "sincronizacion_completada" -> "Synchronization completed"
        "error_sincronizacion" -> "Synchronization error"

        // Articles - Main screen
        "articulos" -> "Articles"
        "add_articulo" -> "Add article"
        "nuevo_articulo" -> "New Article"
        "editar_articulo" -> "Edit Article"
        "pulsa_crear_primer_articulo" -> "Tap + to create your first article"
        "eliminar_articulo" -> "Delete Article"
        "confirmar_eliminar_articulo" -> "Are you sure you want to delete \"{nombre}\"?"

        // Form fields
        "precio_venta" -> "Sale price"
        "precio_coste" -> "Cost price"
        "stock" -> "Stock"
        "categoria" -> "Category"
        "seleccionar_categoria" -> "Select category"
        "sin_categorias" -> "No categories available"

        // Premium controls
        "controlar_coste" -> "Control cost"
        "controlar_stock" -> "Control stock"
        "marcar_favorito" -> "Mark as favorite"

        // Validations and messages
        "precio_venta_requerido" -> "Sale price is required"
        "precio_venta_invalido" -> "Invalid sale price"
        "categoria_requerida" -> "Select a category"
        "articulo_creado" -> "Article created successfully"
        "articulo_actualizado" -> "Article updated successfully"
        "articulo_eliminado" -> "Article deleted successfully"
        "error_crear_articulo" -> "Error creating article"
        "error_actualizar_articulo" -> "Error updating article"
        "error_eliminar_articulo" -> "Error deleting article"

        // States
        "sin_articulos" -> "You have no registered articles"
        "cargando_articulos" -> "Loading articles..."
        "sincronizando_articulos" -> "Syncing articles..."

        // Premium
        "solo_premium_stock" -> "Stock control available only in Premium"
        "solo_premium_coste" -> "Cost control available only in Premium"


        // ✅ AUTHENTICATION STRINGS PHASE 2
        "login_subtitle" -> "Sign in to your account"
        "register_subtitle" -> "Create your new account"
        "email" -> "Email"
        "email_placeholder" -> "your@email.com"
        "email_invalid" -> "Invalid email"
        "password" -> "Password"
        "password_placeholder" -> "Minimum 6 characters"
        "password_invalid" -> "Minimum 6 characters required"
        "login_button" -> "Sign In"
        "register_button" -> "Create Account"
        "loading" -> "Loading..."
        "or" -> "or"
        "go_to_register" -> "Don't have an account? Create account"
        "go_to_login" -> "Already have an account? Sign in"
        "register_benefits_title" -> "🚀 Account benefits:"
        "benefit_1" -> "• Automatic sync across all your devices"
        "benefit_2" -> "• Personalized configuration saved"
        "benefit_3" -> "• Access to Premium features"
        "benefit_4" -> "• Secure data backup"
        "welcome" -> "Welcome"
        "premium_user" -> "Premium User"
        "free_user" -> "Free User"
        "not_authenticated" -> "Not authenticated"
        "home" -> "Home"
        "markets" -> "Markets"
        "add_market" -> "Add Market"
        "premium_features" -> "Premium Features"
        "upgrade_premium" -> "Upgrade to Premium"
        "about" -> "About"
        "logout" -> "Sign Out"
        "exit_app" -> "Exit App"
        "logout_title" -> "Sign Out"
        "logout_message" -> "Are you sure you want to sign out?"
        "logout_confirm" -> "Sign Out"
        "exit_title" -> "Exit App"
        "exit_message" -> "Are you sure you want to exit Market Sales?"
        "exit_confirm" -> "Exit"
        "available_markets" -> "Available Markets"
        "premium_required" -> "Requires Premium for full access"
        "see_details" -> "See details"
        "edit" -> "Edit"
        "menu" -> "Menu"
        "premium" -> "Premium"
        "free" -> "Free"

        // 🚀 GOOGLE AUTH V8 - NEW ENGLISH STRINGS
        "google_signin" -> "Continue with Google"
        "google_register" -> "Sign up with Google"
        "google_auth_error" -> "Google authentication error"
        "google_token_error" -> "Error getting Google token"
        "auth_provider_google" -> "Google"
        "auth_provider_email" -> "Email"
        "google_signin_success" -> "Google authentication successful"
        "google_signin_failed" -> "Google authentication failed"

        // ✅ STRINGS PARA MERCADILLOS V11
        "add_mercadillo" -> "Add market"
        "nuevo_mercadillo" -> "New Market"
        "editar_mercadillo" -> "Edit Market"
        "ver_leyenda" -> "View legend"
        "leyenda_estados" -> "Status Legend"
        "entendido" -> "Understood"
        "proximo_mercadillo" -> "Next Market"
        "sin_mercadillos" -> "You have no registered markets"
        "pulsa_crear_primer_mercadillo" -> "Tap + to create your first market"

        // Market states
        "estado_programado_parcial" -> "Partially scheduled"
        "estado_programado_total" -> "Fully scheduled"
        "estado_en_curso" -> "In progress"
        "estado_pendiente_arqueo" -> "Finished (pending cash count)"
        "estado_pendiente_asignar_saldo" -> "Cash counted (pending balance assignment)"
        "estado_cerrado_completo" -> "Completely closed"
        "estado_cancelado" -> "Cancelled"

        // Market form
        "fecha_mercadillo" -> "Market date"
        "lugar_mercadillo" -> "Location"
        "organizador_mercadillo" -> "Organizer"
        "hora_inicio" -> "Start time"
        "hora_fin" -> "End time"
        "es_gratis" -> "Is free"
        "importe_suscripcion" -> "Subscription amount"
        "requiere_mesa" -> "Requires table"
        "requiere_carpa" -> "Requires tent"
        "hay_punto_luz" -> "Has power outlet"

        // Market validations
        "fecha_requerida" -> "Date is required"
        "fecha_invalida" -> "Invalid date format (dd-MM-yyyy)"
        "lugar_requerido" -> "Location is required"
        "lugar_muy_corto" -> "Location must be at least 3 characters"
        "lugar_muy_largo" -> "Location cannot be more than 100 characters"
        "organizador_requerido" -> "Organizer is required"
        "organizador_muy_corto" -> "Organizer must be at least 3 characters"
        "organizador_muy_largo" -> "Organizer cannot be more than 100 characters"
        "hora_inicio_invalida" -> "Invalid start time format (HH:mm)"
        "hora_fin_invalida" -> "Invalid end time format (HH:mm)"
        "horarios_invalidos" -> "Start time must be before end time"
        "importe_negativo" -> "Amount cannot be negative"
        "importe_muy_alto" -> "Amount is too high"
        "mercadillo_existe_fecha_hora" -> "A market already exists at that date and time"

        // Market messages
        "mercadillo_creado" -> "Market created successfully"
        "mercadillo_actualizado" -> "Market updated successfully"
        "mercadillo_eliminado" -> "Market deleted successfully"
        "mercadillo_cancelado" -> "Market cancelled successfully"
        "error_crear_mercadillo" -> "Error creating market"
        "error_actualizar_mercadillo" -> "Error updating market"
        "error_eliminar_mercadillo" -> "Error deleting market"
        "error_cancelar_mercadillo" -> "Error cancelling market"

        // Balances and cash counts
        "saldo_inicial" -> "Initial balance"
        "saldo_final" -> "Final balance"
        "asignar_saldo_inicial" -> "Assign initial balance"
        "asignar_automaticamente" -> "Assign automatically"
        "realizar_arqueo" -> "Perform cash count"
        "arqueo_caja" -> "Cash count"
        "saldo_asignado" -> "Initial balance assigned"
        "arqueo_realizado" -> "Cash count completed successfully"
        "sin_saldo_anterior" -> "No previous markets with available balance"
        "saldo_negativo" -> "Balance cannot be negative"
        "saldo_muy_alto" -> "Balance is too high"

        // Confirmations
        "confirmar_eliminar_mercadillo" -> "Are you sure you want to delete this market?"
        "confirmar_cancelar_mercadillo" -> "Are you sure you want to cancel this market?"
        "mercadillo_tiene_ventas" -> "Cannot cancel: market has sales"
        "mercadillo_estado_no_valido" -> "Cannot cancel: invalid status"

        "informacion_basica" -> "Basic Information"
        "horarios" -> "Schedule"
        "configuracion_mercadillo" -> "Market Configuration"
        "crear_mercadillo" -> "Create Market"
        "actualizar_mercadillo" -> "Update Market"
        "guardando" -> "Saving..."
        "saldo_inicial_ayuda" -> "Money available at the start of the market"
        "seleccionar_fecha" -> "Select date"
        "seleccionar_hora_inicio" -> "Select start time"
        "seleccionar_hora_fin" -> "Select end time"

        // English validations
        "fecha_no_puede_estar_vacia" -> "Date cannot be empty"
        "lugar_no_puede_estar_vacio" -> "Location cannot be empty"
        "organizador_no_puede_estar_vacio" -> "Organizer cannot be empty"
        "formato_fecha_invalido" -> "Invalid date format (dd-MM-yyyy)"
        "formato_hora_inicio_invalido" -> "Invalid start time format (HH:mm)"
        "formato_hora_fin_invalido" -> "Invalid end time format (HH:mm)"
        "hora_inicio_debe_ser_anterior" -> "Start time must be before end time"
        "lugar_minimo_caracteres" -> "Location must have at least 3 characters"
        "lugar_maximo_caracteres" -> "Location cannot have more than 100 characters"
        "organizador_minimo_caracteres" -> "Organizer must have at least 3 characters"
        "organizador_maximo_caracteres" -> "Organizer cannot have more than 100 characters"
        "importe_no_puede_ser_negativo" -> "Amount cannot be negative"
        "importe_demasiado_alto" -> "Amount is too high"
        "saldo_inicial_no_puede_ser_negativo" -> "Initial balance cannot be negative"
        "saldo_inicial_demasiado_alto" -> "Initial balance is too high"

        "seleccionar_hora" -> "Select time"
        "opcional" -> "(optional)"
        "lunes" -> "M"
        "martes" -> "T"
        "miercoles" -> "W"
        "jueves" -> "T"
        "viernes" -> "F"
        "sabado" -> "S"
        "domingo" -> "S"

        else -> key
    }
}


===== END
===== FILE: MainActivity.kt
// app/src/main/java/es/nuskysoftware/marketsales/MainActivity.kt
package es.nuskysoftware.marketsales

import android.os.Bundle
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavType
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import androidx.navigation.navArgument
import es.nuskysoftware.marketsales.ui.pantallas.PantallaConfiguracion
import es.nuskysoftware.marketsales.ui.pantallas.PantallaLogin
import es.nuskysoftware.marketsales.ui.pantallas.PantallaMercadillos
import es.nuskysoftware.marketsales.ui.pantallas.PantallaPerfil
import es.nuskysoftware.marketsales.ui.pantallas.PantallaSplash
import es.nuskysoftware.marketsales.ui.theme.MarketSalesTheme
import es.nuskysoftware.marketsales.ui.viewmodel.ConfiguracionViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.ConfiguracionViewModelFactory
import es.nuskysoftware.marketsales.ui.viewmodel.MercadilloViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.MercadilloViewModelFactory
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.data.repository.ConfiguracionRepository
import es.nuskysoftware.marketsales.ui.pantallas.PantallaAltaMercadillo
import es.nuskysoftware.marketsales.ui.pantallas.PantallaArticulos
import es.nuskysoftware.marketsales.ui.pantallas.PantallaCategorias
import es.nuskysoftware.marketsales.ui.pantallas.PantallaVentas

class MainActivity : ComponentActivity() {

    companion object {
        private const val TAG = "MainActivity"
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()

        Log.d(TAG, "🚀 MainActivity iniciada")

        setContent {
            val configuracionRepository = ConfiguracionRepository(this@MainActivity)
            val configuracionViewModel: ConfiguracionViewModel = viewModel(
                factory = ConfiguracionViewModelFactory(configuracionRepository)
            )

            val isDarkTheme by ConfigurationManager.temaOscuro.collectAsState()

            MarketSalesTheme(configurationManager = ConfigurationManager) {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    NavigationSystem(configuracionViewModel)
                }
            }
        }
    }
}

@Composable
fun NavigationSystem(
    configuracionViewModel: ConfiguracionViewModel
) {
    val navController = rememberNavController()
    var showSplash by remember { mutableStateOf(true) }

    LaunchedEffect(Unit) {
        kotlinx.coroutines.delay(2000)
        showSplash = false
    }

    if (showSplash) {
        PantallaSplash()
    } else {
        NavHost(navController = navController, startDestination = "mercadillos") {
            composable("mercadillos") {
                PantallaMercadillos(navController)
            }

            composable("configuracion") {
                PantallaConfiguracion(navController)
            }

            composable("login") {
                PantallaLogin(
                    onNavigateToMain = {
                        navController.navigate("mercadillos") {
                            popUpTo("login") { inclusive = true }
                        }
                    }
                )
            }

            composable("perfil") {
                PantallaPerfil(navController = navController)
            }

            composable("categorias") {
                PantallaCategorias(navController = navController)
            }

            composable("articulos") {
                PantallaArticulos(navController = navController)
            }

            composable("alta_mercadillo") {
                PantallaAltaMercadillo(navController = navController)
            }

            composable(
                route = "editar_mercadillo/{mercadilloId}",
                arguments = listOf(navArgument("mercadilloId") { type = NavType.StringType })
            ) { backStackEntry ->
                val mercadilloId = backStackEntry.arguments?.getString("mercadilloId")
                PantallaAltaMercadillo(
                    navController = navController,
                    mercadilloId = mercadilloId
                )
            }

            // ✅ NAVEGACIÓN A VENTAS ARREGLADA
            composable(
                route = "ventas/{mercadilloId}",
                arguments = listOf(navArgument("mercadilloId") { type = NavType.StringType })
            ) { backStackEntry ->
                val mercadilloId = backStackEntry.arguments?.getString("mercadilloId")

                if (mercadilloId != null) {
                    PantallaVentasWrapper(
                        navController = navController,
                        mercadilloId = mercadilloId
                    )
                }
            }
        }
    }
}

// ✅ WRAPPER QUE OBTIENE EL MERCADILLO POR ID
@Composable
fun PantallaVentasWrapper(
    navController: androidx.navigation.NavController,
    mercadilloId: String
) {
    val context = LocalContext.current
    val mercadilloViewModel: MercadilloViewModel = viewModel(
        factory = MercadilloViewModelFactory(context)
    )

    // Cargar el mercadillo específico
    LaunchedEffect(mercadilloId) {
        mercadilloViewModel.cargarMercadillo(mercadilloId)
    }

    val mercadilloParaEditar by mercadilloViewModel.mercadilloParaEditar.collectAsState()

    // Mostrar pantalla de ventas cuando el mercadillo esté cargado
    mercadilloParaEditar?.let { mercadillo ->
        PantallaVentas(
            navController = navController,
            mercadilloActivo = mercadillo
        )
    }
}

===== END

===== FILE: build.gradle.kts Project
// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    id("com.android.application") version "8.12.0" apply false
    id("org.jetbrains.kotlin.android") version "2.0.21" apply false
    id("org.jetbrains.kotlin.plugin.compose") version "2.0.21" apply false
    id("com.google.devtools.ksp") version "2.0.21-1.0.27"
    id("com.google.gms.google-services") version "4.4.3" apply false
}
===== END
===== FILE: bild.gradle.kts Module
plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
    id("org.jetbrains.kotlin.plugin.compose")
    id("com.google.devtools.ksp")
    id("com.google.gms.google-services")
    id ("kotlin-kapt")
}

android {
    namespace = "es.nuskysoftware.marketsales"
    compileSdk = 36

    defaultConfig {
        applicationId = "es.nuskysoftware.marketsales"
        minSdk = 24
        targetSdk = 36
        versionCode = 1
        versionName = "1.0"
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }

    kotlinOptions {
        jvmTarget = "11"
    }

    buildFeatures {
        compose = true
    }
}

dependencies {
    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.lifecycle.runtime.ktx)
    implementation(libs.androidx.activity.compose)
    implementation(platform(libs.androidx.compose.bom))
    implementation(libs.androidx.ui)
    implementation(libs.androidx.ui.graphics)
    implementation(libs.androidx.ui.tooling.preview)
    implementation(libs.androidx.material3)
    implementation(libs.androidx.navigation.compose)
    implementation(libs.androidx.room.runtime)

    testImplementation(libs.junit)
    androidTestImplementation(libs.androidx.junit)
    androidTestImplementation(libs.androidx.espresso.core)
    androidTestImplementation(platform(libs.androidx.compose.bom))
    androidTestImplementation(libs.androidx.ui.test.junit4)
    debugImplementation(libs.androidx.ui.tooling)
    debugImplementation(libs.androidx.ui.test.manifest)
    ksp(libs.androidx.room.compiler)

    implementation("com.github.skydoves:colorpicker-compose:1.1.2")

    // ✅ Firebase BOM (maneja versiones automáticamente)
    implementation(platform("com.google.firebase:firebase-bom:33.3.0"))
    implementation("com.google.firebase:firebase-firestore")

    implementation("androidx.work:work-runtime-ktx:2.9.0")

    // ✅ FIREBASE AUTH PARA FASE 2
    implementation("com.google.firebase:firebase-auth:22.3.0")
    implementation("com.google.firebase:firebase-firestore:24.9.1")

    // ✅ GOOGLE AUTH V8 - NUEVAS DEPENDENCIAS AGREGADAS
    implementation("com.google.android.gms:play-services-auth:20.7.0")
    implementation("androidx.credentials:credentials:1.3.0")
    implementation("androidx.credentials:credentials-play-services-auth:1.3.0")
    implementation("com.google.android.libraries.identity.googleid:googleid:1.1.1")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-play-services:1.7.3")

    // ✅ AGREGADO SOLO LO NECESARIO PARA FASE 2:
    implementation("androidx.room:room-ktx:2.6.0")
    implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0")
    implementation("androidx.compose.material:material-icons-extended:1.5.4")

    implementation("com.github.skydoves:colorpicker-compose:1.0.5")
}

===== END
===== FILE: libs.versions.toml
[versions]
agp = "8.11.1"
colorpickerCompose = "1.1.2"
hiltAndroid = "2.57"
kotlin = "2.0.21"
coreKtx = "1.16.0"
junit = "4.13.2"
junitVersion = "1.2.1"
espressoCore = "3.6.1"
lifecycleRuntimeKtx = "2.9.2"
activityCompose = "1.10.1"
composeBom = "2025.07.00"
navigationCompose = "2.9.2"
navigationComposeJvmstubs = "2.9.2"
ksp="2.0.21-1.0.27"
roomCompiler = "2.7.2"
roomRuntime = "2.7.2"
firebaseFirestoreKtx = "26.0.0"
[libraries]
androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
androidx-navigation-compose = { module = "androidx.navigation:navigation-compose", version.ref = "navigationCompose" }
androidx-room-runtime = { module = "androidx.room:room-runtime", version.ref = "roomRuntime" }
colorpicker-compose = { module = "com.github.skydoves:colorpicker-compose", version.ref = "colorpickerCompose" }
hilt-android = { module = "com.google.dagger:hilt-android", version.ref = "hiltAndroid" }
junit = { group = "junit", name = "junit", version.ref = "junit" }
androidx-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
androidx-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
androidx-lifecycle-runtime-ktx = { group = "androidx.lifecycle", name = "lifecycle-runtime-ktx", version.ref = "lifecycleRuntimeKtx" }
androidx-activity-compose = { group = "androidx.activity", name = "activity-compose", version.ref = "activityCompose" }
androidx-compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "composeBom" }
androidx-ui = { group = "androidx.compose.ui", name = "ui" }
androidx-ui-graphics = { group = "androidx.compose.ui", name = "ui-graphics" }
androidx-ui-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
androidx-ui-tooling-preview = { group = "androidx.compose.ui", name = "ui-tooling-preview" }
androidx-ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }
androidx-ui-test-junit4 = { group = "androidx.compose.ui", name = "ui-test-junit4" }
androidx-material3 = { group = "androidx.compose.material3", name = "material3" }
androidx-navigation-compose-jvmstubs = { group = "androidx.navigation", name = "navigation-compose-jvmstubs", version.ref = "navigationComposeJvmstubs" }
androidx-room-compiler = { group = "androidx.room", name = "room-compiler", version.ref = "roomCompiler" }

[plugins]
android-application = { id = "com.android.application", version.ref = "agp" }
kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
kotlin-compose = { id = "org.jetbrains.kotlin.plugin.compose", version.ref = "kotlin" }
com-google-devtools-ksp = { id = "com.google.devtools.ksp", version = "2.2.0-2.0.2" }
kotlin-ksp = {id = "com.google.devtools.ksp", version.ref ="ksp"}
===== END
===== FILE: settings.gradle.kts
pluginManagement {
    repositories {
        google {
            content {
                includeGroupByRegex("com\\.android.*")
                includeGroupByRegex("com\\.google.*")
                includeGroupByRegex("androidx.*")
            }
        }
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.name = "Market Sales"
include(":app")
===== END
===== FILE: app/src/main/AndroidManifest.xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <application
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.MarketSales">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:screenOrientation="portrait"
            android:label="@string/app_name"
            android:theme="@style/Theme.MarketSales">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>

===== END
ic_account.xml
ic_add.xml
ic_arrow_down.xml
ic_arrow_left.xml
ic_arrow_right.xml
ic_arrow_up.xml
ic_category.xml
ic_delete.xml
ic_edit.xml
ic_exit.xml
ic_font.xml
ic_gastos.xml
ic_info.xml
ic_inventory.xml
ic_language.xml
ic_launcher_background.xml
ic_launcher_foreground.xml
ic_list.xml
ic_login.xml
ic_logout.xml
ic_menu.xml
ic_money.xml
ic_palette.xml
ic_password.xml
ic_resumen.xml
ic_settings.xml
ic_store.xml
ic_ventas.xml

montserrat_bold.ttf
montserrat_medium.ttf
montserrat_regular.ttf
poppins_bold.ttf
poppins_medium.ttf
poppins_regular.ttf
roboto_bold.ttf
roboto_medium.ttf
roboto_regular.ttf