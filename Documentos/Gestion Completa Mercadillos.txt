Empezamos por el dise√±o de la pantalla.

La pantalla tiene que ser como la actual, para eso adjuntar√© al final del c√≥digo, el codigo actual de PantallaMercadillos
Debe tener el topbarr como el que tiene ahora, con el MenuHambuerguesa totalmente funcional y el texto Mercadillos.
Todos los textos de la pantalla debe usar StringResourceManager para que salgan en funcion del idioma del usuario que tiene se obtiene de ConfigurationManager.

Debajo del topbar tiene que aparece un calendario el el mes actual. Ese calendario se encergar√° de mostrar los mercadillos programados con el codigo de colores segun el estado.
en el que se encuentren. As√≠ como un boton "i" que al pulsarlo muestre la leyenda de los estados de los mercadillos. Tambien se adjuntara el codigo de Estados Mercadillos 
El calendario ser√° navegable para meses anteriores y meses siguientes.
Justo debajo del calendario se mostrar√° una serie de cards con los proximos mercadillos a partir de la fecha del sistema. Estos cards se mostrar√°n en scroll para poder ver todos
los proximos mercadillos. La informacion que debe mostrar ese card es la misma que muestras ahora Fecha, hora Lugar, organizador, etc. La misma que se muestra ahora.

Tambien tendra un boton, creo que se llama FAB para a√±adir un nuevo mercadillo. y al final se mostrara el Footer. El pie de pantalla cambiar√° cuando haya un mercadillo "En Curso"
En este caso se mostraran al pie tres botones. Ventas, Gastos y Resumen.

Funcionamiento de pantalla.
Es aqu√≠ donde se debe repartir el codigo en uno m√°s modulos.

Cuando se pulsa el boton FAB se llamar√° a una pantalla que ya exites, pero a la que hay que hacer modificaciones, que se llama PantallaAltaMercadillos. En esa pantalla se d√° de
alta los mercadillos. Los datos minimos son Fecha, lugar y organizador. eso se controla desde PantallaAltaMercadillos del que tambien adjuntare el codigo.
Cuando se pulse en una fecha que no tiene mercadillo asignado deber√° llamar al PantallaAltaMercadillos para crear un mercadillo pasando la fecha a la pantalla para crear el mercadillo
en esa fecha. Por ejempl si pulsamos en el 20 de agosto y no hay ningun mercadillo se abre la PantallaAltaMercadillos y en la fecha debe poner ya 20 de agosto.
Si pulsamos en una fecha que ya tiene un mercadillo deber√° abrir PantallaAltaMercadillos pero en modo edicion para editar los datos del mercadillo.
Los mercadillos en estado 1 y 2 se pueden modificar en su totalidad. Los mercadillos en estado 3 se puede modificar todo menos la fecha. En caso de modificar el Saldo Inicial
debera aparece primero un aviso de que modificar el saldo inicial de un Mercadillo En Curso puede provocar errores en el arqueo de caja. En el resto de estados no se puede modificar nada

Al pulsar en un dia que hay mas de un mercadillo programado debe salir una pantalla modal intermedia para seleccionar el mercadillo que queremos modificar. 
De igual manera cuando hay un mercadillo en curso al pie salen unos botones, Ventas, Gastos y Resumen. Si al pulsar alguno de esos hay varios mercadillos en curso debe salir la 
misma pantalla o una similar que permita elegir a que mercadillo hay que a√±adir ventas, gastos o mostrar el listado de ventas. La primera vez que se seleccione se guardar√° esa selecciona
as√≠ la proxima vez que se pulse ventas, gastos o resumen ya no haya que elegir. Tambian habra que poner un boton en algun sitio que sea algo as√≠ como "olvidar seleccion" para que
el programa vuelva a pedir que se seleccione el mercadillo cuando se pulsa alguno de los botones del pie.

MUY IMPORTANTE
Siempre que se carga la PantallaMercadillos se debe actualizar toda la informaciona de la pantalla. De los estados de mercadillos. Cuando se crea un mercadillo, cuando se 
modifica un mercadillo, cuando hay un mercadillo en curso, cuando se cambia el usuario logado o se cierra sesion,  etc. Esto es super importante. La informacion que muestra la PantallaMercadillos tiene que estar 100% actualizada en 
cuanto a los estados de los mercadillos.

Como se manejan los estado:

Los estados de los mercadillos son 7
1 Programado Parcialmente
2 Programado totalmente
3 En Curso
4 Pendiente de Arqueo
5 Pendiente de Asignar Saldo
6 Cerrado
7 Cancelado.

Como se manejan los estados.
Cuando se da de alta un mercadillo o se actualiza, si no tiene Saldo Inicial su estado es 1.
Cuando un mercadillo se da de alta o se actualizar y SI tiene saldo inicial su estado es dos.
Cuando la fecha de programacion de un mercadillo coincide con la fecha del sistema esta en estado En Curso. 
¬øhasta cuando se considera que un mercadillos est√° en curso? 
Hasta las 5 de la ma√±ana del dia siguiente. 
Es decir si un mercadillo se programa para el dia 20 de agosto, estar√° En Curso desde las 00:00 del 20 de agosto,hasta las 05:00 del 21 de agosto
Cuando un mercadillo esta en una fecha anterior a la fecha actual Y NO TIENE RECIBOS Y/O VENTAS estar√° en estado Cancelado. Si por contra SI TIENE VENTAS
estar√° en estado 4 pendiente de arqueo. Salvo que este en estado 5 o 6, logicamente. Es decir el si la fecha de mercadillo esta pasada, tiene lineas de ventas, pero no se ha
hecho todavia el arqueo, esta en estado 4, pendiente de arqueo. Cuando se realiza el arqueo y no se ha asignado su saldo a un mercadillo posterior esta en estado 5, 
pendiente de asignar saldo. Y por ultimo cuando se asigne ese saldo a un mercadillo posterior, estar√° en estado 6, Cerrado.

Cuando un mercadillo est√° Cancelado?
Cuando este en una fecha pasada y no tenga lineas de ventas o cuando desde PantallaAltaMercadillos se haya modificado su estado a "Cancelado"

Con esto est√°n aclarados todos los estados de los mercadilos, las altas y las modificaciones.

Hay que hacer cambios el el PantallaAltaMercadillos. Cuando este pantalla se abra para crear un mercadillo mostrar√° lo mismo que muestras ahora:
Fecha, cuyo valor depender√° de si se ha pulsado el FAB o una fecha libre del calendario
Lugar
Organizador
SI el mercadillo es gratuito. Si es falso mostrar√° el un imput text para introducir el importe de la suscripcion
Si requiere mesa
si reguiere carpa
si hay punto de luz
El horario, que es solo orientativo, no se usa para nada mas.
y el saldo inicial.

abajo los botones Cancelar y Crear

En caso de modificar saldran esos campos y uno m√°s que es desplegable para seleccionar la opcion cancelado para ello habr√° que cambiar el que sale ahora como "Estado DEBUG" y cambiarlo
por este para poner el estado en Cancelado. Pero con las restricciones que hemos comentado. Solo en los estados 1 y 2. En el estado 3 solo si no hay lineas de ventas. en los demas
estados no se podr√° modificar como el resto de los campos. 

En el pie apareceran los botones actualizar y cancelar.

Si el Mercadillo esta en estado 4, 5 y 6, no se podr√° cambiar ningun dato. y los botones que apareceran abajo seran.
Cancelar y Arqueo. 
De momento
no vamos a definir la funcionalidad de arqueo, pero queda pendiente para un futuro.


Consideraciones para usuarios Free vs Premium. 
Los usuario premium no pueden crear m√°s de un mercadillo en un mismo dia. 

A partir de este documento ha que definir que m√≥dulos hay que crear, uno o mas de uno, para la gestion de los mercadillo. 
PantallaMercadillos debe gestionar solo el Composable y llamar a las funciones que hacen el trabajo.

CODIGO FUENTE
// app/src/main/java/es/nuskysoftware/marketsales/ui/pantallas/PantallaMercadillos.kt
// ACTUALIZACI√ìN: Pull-to-Refresh Material 3 (sin banner) + Paywall v√≠a Snackbar + ProgressBar de Sync

package es.nuskysoftware.marketsales.ui.pantallas

import es.nuskysoftware.marketsales.data.repository.SyncState
import es.nuskysoftware.marketsales.ui.viewmodel.AuthViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.AuthViewModelFactory

import es.nuskysoftware.marketsales.ui.components.MenuHamburguesa
import es.nuskysoftware.marketsales.ui.components.BottomBarMercadillo
import es.nuskysoftware.marketsales.ui.components.DialogoSeleccionMercadilloActivo
import es.nuskysoftware.marketsales.ui.components.DownloadProgressBar
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Info
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Badge
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.ModalNavigationDrawer
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarDuration
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.SnackbarResult
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.pulltorefresh.PullToRefreshBox
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.DialogProperties
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import kotlinx.coroutines.launch
import kotlinx.coroutines.delay
import es.nuskysoftware.marketsales.R
import es.nuskysoftware.marketsales.data.local.entity.MercadilloEntity
import es.nuskysoftware.marketsales.ui.viewmodel.MercadilloViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.MercadilloViewModelFactory
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.EstadosMercadillo
import es.nuskysoftware.marketsales.utils.FooterMarca
import es.nuskysoftware.marketsales.utils.StringResourceManager

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PantallaMercadillos(
    navController: NavController? = null
) {
    val context = LocalContext.current

    // ViewModel con factory
    val mercadilloViewModel: MercadilloViewModel = viewModel(
        factory = MercadilloViewModelFactory(context)
    )

    val authViewModel: AuthViewModel = viewModel(
        factory = AuthViewModelFactory(context.applicationContext)
    )

    // ‚úÖ Estados de sincronizaci√≥n/progreso desde AuthViewModel
    val syncState by authViewModel.syncState.collectAsState()
    val progress by authViewModel.downloadProgress.collectAsState()
    val message by authViewModel.downloadMessage.collectAsState()

    // Estados para el drawer
    val drawerState = androidx.compose.material3.rememberDrawerState(androidx.compose.material3.DrawerValue.Closed)
    val scope = rememberCoroutineScope()

    // Estados de configuraci√≥n
    val currentLanguage by ConfigurationManager.idioma.collectAsState()
    val esPremium by ConfigurationManager.esPremium.collectAsState()
    val isAuthenticated by ConfigurationManager.isAuthenticated.collectAsState()

    // Estados del ViewModel
    val uiState by mercadilloViewModel.uiState.collectAsState()
    val calendarioState by mercadilloViewModel.calendarioState.collectAsState()
    val mercadillosPorDia by mercadilloViewModel.mercadillosPorDia.collectAsState()
    val proximoMercadillo by mercadilloViewModel.proximoMercadillo.collectAsState()
    val nombreMesActual by mercadilloViewModel.nombreMesActual.collectAsState()
    val tieneMercadillos by mercadilloViewModel.tieneMercadillos.collectAsState()

    // ‚úÖ NUEVOS ESTADOS PARA BOTTOMBAR
    val mostrarBottomBar by mercadilloViewModel.mostrarBottomBar.collectAsState()
    val mercadillosEnCurso by mercadilloViewModel.mercadillosEnCurso.collectAsState()
    val mercadilloActivoParaOperaciones by mercadilloViewModel.mercadilloActivoParaOperaciones.collectAsState()

    // Estados locales
    var mostrarLeyenda by remember { mutableStateOf(false) }
    var mostrarDialogoSeleccion by remember { mutableStateOf(false) }
    var mercadillosParaSeleccionar by remember { mutableStateOf<List<MercadilloEntity>>(emptyList()) }

    // ‚úÖ NUEVOS ESTADOS PARA MERCADILLOS PR√ìXIMOS
    val mercadillosProximos by mercadilloViewModel.mercadillosProximos.collectAsState()
    val tieneMercadillosProximos by mercadilloViewModel.tieneMercadillosProximos.collectAsState()

    // ‚úÖ NUEVOS ESTADOS PARA BOTTOMBAR
    var mostrarDialogoSeleccionActivo by remember { mutableStateOf(false) }
    var accionPendiente by remember { mutableStateOf<String?>(null) } // "ventas", "gastos", "resumen"

    val snackbarHostState = remember { SnackbarHostState() }

    // ====== PULL-TO-REFRESH (Material 3) ======
    var isRefreshing by remember { mutableStateOf(false) }

    // Manejar mensajes del ViewModel
    LaunchedEffect(uiState.message) {
        uiState.message?.let { message ->
            snackbarHostState.showSnackbar(message)
            mercadilloViewModel.limpiarMensaje()
        }
    }

    LaunchedEffect(uiState.error) {
        uiState.error?.let { error ->
            snackbarHostState.showSnackbar(error)
            mercadilloViewModel.limpiarError()
        }
    }

    // ====== UI ======
    PullToRefreshBox(
        isRefreshing = isRefreshing,
        onRefresh = {
            scope.launch {
                isRefreshing = true
                if (esPremium) {
                    // PREMIUM ‚Üí sync completa (subir + bajar) via VM
                    mercadilloViewModel.forzarSincronizacion()
                } else {
                    // FREE ‚Üí refresco local (no red) + paywall
                    delay(600)
                    val result = snackbarHostState.showSnackbar(
                        message = StringResourceManager.getString("premium_required", currentLanguage),
                        actionLabel = StringResourceManager.getString("go_premium", currentLanguage),
                        withDismissAction = true,
                        duration = SnackbarDuration.Short
                    )
                    if (result == SnackbarResult.ActionPerformed) {
                        navController?.navigate("configuracion")
                    }
                }
                isRefreshing = false
            }
        },
        modifier = Modifier.fillMaxSize()
    ) {
        // Drawer + Scaffold
        ModalNavigationDrawer(
            drawerState = drawerState,
            drawerContent = {
                navController?.let { nav ->
                    MenuHamburguesa(
                        navController = nav,
                        drawerState = drawerState
                    )
                }
            }
        ) {
            Scaffold(
                topBar = {
                    TopAppBar(
                        title = {
                            Text(
                                StringResourceManager.getString("mercadillos", currentLanguage),
                                fontWeight = FontWeight.Bold
                            )
                        },
                        navigationIcon = {
                            IconButton(
                                onClick = {
                                    scope.launch { drawerState.open() }
                                }
                            ) {
                                Icon(
                                    painter = painterResource(id = R.drawable.ic_menu),
                                    contentDescription = StringResourceManager.getString("menu", currentLanguage)
                                )
                            }
                        },
                        colors = TopAppBarDefaults.topAppBarColors(
                            containerColor = MaterialTheme.colorScheme.primary,
                            titleContentColor = MaterialTheme.colorScheme.onPrimary,
                            navigationIconContentColor = MaterialTheme.colorScheme.onPrimary
                        )
                    )
                },
                snackbarHost = { SnackbarHost(snackbarHostState) },
                floatingActionButton = {
                    FloatingActionButton(
                        onClick = {
                            navController?.navigate("alta_mercadillo")
                        },
                        shape = CircleShape,
                        containerColor = MaterialTheme.colorScheme.primary,
                        contentColor = MaterialTheme.colorScheme.onPrimary
                    ) {
                        Icon(
                            imageVector = Icons.Default.Add,
                            contentDescription = StringResourceManager.getString("add_mercadillo", currentLanguage)
                        )
                    }
                },
                bottomBar = {
                    if (mostrarBottomBar) {
                        BottomBarMercadillo(
                            mercadilloActivo = mercadilloActivoParaOperaciones,
                            onVentasClick = { manejarOperacion("ventas", mercadilloViewModel, navController) },
                            onGastosClick = { manejarOperacion("gastos", mercadilloViewModel, navController) },
                            onResumenClick = { manejarOperacion("resumen", mercadilloViewModel, navController) },
                            onCambiarMercadillo = { mercadilloViewModel.cambiarMercadilloActivo() },
                            currentLanguage = currentLanguage
                        )
                    }
                }
            ) { paddingValues ->
                // =================== CONTENIDO ===================
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues)
                        .background(MaterialTheme.colorScheme.background)
                ) {

                    // üîµ Barra de progreso de descarga/sync (visible mientras est√° en marcha)
                    DownloadProgressBar(
                        visible = syncState != SyncState.Idle && syncState != SyncState.Done && syncState !is SyncState.Error,
                        progressPercent = progress,
                        message = message,
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(horizontal = 16.dp, vertical = 8.dp)
                    )

                    // Bloque principal que ocupa el espacio disponible
                    Column(
                        modifier = Modifier
                            .weight(1f)
                            .fillMaxWidth()
                    ) {
                        // ========== CALENDARIO CON MERCADILLOS ==========
                        Card(
                            modifier = Modifier
                                .fillMaxWidth()
                                .height(350.dp)
                                .padding(horizontal = 16.dp, vertical = 8.dp),
                            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
                            colors = CardDefaults.cardColors(
                                containerColor = MaterialTheme.colorScheme.surface
                            )
                        ) {
                            Column(
                                modifier = Modifier
                                    .fillMaxSize()
                                    .padding(16.dp)
                            ) {
                                // Header del calendario con navegaci√≥n entre meses
                                Row(
                                    modifier = Modifier.fillMaxWidth(),
                                    horizontalArrangement = Arrangement.SpaceBetween,
                                    verticalAlignment = Alignment.CenterVertically
                                ) {
                                    IconButton(
                                        onClick = { mercadilloViewModel.navegarMesAnterior() }
                                    ) {
                                        Text(
                                            text = "‚Üê",
                                            fontSize = 20.sp,
                                            color = MaterialTheme.colorScheme.primary
                                        )
                                    }

                                    Text(
                                        text = nombreMesActual,
                                        style = MaterialTheme.typography.titleLarge,
                                        fontWeight = FontWeight.Bold,
                                        color = MaterialTheme.colorScheme.onSurface
                                    )

                                    IconButton(
                                        onClick = { mercadilloViewModel.navegarMesSiguiente() }
                                    ) {
                                        Text(
                                            text = "‚Üí",
                                            fontSize = 20.sp,
                                            color = MaterialTheme.colorScheme.primary
                                        )
                                    }

                                    IconButton(
                                        onClick = { mostrarLeyenda = true },
                                        modifier = Modifier.size(32.dp)
                                    ) {
                                        Icon(
                                            imageVector = Icons.Default.Info,
                                            contentDescription = StringResourceManager.getString("ver_leyenda", currentLanguage),
                                            tint = MaterialTheme.colorScheme.primary,
                                            modifier = Modifier.size(20.dp)
                                        )
                                    }
                                }

                                Spacer(modifier = Modifier.height(8.dp))

                                // D√≠as de la semana
                                Row(
                                    modifier = Modifier.fillMaxWidth(),
                                    horizontalArrangement = Arrangement.SpaceEvenly
                                ) {
                                    listOf("L", "M", "X", "J", "V", "S", "D").forEach { dia ->
                                        Text(
                                            text = dia,
                                            style = MaterialTheme.typography.bodySmall,
                                            fontWeight = FontWeight.Bold,
                                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f),
                                            modifier = Modifier.weight(1f),
                                            textAlign = TextAlign.Center
                                        )
                                    }
                                }

                                Spacer(modifier = Modifier.height(8.dp))

                                // Grid del calendario
                                CalendarioGrid(
                                    ano = calendarioState.ano,
                                    mes = calendarioState.mes,
                                    mercadillosPorDia = mercadillosPorDia,
                                    onDiaClick = { dia ->
                                        val mercadillosDelDia = mercadillosPorDia[dia] ?: emptyList()
                                        manejarClickDiaCalendario(
                                            mercadillosDelDia,
                                            navController
                                        )
                                    }
                                )
                            }
                        }

                        // ========== CARD PR√ìXIMOS MERCADILLOS ==========
                        CardMercadillosProximos(
                            mercadillosProximos = mercadillosProximos,
                            onMercadilloClick = { mercadillo ->
                                navController?.navigate("editar_mercadillo/${mercadillo.idMercadillo}")
                            }
                        )

                        // ========== ESTADO VAC√çO ==========
                        if (!tieneMercadillos) {
                            Column(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .padding(32.dp),
                                horizontalAlignment = Alignment.CenterHorizontally,
                                verticalArrangement = Arrangement.Center
                            ) {
                                Icon(
                                    painter = painterResource(id = R.drawable.ic_store),
                                    contentDescription = null,
                                    modifier = Modifier.size(64.dp),
                                    tint = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.4f)
                                )

                                Spacer(modifier = Modifier.height(16.dp))

                                Text(
                                    text = StringResourceManager.getString("sin_mercadillos", currentLanguage),
                                    style = MaterialTheme.typography.titleMedium,
                                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f),
                                    textAlign = TextAlign.Center
                                )

                                Spacer(modifier = Modifier.height(8.dp))

                                Text(
                                    text = StringResourceManager.getString("pulsa_crear_primer_mercadillo", currentLanguage),
                                    style = MaterialTheme.typography.bodyMedium,
                                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f),
                                    textAlign = TextAlign.Center
                                )
                            }
                        }
                    }

                    // ========== FOOTER ==========
                    FooterMarca()
                }
            }

            // ========== DI√ÅLOGO DE LEYENDA ==========
            if (mostrarLeyenda) {
                LeyendaColoresDialog(
                    onDismiss = { mostrarLeyenda = false },
                    currentLanguage = currentLanguage
                )
            }

            // ========== DI√ÅLOGO DE SELECCI√ìN DE MERCADILLOS (EDICI√ìN) ==========
            if (mostrarDialogoSeleccion) {
                DialogoSeleccionMercadillo(
                    mercadillos = mercadillosParaSeleccionar,
                    onMercadilloSeleccionado = { mercadillo ->
                        mostrarDialogoSeleccion = false
                        navController?.navigate("editar_mercadillo/${mercadillo.idMercadillo}")
                    },
                    onDismiss = { mostrarDialogoSeleccion = false },
                    currentLanguage = currentLanguage
                )
            }

            // ‚úÖ DI√ÅLOGO DE SELECCI√ìN DE MERCADILLO ACTIVO (OPERACIONES)
            var mostrarDialogoSeleccionActivo by remember { mutableStateOf(false) }
            var accionPendiente by remember { mutableStateOf<String?>(null) }
            if (mostrarDialogoSeleccionActivo) {
                DialogoSeleccionMercadilloActivo(
                    mercadillosEnCurso = mercadillosEnCurso,
                    onMercadilloSeleccionado = { mercadillo ->
                        mercadilloViewModel.seleccionarMercadilloActivo(mercadillo)
                        mostrarDialogoSeleccionActivo = false

                        accionPendiente?.let { accion ->
                            when (accion) {
                                "ventas" -> navController?.navigate("ventas/${mercadillo.idMercadillo}")
                                "gastos" -> navController?.navigate("gastos/${mercadillo.idMercadillo}")
                                "resumen" -> navController?.navigate("resumen/${mercadillo.idMercadillo}")
                            }
                            accionPendiente = null
                        }
                    },
                    onDismiss = {
                        mostrarDialogoSeleccionActivo = false
                        accionPendiente = null
                    },
                    currentLanguage = currentLanguage
                )
            }
        }
    }
}

private fun manejarClickDiaCalendario(
    mercadillosDelDia: List<MercadilloEntity>,
    navController: NavController?
) {
    when (mercadillosDelDia.size) {
        0 -> Unit
        1 -> navController?.navigate("editar_mercadillo/${mercadillosDelDia.first().idMercadillo}")
        else -> {
            // El di√°logo de selecci√≥n se maneja en el estado de la pantalla
        }
    }
}

// Navegaci√≥n desde la Bottombar con selecci√≥n si hay varios activos
private fun manejarOperacion(
    tipoOperacion: String,
    mercadilloViewModel: MercadilloViewModel,
    navController: NavController?
) {
    val (puedeNavegar, mercadillo) = when (tipoOperacion) {
        "ventas" -> mercadilloViewModel.manejarNavegacionVentas()
        "gastos" -> mercadilloViewModel.manejarNavegacionGastos()
        "resumen" -> mercadilloViewModel.manejarNavegacionResumen()
        else -> Pair(false, null)
    }

    if (puedeNavegar && mercadillo != null) {
        when (tipoOperacion) {
            "ventas" -> navController?.navigate("ventas/${mercadillo.idMercadillo}")
            "gastos" -> navController?.navigate("gastos/${mercadillo.idMercadillo}")
            "resumen" -> navController?.navigate("resumen/${mercadillo.idMercadillo}")
        }
    } else {
        // Si no puede navegar directo, el propio ViewModel ya gestiona mostrar selecci√≥n.
    }
}

@Composable
private fun CalendarioGrid(
    ano: Int,
    mes: Int,
    mercadillosPorDia: Map<Int, List<MercadilloEntity>>,
    onDiaClick: (Int) -> Unit
) {
    val diasDelMes = when (mes) {
        1, 3, 5, 7, 8, 10, 12 -> 31
        4, 6, 9, 11 -> 30
        2 -> if (ano % 4 == 0 && (ano % 100 != 0 || ano % 400 == 0)) 29 else 28
        else -> 31
    }

    val calendar = java.util.Calendar.getInstance().apply {
        set(ano, mes - 1, 1)
    }
    val primerDiaSemana = (calendar.get(java.util.Calendar.DAY_OF_WEEK) + 5) % 7

    LazyVerticalGrid(
        columns = GridCells.Fixed(7),
        modifier = Modifier.fillMaxWidth(),
        verticalArrangement = Arrangement.spacedBy(4.dp),
        horizontalArrangement = Arrangement.spacedBy(4.dp)
    ) {
        items(primerDiaSemana) {
            Box(modifier = Modifier.size(40.dp))
        }

        items((1..diasDelMes).toList()) { dia ->
            DiaCalendario(
                dia = dia,
                mercadillos = mercadillosPorDia[dia] ?: emptyList(),
                onClick = { onDiaClick(dia) }
            )
        }
    }
}

@Composable
private fun DiaCalendario(
    dia: Int,
    mercadillos: List<MercadilloEntity>,
    onClick: () -> Unit
) {
    val estados = mercadillos.map { mercadillo ->
        EstadosMercadillo.Estado.fromCodigo(mercadillo.estado)
            ?: EstadosMercadillo.Estado.PROGRAMADO_PARCIAL
    }.sortedBy { EstadosMercadillo.obtenerPrioridad(it) }

    Box(
        modifier = Modifier
            .size(40.dp)
            .clickable { onClick() }
            .background(
                color = if (estados.size == 1) {
                    EstadosMercadillo.obtenerColor(estados.first())
                } else {
                    MaterialTheme.colorScheme.surface
                },
                shape = RoundedCornerShape(8.dp)
            ),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            Text(
                text = dia.toString(),
                style = MaterialTheme.typography.bodySmall,
                color = if (estados.size == 1) {
                    EstadosMercadillo.obtenerColorTexto(estados.first())
                } else {
                    MaterialTheme.colorScheme.onSurface
                },
                fontWeight = if (mercadillos.isNotEmpty()) FontWeight.Bold else FontWeight.Normal
            )

            if (estados.size > 1) {
                Row(
                    horizontalArrangement = Arrangement.spacedBy(3.dp),
                    modifier = Modifier.padding(top = 2.dp)
                ) {
                    estados.take(2).forEach { estado ->
                        Box(
                            modifier = Modifier
                                .size(6.dp)
                                .background(
                                    EstadosMercadillo.obtenerColor(estado),
                                    CircleShape
                                )
                        )
                    }
                }
            }
        }
    }
}

@Composable
private fun LeyendaColoresDialog(
    onDismiss: () -> Unit,
    currentLanguage: String
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        properties = DialogProperties(usePlatformDefaultWidth = false),
        title = {
            Text(
                text = StringResourceManager.getString("leyenda_estados", currentLanguage),
                style = MaterialTheme.typography.titleLarge,
                fontWeight = FontWeight.Bold
            )
        },
        text = {
            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                EstadosMercadillo.obtenerTodosLosEstados().forEach { estado ->
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Box(
                            modifier = Modifier
                                .size(16.dp)
                                .background(
                                    EstadosMercadillo.obtenerColor(estado),
                                    CircleShape
                                )
                        )

                        Spacer(modifier = Modifier.width(12.dp))

                        Text(
                            text = EstadosMercadillo.obtenerIcono(estado),
                            fontSize = 16.sp
                        )

                        Spacer(modifier = Modifier.width(8.dp))

                        Text(
                            text = estado.descripcion,
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.onSurface
                        )
                    }
                }
            }
        },
        confirmButton = {
            TextButton(onClick = onDismiss) {
                Text(StringResourceManager.getString("entendido", currentLanguage))
            }
        }
    )
}

@Composable
private fun DialogoSeleccionMercadillo(
    mercadillos: List<MercadilloEntity>,
    onMercadilloSeleccionado: (MercadilloEntity) -> Unit,
    onDismiss: () -> Unit,
    currentLanguage: String
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = {
            Text(
                text = "Seleccionar mercadillo",
                style = MaterialTheme.typography.titleLarge,
                fontWeight = FontWeight.Bold
            )
        },
        text = {
            LazyColumn(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                items(mercadillos) { mercadillo ->
                    Card(
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable { onMercadilloSeleccionado(mercadillo) },
                        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
                    ) {
                        Column(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(12.dp)
                        ) {
                            Text(
                                text = mercadillo.lugar,
                                style = MaterialTheme.typography.titleMedium,
                                fontWeight = FontWeight.Bold,
                                color = MaterialTheme.colorScheme.onSurface
                            )

                            Spacer(modifier = Modifier.height(4.dp))

                            Text(
                                text = "${mercadillo.organizador} ‚Ä¢ ${mercadillo.horaInicio} - ${mercadillo.horaFin}",
                                style = MaterialTheme.typography.bodyMedium,
                                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                            )

                            Spacer(modifier = Modifier.height(4.dp))

                            val estado = EstadosMercadillo.Estado.fromCodigo(mercadillo.estado)
                            if (estado != null) {
                                Row(verticalAlignment = Alignment.CenterVertically) {
                                    Text(
                                        text = EstadosMercadillo.obtenerIcono(estado),
                                        fontSize = 12.sp
                                    )
                                    Spacer(modifier = Modifier.width(4.dp))
                                    Text(
                                        text = estado.descripcion,
                                        style = MaterialTheme.typography.bodySmall,
                                        color = EstadosMercadillo.obtenerColor(estado)
                                    )
                                }
                            }
                        }
                    }
                }
            }
        },
        confirmButton = { },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text(StringResourceManager.getString("cancelar", currentLanguage))
            }
        }
    )
}

/**
 * ‚úÖ Card con lista de mercadillos pr√≥ximos
 */
@Composable
fun CardMercadillosProximos(
    mercadillosProximos: List<MercadilloEntity>,
    onMercadilloClick: (MercadilloEntity) -> Unit
) {
    if (mercadillosProximos.isNotEmpty()) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp, vertical = 4.dp),
            elevation = CardDefaults.cardElevation(defaultElevation = 6.dp),
            colors = CardDefaults.cardColors(
                containerColor = MaterialTheme.colorScheme.primaryContainer
            ),
            shape = RoundedCornerShape(12.dp)
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            ) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        text = "Pr√≥ximos Mercadillos",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.onPrimaryContainer
                    )
                    Badge(
                        containerColor = MaterialTheme.colorScheme.primary
                    ) {
                        Text(
                            text = mercadillosProximos.size.toString(),
                            color = MaterialTheme.colorScheme.onPrimary,
                            style = MaterialTheme.typography.bodySmall
                        )
                    }
                }

                Spacer(modifier = Modifier.height(12.dp))

                mercadillosProximos.take(3).forEachIndexed { index, mercadillo ->
                    MercadilloProximoItem(
                        mercadillo = mercadillo,
                        onClick = { onMercadilloClick(mercadillo) }
                    )

                    if (index < mercadillosProximos.take(3).size - 1) {
                        Spacer(modifier = Modifier.height(8.dp))
                        HorizontalDivider(
                            color = MaterialTheme.colorScheme.onPrimaryContainer.copy(alpha = 0.2f),
                            thickness = 1.dp
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                    }
                }

                if (mercadillosProximos.size > 3) {
                    Spacer(modifier = Modifier.height(12.dp))

                    Card(
                        modifier = Modifier.fillMaxWidth(),
                        colors = CardDefaults.cardColors(
                            containerColor = MaterialTheme.colorScheme.primary.copy(alpha = 0.1f)
                        ),
                        shape = RoundedCornerShape(8.dp)
                    ) {
                        Text(
                            text = "+ ${mercadillosProximos.size - 3} mercadillos m√°s",
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.primary,
                            fontWeight = FontWeight.Medium,
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(8.dp),
                            textAlign = TextAlign.Center
                        )
                    }
                }
            }
        }
    }
}

@Composable
private fun MercadilloProximoItem(
    mercadillo: MercadilloEntity,
    onClick: () -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onClick() }
            .padding(vertical = 4.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Column(modifier = Modifier.weight(1f)) {
            Row(verticalAlignment = Alignment.CenterVertically) {
                Text(text = "üìÖ ", fontSize = 14.sp)
                Text(
                    text = "${mercadillo.fecha} ‚Ä¢ ${mercadillo.horaInicio}",
                    style = MaterialTheme.typography.bodyMedium,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.onPrimaryContainer
                )
            }

            Spacer(modifier = Modifier.height(4.dp))

            Row(verticalAlignment = Alignment.CenterVertically) {
                Text(text = "üìç ", fontSize = 14.sp)
                Text(
                    text = mercadillo.lugar,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onPrimaryContainer,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
            }

            Spacer(modifier = Modifier.height(2.dp))

            Row(verticalAlignment = Alignment.CenterVertically) {
                Text(text = "üë• ", fontSize = 12.sp)
                Text(
                    text = mercadillo.organizador,
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onPrimaryContainer.copy(alpha = 0.8f),
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
            }

            val estado = EstadosMercadillo.Estado.fromCodigo(mercadillo.estado)
            if (estado != null) {
                Spacer(modifier = Modifier.height(4.dp))
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Box(
                        modifier = Modifier
                            .size(8.dp)
                            .background(
                                EstadosMercadillo.obtenerColor(estado),
                                CircleShape
                            )
                    )
                    Spacer(modifier = Modifier.width(6.dp))
                    Text(
                        text = estado.descripcion,
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onPrimaryContainer.copy(alpha = 0.7f),
                        fontSize = 11.sp
                    )
                }
            }

            if (mercadillo.saldoInicial != null) {
                Spacer(modifier = Modifier.height(2.dp))
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Text(text = "üí∞ ", fontSize = 12.sp)
                    Text(
                        text = "‚Ç¨${String.format("%.2f", mercadillo.saldoInicial)}",
                        style = MaterialTheme.typography.bodySmall,
                        color = Color(0xFF4CAF50),
                        fontWeight = FontWeight.Medium,
                        fontSize = 11.sp
                    )
                }
            }
        }

        Column(horizontalAlignment = Alignment.CenterHorizontally) {
            IconButton(
                onClick = onClick,
                modifier = Modifier.size(32.dp)
            ) {
                Text(
                    text = "‚Üí",
                    fontSize = 18.sp,
                    color = MaterialTheme.colorScheme.onPrimaryContainer,
                    fontWeight = FontWeight.Bold
                )
            }
        }
    }
}

// app/src/main/java/es/nuskysoftware/marketsales/data/local/dao/MercadilloDao.kt
package es.nuskysoftware.marketsales.data.local.dao

import androidx.room.*
import es.nuskysoftware.marketsales.data.local.entity.MercadilloEntity
import kotlinx.coroutines.flow.Flow

/**
 * MercadilloDao V11 - Market Sales
 *
 * DIFERENCIAS CON CAJA MERCADILLOS:
 * - Todas las consultas filtradas por userId
 * - Arquitectura h√≠brida con sincronizadoFirebase
 * - Compatibilidad con sistema "Reloj Suizo"
 * - M√©todos espec√≠ficos para gesti√≥n de estados y saldos
 */
@Dao
interface MercadilloDao {


    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsertAll(items: List<MercadilloEntity>)

    @Query("DELETE FROM mercadillos WHERE userId = :userId")
    suspend fun borrarPorUsuario(userId: String)


    // ========== OPERACIONES B√ÅSICAS ==========

    @Upsert
    suspend fun upsert(mercadillo: MercadilloEntity)

    @Query("SELECT EXISTS(SELECT 1 FROM mercadillos WHERE userId = :uid LIMIT 1)")
    suspend fun existeAlgunoDeUsuario(uid: String): Boolean

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertMercadillo(mercadillo: MercadilloEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOrUpdate(mercadillo: MercadilloEntity)

    @Update
    suspend fun updateMercadillo(mercadillo: MercadilloEntity)

    @Delete
    suspend fun deleteMercadillo(mercadillo: MercadilloEntity)

    // ========== CONSULTAS FILTRADAS POR USUARIO ==========

    // Agregar en MercadilloDao.kt:

    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND fecha = :fecha AND activo = 1")
    suspend fun getMercadillosByUserAndFecha(userId: String, fecha: String): List<MercadilloEntity>

    /**
     * Obtiene todos los mercadillos del usuario actual ordenados por fecha DESC
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND activo = 1 ORDER BY fecha DESC, horaInicio DESC")
    fun getMercadillosByUser(userId: String): Flow<List<MercadilloEntity>>

    /**
     * Obtiene mercadillos de un mes espec√≠fico para el calendario
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND fecha LIKE :mesPattern AND activo = 1 ORDER BY fecha ASC")
    fun getMercadillosByUserAndMes(userId: String, mesPattern: String): Flow<List<MercadilloEntity>>

    /**
     * Obtiene un mercadillo espec√≠fico por ID
     */
    @Query("SELECT * FROM mercadillos WHERE idMercadillo = :id")
    suspend fun getMercadilloById(id: String): MercadilloEntity?

    /**
     * Elimina mercadillo por ID
     */
    @Query("DELETE FROM mercadillos WHERE idMercadillo = :id")
    suspend fun deleteMercadilloById(id: String)

    // ========== CONSULTAS POR ESTADO ==========

    /**
     * Obtiene mercadillos por estado espec√≠fico
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND estado = :estado AND activo = 1 ORDER BY fecha ASC")
    fun getMercadillosByUserAndEstado(userId: String, estado: Int): Flow<List<MercadilloEntity>>

    /**
     * Obtiene mercadillos programados parcialmente (sin saldo inicial)
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND saldoInicial IS NULL AND activo = 1 ORDER BY fecha ASC")
    fun getMercadillosProgramadosParciales(userId: String): Flow<List<MercadilloEntity>>

    /**
     * Obtiene mercadillos pendientes de arqueo
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND pendienteArqueo = 1 AND activo = 1 ORDER BY fecha ASC")
    fun getMercadillosPendientesArqueo(userId: String): Flow<List<MercadilloEntity>>

    /**
     * Obtiene mercadillos pendientes de asignar saldo
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND pendienteAsignarSaldo = 1 AND activo = 1 ORDER BY fecha ASC")
    fun getMercadillosPendientesAsignarSaldo(userId: String): Flow<List<MercadilloEntity>>

    // ========== CONSULTAS PARA L√ìGICA DE NEGOCIO ==========

    /**
     * Obtiene el pr√≥ximo mercadillo programado
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND fecha >= :fechaActual AND activo = 1 ORDER BY fecha ASC, horaInicio ASC LIMIT 1")
    suspend fun getProximoMercadillo(userId: String, fechaActual: String): MercadilloEntity?

    /**
     * Obtiene mercadillos de una fecha espec√≠fica
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND fecha = :fecha AND activo = 1 ORDER BY horaInicio ASC")
    suspend fun getMercadillosByFecha(userId: String, fecha: String): List<MercadilloEntity>

    /**
     * Obtiene el √∫ltimo mercadillo con saldo final para asignaci√≥n autom√°tica
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND saldoFinal IS NOT NULL AND pendienteAsignarSaldo = 1 AND activo = 1 ORDER BY fecha DESC, horaFin DESC LIMIT 1")
    suspend fun getUltimoMercadilloConSaldoFinal(userId: String): MercadilloEntity?

    /**
     * Verifica si existe un mercadillo en la misma fecha y hora
     */
    @Query("SELECT COUNT(*) > 0 FROM mercadillos WHERE userId = :userId AND fecha = :fecha AND horaInicio = :horaInicio AND activo = 1 AND idMercadillo != :excludeId")
    suspend fun existeMercadilloEnFechaHora(userId: String, fecha: String, horaInicio: String, excludeId: String = ""): Boolean

    // ========== SINCRONIZACI√ìN H√çBRIDA ==========

    /**
     * Obtiene mercadillos no sincronizados de un usuario espec√≠fico
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND sincronizadoFirebase = 0")
    suspend fun getMercadillosNoSincronizadosByUser(userId: String): List<MercadilloEntity>

    /**
     * Marca mercadillo como sincronizado
     */
    @Query("UPDATE mercadillos SET sincronizadoFirebase = 1, lastModified = :timestamp WHERE idMercadillo = :id")
    suspend fun marcarComoSincronizado(id: String, timestamp: Long = System.currentTimeMillis())

    /**
     * Marca mercadillo como no sincronizado (para cambios locales)
     */
    @Query("UPDATE mercadillos SET sincronizadoFirebase = 0 WHERE idMercadillo = :id")
    suspend fun marcarComoNoSincronizado(id: String)

    /**
     * Obtiene la versi√≥n actual de un mercadillo
     */
    @Query("SELECT version FROM mercadillos WHERE idMercadillo = :id")
    suspend fun getMercadilloVersion(id: String): Long?

    // ========== ACTUALIZACI√ìN DE ESTADOS Y SALDOS ==========

    /**
     * Asigna saldo inicial a un mercadillo
     */
    @Query("UPDATE mercadillos SET saldoInicial = :saldoInicial, estado = 2, version = version + 1, lastModified = :timestamp, sincronizadoFirebase = 0 WHERE idMercadillo = :id")
    suspend fun asignarSaldoInicial(id: String, saldoInicial: Double, timestamp: Long = System.currentTimeMillis())

    /**
     * Actualiza estado del mercadillo
     */
    @Query("UPDATE mercadillos SET estado = :nuevoEstado, version = version + 1, lastModified = :timestamp, sincronizadoFirebase = 0 WHERE idMercadillo = :id")
    suspend fun actualizarEstado(id: String, nuevoEstado: Int, timestamp: Long = System.currentTimeMillis())

    /**
     * Realiza arqueo de caja
     */
    @Query("UPDATE mercadillos SET arqueoCaja = :arqueoCaja, saldoFinal = :saldoFinal, pendienteArqueo = 0, pendienteAsignarSaldo = 1, estado = 5, version = version + 1, lastModified = :timestamp, sincronizadoFirebase = 0 WHERE idMercadillo = :id")
    suspend fun realizarArqueoCaja(id: String, arqueoCaja: Double, saldoFinal: Double, timestamp: Long = System.currentTimeMillis())

    /**
     * Marca saldo como asignado (mercadillo cerrado completo)
     */
    @Query("UPDATE mercadillos SET pendienteAsignarSaldo = 0, estado = 6, version = version + 1, lastModified = :timestamp, sincronizadoFirebase = 0 WHERE idMercadillo = :id")
    suspend fun marcarSaldoAsignado(id: String, timestamp: Long = System.currentTimeMillis())

    /**
     * Actualiza totales de ventas y gastos (calculados desde otras tablas)
     */
    @Query("UPDATE mercadillos SET totalVentas = :totalVentas, totalGastos = :totalGastos, arqueoMercadillo = :arqueoMercadillo, version = version + 1, lastModified = :timestamp, sincronizadoFirebase = 0 WHERE idMercadillo = :id")
    suspend fun actualizarTotales(id: String, totalVentas: Double, totalGastos: Double, arqueoMercadillo: Double, timestamp: Long = System.currentTimeMillis())

    /**
     * Cancela un mercadillo
     */
    @Query("UPDATE mercadillos SET estado = 7, activo = 0, version = version + 1, lastModified = :timestamp, sincronizadoFirebase = 0 WHERE idMercadillo = :id")
    suspend fun cancelarMercadillo(id: String, timestamp: Long = System.currentTimeMillis())

    // ========== UTILIDADES ==========

    /**
     * Cuenta el total de mercadillos de un usuario
     */
    @Query("SELECT COUNT(*) FROM mercadillos WHERE userId = :userId AND activo = 1")
    suspend fun getMercadilloCountByUser(userId: String): Int

    /**
     * Obtiene estad√≠sticas b√°sicas de mercadillos por estado
     */
    @Query("SELECT estado, COUNT(*) as cantidad FROM mercadillos WHERE userId = :userId AND activo = 1 GROUP BY estado")
    suspend fun getEstadisticasPorEstado(userId: String): List<EstadisticaEstado>

    // ========== MANTENIMIENTO ==========

    /**
     * Elimina mercadillos cancelados antiguos
     */
    @Query("DELETE FROM mercadillos WHERE userId = :userId AND estado = 7 AND lastModified < :limiteFecha")
    suspend fun limpiarMercadillosCanceladosAntiguos(userId: String, limiteFecha: Long)

    /**
     * Resetea sincronizaci√≥n para forzar re-sync
     */
    @Query("UPDATE mercadillos SET sincronizadoFirebase = 0 WHERE userId = :userId")
    suspend fun resetearSincronizacion(userId: String)

    // AGREGAR ESTA FUNCI√ìN AL MercadilloDao.kt

    /**
     * Obtiene todos los mercadillos desde una fecha espec√≠fica en adelante
     * Ordenados por fecha ASC y luego por hora de inicio ASC
     */
    @Query("""
    SELECT * FROM mercadillos 
    WHERE userId = :userId 
    AND fecha >= :fechaActual 
    AND activo = 1 
    ORDER BY fecha ASC, horaInicio ASC
""")
    suspend fun getMercadillosDesdeHoy(userId: String, fechaActual: String): List<MercadilloEntity>

}




/**
 * Data class para estad√≠sticas por estado
 */
data class EstadisticaEstado(
    val estado: Int,
    val cantidad: Int
)

// app/src/main/java/es/nuskysoftware/marketsales/data/local/database/AppDatabase.kt
package es.nuskysoftware.marketsales.data.local.database

import android.content.Context
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase
import com.google.firebase.BuildConfig

import es.nuskysoftware.marketsales.data.local.dao.ArticuloDao
import es.nuskysoftware.marketsales.data.local.dao.CategoriaDao
import es.nuskysoftware.marketsales.data.local.dao.ConfiguracionDao
import es.nuskysoftware.marketsales.data.local.dao.LineasVentaDao
import es.nuskysoftware.marketsales.data.local.dao.MercadilloDao
import es.nuskysoftware.marketsales.data.local.dao.RecibosDao
import es.nuskysoftware.marketsales.data.local.dao.UserDao
import es.nuskysoftware.marketsales.data.local.entity.ArticuloEntity
import es.nuskysoftware.marketsales.data.local.entity.CategoriaEntity
import es.nuskysoftware.marketsales.data.local.entity.ConfiguracionEntity
import es.nuskysoftware.marketsales.data.local.entity.LineaVentaEntity
import es.nuskysoftware.marketsales.data.local.entity.MercadilloEntity
import es.nuskysoftware.marketsales.data.local.entity.ReciboEntity
import es.nuskysoftware.marketsales.data.local.entity.UserEntity

@Database(
    entities = [
        ConfiguracionEntity::class,
        MercadilloEntity::class,
        UserEntity::class,
        CategoriaEntity::class,
        ArticuloEntity::class,
        ReciboEntity::class,
        LineaVentaEntity::class
    ],
    version = 8, // ‚¨ÜÔ∏è nunca bajar versi√≥n; antes estaba en 7 y la BD del dispositivo en 8
    exportSchema = false
)
abstract class AppDatabase : RoomDatabase() {

    abstract fun configuracionDao(): ConfiguracionDao
    abstract fun mercadilloDao(): MercadilloDao
    abstract fun userDao(): UserDao
    abstract fun categoriaDao(): CategoriaDao
    abstract fun articuloDao(): ArticuloDao
    abstract fun recibosDao(): RecibosDao
    abstract fun lineasVentaDao(): LineasVentaDao

    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null

        // ‚ûï Migraci√≥n NO-OP de 7 ‚Üí 8 (ajusta aqu√≠ si realmente cambiaste esquema)
        private val MIGRATION_7_8 = object : Migration(7, 8) {
            override fun migrate(db: SupportSQLiteDatabase) {
                // No-op: si entre 7 y 8 no hubo cambios de esquema efectivos.
                // Si a√±adiste columnas/tablas de verdad, pon aqu√≠ tus ALTER TABLE ‚Ä¶ ADD COLUMN ‚Ä¶ DEFAULT ‚Ä¶
                // Ejemplo (com√©ntalo/aj√∫stalo si aplica):
                // db.execSQL("ALTER TABLE configuracion ADD COLUMN usuarioLogueado TEXT NOT NULL DEFAULT 'usuario_default'")
            }
        }

        fun getDatabase(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {

                val builder = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "marketsales_database_v10"
                )
                    // ‚úÖ Registra tus migraciones conocidas
                    .addMigrations(
                        Migrations.M6_TO_M7, // la que ya usabas
                        MIGRATION_7_8        // nueva para evitar el crash 8‚Üí7
                    )

                // üîß Solo en DEBUG: si por error instalas un APK m√°s viejo (downgrade), evita el crash
                if (BuildConfig.DEBUG) {
                    builder.fallbackToDestructiveMigrationOnDowngrade()
                }

                val instance = builder.build()
                INSTANCE = instance
                instance
            }
        }

        fun clearInstance() {
            INSTANCE = null
        }
    }
}

// app/src/main/java/es/nuskysoftware/marketsales/data/local/entity/MercadilloEntity.kt
package es.nuskysoftware.marketsales.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.UUID

/**
 * MercadilloEntity V11 - Market Sales
 *
 * ARQUITECTURA H√çBRIDA "RELOJ SUIZO":
 * - Compatible con sincronizaci√≥n Firebase + Room offline-first
 * - Campo userId para vincular con usuario
 * - Estados autom√°ticos seg√∫n l√≥gica de negocio
 * - Gesti√≥n completa de saldos y arqueos
 * - Campos calculados almacenados en BD
 */
@Entity(tableName = "mercadillos")
data class MercadilloEntity(
    @PrimaryKey
    val idMercadillo: String = UUID.randomUUID().toString(),

    // ‚úÖ Campo para vincular con usuario
    val userId: String = "",

    // ========== DATOS B√ÅSICOS (M√çNIMOS REQUERIDOS) ==========
    val fecha: String = "", // Formato "dd-MM-yyyy"
    val lugar: String = "",
    val organizador: String = "",

    // ========== CONFIGURACI√ìN DEL MERCADILLO ==========
    val esGratis: Boolean = true,
    val importeSuscripcion: Double = 0.0, // Solo si esGratis = false
    val requiereMesa: Boolean = true,
    val requiereCarpa: Boolean = true,
    val hayPuntoLuz: Boolean = false,
    val horaInicio: String = "09:00", // Formato "HH:mm"
    val horaFin: String = "14:00", // Formato "HH:mm"

    // ========== ESTADOS Y CONTROL ==========
    val estado: Int = 1, // Seg√∫n EstadosMercadillo.Estado.codigo (autom√°tico)
    val pendienteArqueo: Boolean = false,
    val pendienteAsignarSaldo: Boolean = false,

    // ========== GESTI√ìN FINANCIERA ==========
    // null en saldoInicial = PROGRAMADO_PARCIAL, asignado = PROGRAMADO_TOTAL
    val saldoInicial: Double? = null,
    val saldoFinal: Double? = null,

    // Campos calculados pero almacenados:
    val arqueoCaja: Double? = null, // saldoInicial + ventasEfectivo - gastosEfectivo
    val totalVentas: Double = 0.0, // Ventas en cualquier forma de pago (calculado desde tabla ventas)
    val totalGastos: Double = 0.0, // Gastos en cualquier forma de pago (calculado desde tabla gastos)
    val arqueoMercadillo: Double? = null, // saldoInicial + totalVentas - totalGastos - importeSuscripcion

    // ========== CAMPOS DE CONTROL ==========
    val activo: Boolean = true,

    // ========== CAMPOS SINCRONIZACI√ìN H√çBRIDA ==========
    val version: Long = 1,
    val lastModified: Long = System.currentTimeMillis(),
    val sincronizadoFirebase: Boolean = false
) {
    // Constructor vac√≠o para Firestore
    constructor() : this(
        idMercadillo = "",
        userId = "",
        fecha = "",
        lugar = "",
        organizador = "",
        esGratis = true,
        importeSuscripcion = 0.0,
        requiereMesa = true,
        requiereCarpa = true,
        hayPuntoLuz = false,
        horaInicio = "09:00",
        horaFin = "14:00",
        estado = 1,
        pendienteArqueo = false,
        pendienteAsignarSaldo = false,
        saldoInicial = null,
        saldoFinal = null,
        arqueoCaja = null,
        totalVentas = 0.0,
        totalGastos = 0.0,
        arqueoMercadillo = null,
        activo = true,
        version = 1,
        lastModified = System.currentTimeMillis(),
        sincronizadoFirebase = false
    )
}

// app/src/main/java/es/nuskysoftware/marketsales/data/repository/MercadilloRepository.kt
package es.nuskysoftware.marketsales.data.repository

import android.content.Context
import android.util.Log
import com.google.firebase.firestore.FirebaseFirestore
import es.nuskysoftware.marketsales.data.local.dao.MercadilloDao
import es.nuskysoftware.marketsales.data.local.dao.EstadisticaEstado
import es.nuskysoftware.marketsales.data.local.database.AppDatabase
import es.nuskysoftware.marketsales.data.local.entity.MercadilloEntity
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.ConnectivityObserver
import es.nuskysoftware.marketsales.utils.EstadosMercadillo
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.flatMapLatest
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.tasks.await
import java.text.SimpleDateFormat
import java.util.*

/**
 * MercadilloRepository V11 - Market Sales
 *
 * ARQUITECTURA H√çBRIDA "RELOJ SUIZO":
 * - Local First: Toda operaci√≥n se ejecuta primero en Room
 * - Sync When Possible: Sincronizaci√≥n autom√°tica cuando hay conexi√≥n
 * - Never Block UI: La interfaz nunca espera operaciones de red
 * - Graceful Degradation: Funcionamiento completo offline
 * - Estados autom√°ticos: Actualizaci√≥n autom√°tica de estados seg√∫n l√≥gica de negocio
 * - Filtrado por usuario: Cada usuario solo ve sus datos
 */
class MercadilloRepository(
    context: Context
) {
    private val mercadilloDao: MercadilloDao = AppDatabase.getDatabase(context).mercadilloDao()
    private val firestore = FirebaseFirestore.getInstance()
    private val connectivityObserver = ConnectivityObserver(context)
    private val repositoryScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

    // Formateadores de fecha
    private val dateFormat = SimpleDateFormat("dd-MM-yyyy", Locale.getDefault())
    private val timeFormat = SimpleDateFormat("HH:mm", Locale.getDefault())

    companion object {
        private const val TAG = "MercadilloRepository"
    }

    init {
        // Sincronizaci√≥n autom√°tica cuando volvemos online
        repositoryScope.launch {
            connectivityObserver.isConnected.collect { online ->
                if (online) {
                    val userId = ConfigurationManager.getCurrentUserId()
                    if (userId != null) {
                        sincronizarMercadillosNoSincronizados(userId)
                        actualizarEstadosAutomaticos(userId)
                    }
                }
            }
        }

        // Actualizaci√≥n peri√≥dica de estados (cada 5 minutos)
        repositoryScope.launch {
            while (true) {
                delay(5 * 60 * 1000) // 5 minutos
                val userId = ConfigurationManager.getCurrentUserId()
                if (userId != null) {
                    actualizarEstadosAutomaticos(userId)
                }
            }
        }
    }

    /**
     * Obtiene el pr√≥ximo mercadillo para un usuario espec√≠fico
     */
    suspend fun getProximoMercadilloPorUsuario(userId: String, fechaActual: String): MercadilloEntity? = withContext(Dispatchers.IO) {
        Log.d(TAG, "üîç Buscando pr√≥ximo mercadillo para usuario: $userId en fecha: $fechaActual")
        return@withContext mercadilloDao.getProximoMercadillo(userId, fechaActual)
    }

    /**
     * Obtiene todos los mercadillos del usuario actual - VERSION REACTIVA
     */
    fun getMercadillosUsuarioActual(): Flow<List<MercadilloEntity>> {
        return ConfigurationManager.usuarioLogueado.flatMapLatest { userId ->
            val effectiveUserId = when {
                userId == null || userId == "usuario_default" -> "usuario_default"
                else -> userId
            }
            Log.d(TAG, "üîÑ Usuario cambi√≥ a: $effectiveUserId - Recargando mercadillos")
            mercadilloDao.getMercadillosByUser(effectiveUserId)
        }
    }

    /**
     * Obtiene mercadillos de un mes espec√≠fico - VERSION REACTIVA
     */
    fun getMercadillosPorMes(ano: Int, mes: Int): Flow<List<MercadilloEntity>> {
        return ConfigurationManager.usuarioLogueado.flatMapLatest { userId ->
            val effectiveUserId = when {
                userId == null || userId == "usuario_default" -> "usuario_default"
                else -> userId
            }
            Log.d(TAG, "üîÑ Mercadillos mes $mes/$ano para usuario: $effectiveUserId")
            val mesPattern = "${String.format("%02d", mes)}-$ano"
            mercadilloDao.getMercadillosByUserAndMes(effectiveUserId, "%$mesPattern")
        }
    }

    /**
     * Crea un nuevo mercadillo - PATR√ìN H√çBRIDO
     */
    suspend fun crearMercadillo(
        fecha: String,
        lugar: String,
        organizador: String,
        esGratis: Boolean = true,
        importeSuscripcion: Double = 0.0,
        requiereMesa: Boolean = true,
        requiereCarpa: Boolean = true,
        hayPuntoLuz: Boolean = false,
        horaInicio: String = "09:00",
        horaFin: String = "14:00",
        saldoInicial: Double? = null // ‚úÖ NUEVO PAR√ÅMETRO OPCIONAL
    ): String = withContext(Dispatchers.IO) {
        val userId = ConfigurationManager.getCurrentUserId()
            ?: throw IllegalStateException("No se puede crear mercadillo sin usuario")

        Log.d(TAG, "üîÑ Creando mercadillo para usuario: $userId")

        // Validar conflictos de fecha/hora
        if (mercadilloDao.existeMercadilloEnFechaHora(userId, fecha, horaInicio)) {
            throw IllegalArgumentException("Ya existe un mercadillo en esa fecha y hora")
        }

        val nuevoMercadillo = MercadilloEntity(
            userId = userId,
            fecha = fecha,
            lugar = lugar,
            organizador = organizador,
            esGratis = esGratis,
            importeSuscripcion = if (!esGratis) importeSuscripcion else 0.0,
            requiereMesa = requiereMesa,
            requiereCarpa = requiereCarpa,
            hayPuntoLuz = hayPuntoLuz,
            horaInicio = horaInicio,
            horaFin = horaFin,
            saldoInicial = saldoInicial, // ‚úÖ ASIGNAR SALDO INICIAL
            estado = if (saldoInicial != null) {
                EstadosMercadillo.Estado.PROGRAMADO_TOTAL.codigo // Con saldo = TOTAL
            } else {
                EstadosMercadillo.Estado.PROGRAMADO_PARCIAL.codigo // Sin saldo = PARCIAL
            },
            sincronizadoFirebase = false
        )

        try {
            // 1. GUARDAR EN ROOM PRIMERO (respuesta inmediata)
            mercadilloDao.insertMercadillo(nuevoMercadillo)
            Log.d(TAG, "‚úÖ Mercadillo guardado en Room: $lugar - $fecha${if (saldoInicial != null) " (Saldo: ‚Ç¨$saldoInicial)" else ""}")

            // 2. INTENTAR SINCRONIZAR CON FIREBASE
            sincronizarMercadilloConFirebase(nuevoMercadillo)

            return@withContext nuevoMercadillo.idMercadillo

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error creando mercadillo", e)
            throw e
        }
    }

    /**
     * Actualiza un mercadillo existente - PATR√ìN H√çBRIDO
     */
    suspend fun actualizarMercadillo(mercadillo: MercadilloEntity): Boolean = withContext(Dispatchers.IO) {
        try {
            val mercadilloActualizado = mercadillo.copy(
                version = mercadillo.version + 1,
                lastModified = System.currentTimeMillis(),
                sincronizadoFirebase = false
            )

            // 1. ACTUALIZAR EN ROOM PRIMERO
            mercadilloDao.updateMercadillo(mercadilloActualizado)
            Log.d(TAG, "‚úÖ Mercadillo actualizado en Room: ${mercadilloActualizado.lugar}")

            // 2. INTENTAR SINCRONIZAR CON FIREBASE
            sincronizarMercadilloConFirebase(mercadilloActualizado)

            true
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error actualizando mercadillo", e)
            false
        }
    }

    /**
     * Elimina un mercadillo - PATR√ìN H√çBRIDO
     */
    suspend fun eliminarMercadillo(mercadillo: MercadilloEntity): Boolean = withContext(Dispatchers.IO) {
        try {
            // 1. ELIMINAR DE ROOM PRIMERO
            mercadilloDao.deleteMercadillo(mercadillo)
            Log.d(TAG, "‚úÖ Mercadillo eliminado de Room: ${mercadillo.lugar}")

            // 2. INTENTAR ELIMINAR DE FIREBASE
            eliminarMercadilloDeFirebase(mercadillo.idMercadillo)

            true
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error eliminando mercadillo", e)
            false
        }
    }

    /**
     * Obtiene mercadillo por ID
     */
    suspend fun getMercadilloById(id: String): MercadilloEntity? = withContext(Dispatchers.IO) {
        mercadilloDao.getMercadilloById(id)
    }

    // ========== GESTI√ìN DE SALDOS ==========

    /**
     * Asigna saldo inicial a un mercadillo (manual o autom√°tico)
     */
    suspend fun asignarSaldoInicial(
        mercadilloId: String,
        saldoInicial: Double,
        esAsignacionAutomatica: Boolean = false
    ): Boolean = withContext(Dispatchers.IO) {
        try {
            mercadilloDao.asignarSaldoInicial(mercadilloId, saldoInicial)

            if (esAsignacionAutomatica) {
                Log.d(TAG, "‚úÖ Saldo inicial asignado autom√°ticamente: ‚Ç¨$saldoInicial")
            } else {
                Log.d(TAG, "‚úÖ Saldo inicial asignado manualmente: ‚Ç¨$saldoInicial")
            }

            // Sincronizar cambio
            val mercadilloActualizado = mercadilloDao.getMercadilloById(mercadilloId)
            mercadilloActualizado?.let { sincronizarMercadilloConFirebase(it) }

            true
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error asignando saldo inicial", e)
            false
        }
    }

    /**
     * Asigna autom√°ticamente saldo inicial desde el √∫ltimo mercadillo cerrado
     */
    suspend fun asignarSaldoInicialAutomatico(mercadilloId: String): Boolean = withContext(Dispatchers.IO) {
        try {
            val userId = ConfigurationManager.getCurrentUserId() ?: return@withContext false

            val ultimoMercadilloConSaldo = mercadilloDao.getUltimoMercadilloConSaldoFinal(userId)

            if (ultimoMercadilloConSaldo?.saldoFinal != null) {
                val exito = asignarSaldoInicial(
                    mercadilloId = mercadilloId,
                    saldoInicial = ultimoMercadilloConSaldo.saldoFinal,
                    esAsignacionAutomatica = true
                )

                if (exito) {
                    // Marcar el saldo del mercadillo anterior como asignado
                    mercadilloDao.marcarSaldoAsignado(ultimoMercadilloConSaldo.idMercadillo)
                }

                return@withContext exito
            } else {
                Log.d(TAG, "No hay mercadillos anteriores con saldo final para asignar")
                return@withContext false
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error en asignaci√≥n autom√°tica de saldo", e)
            false
        }
    }

    /**
     * Realiza el arqueo de caja de un mercadillo
     */
    suspend fun realizarArqueoCaja(
        mercadilloId: String,
        saldoFinal: Double,
        ventasEfectivo: Double,
        gastosEfectivo: Double
    ): Boolean = withContext(Dispatchers.IO) {
        try {
            val mercadillo = mercadilloDao.getMercadilloById(mercadilloId) ?: return@withContext false
            val saldoInicial = mercadillo.saldoInicial ?: return@withContext false

            val arqueoCaja = saldoInicial + ventasEfectivo - gastosEfectivo

            mercadilloDao.realizarArqueoCaja(mercadilloId, arqueoCaja, saldoFinal)

            Log.d(TAG, "‚úÖ Arqueo de caja realizado: ‚Ç¨$arqueoCaja")

            // Sincronizar cambio
            val mercadilloActualizado = mercadilloDao.getMercadilloById(mercadilloId)
            mercadilloActualizado?.let { sincronizarMercadilloConFirebase(it) }

            true
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error realizando arqueo de caja", e)
            false
        }
    }

    // ========== GESTI√ìN DE ESTADOS AUTOM√ÅTICA ==========

    /**
     * Actualiza autom√°ticamente los estados de todos los mercadillos del usuario
     */
    suspend fun actualizarEstadosAutomaticos(userId: String) {
        try {
            val mercadillos = mercadilloDao.getMercadillosByUser(userId).first()
            val fechaActual = dateFormat.format(Date())
            val horaActual = timeFormat.format(Date())

            Log.d(TAG, "üîÑ Actualizando estados autom√°ticos para ${mercadillos.size} mercadillos")

            mercadillos.forEach { mercadillo ->
                if (mercadillo.estado != EstadosMercadillo.Estado.CANCELADO.codigo) {
                    val estadoCalculado = EstadosMercadillo.calcularEstadoAutomatico(
                        saldoInicial = mercadillo.saldoInicial,
                        fecha = mercadillo.fecha,
                        horaFin = mercadillo.horaFin,
                        arqueoCaja = mercadillo.arqueoCaja,
                        pendienteAsignarSaldo = mercadillo.pendienteAsignarSaldo,
                        fechaActual = fechaActual,
                        horaActual = horaActual
                    )

                    if (estadoCalculado.codigo != mercadillo.estado) {
                        mercadilloDao.actualizarEstado(mercadillo.idMercadillo, estadoCalculado.codigo)
                        Log.d(TAG, "Estado actualizado: ${mercadillo.lugar} -> ${estadoCalculado.descripcion}")

                        // Marcar para sincronizaci√≥n
                        val mercadilloActualizado = mercadilloDao.getMercadilloById(mercadillo.idMercadillo)
                        mercadilloActualizado?.let { sincronizarMercadilloConFirebase(it) }
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error actualizando estados autom√°ticos", e)
        }
    }

    /**
     * Cancela un mercadillo (solo si no tiene ventas)
     */
    suspend fun cancelarMercadillo(
        mercadilloId: String,
        tieneVentas: Boolean = false
    ): Boolean = withContext(Dispatchers.IO) {
        try {
            val mercadillo = mercadilloDao.getMercadilloById(mercadilloId) ?: return@withContext false
            val estado = EstadosMercadillo.Estado.fromCodigo(mercadillo.estado) ?: return@withContext false

            if (!EstadosMercadillo.puedeSerCancelado(estado, tieneVentas)) {
                Log.w(TAG, "No se puede cancelar el mercadillo: tiene ventas o estado no v√°lido")
                return@withContext false
            }

            // Si tiene saldo inicial, se deber√≠a reasignar a otro mercadillo
            // (esta l√≥gica se implementar√≠a en el ViewModel/UI)

            mercadilloDao.cancelarMercadillo(mercadilloId)
            Log.d(TAG, "‚úÖ Mercadillo cancelado: ${mercadillo.lugar}")

            // Sincronizar cambio
            val mercadilloActualizado = mercadilloDao.getMercadilloById(mercadilloId)
            mercadilloActualizado?.let { sincronizarMercadilloConFirebase(it) }

            true
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error cancelando mercadillo", e)
            false
        }
    }

    // ========== CONSULTAS ESPEC√çFICAS ==========

    /**
     * Obtiene el pr√≥ximo mercadillo - VERSION REACTIVA
     */
    suspend fun getProximoMercadillo(): MercadilloEntity? = withContext(Dispatchers.IO) {
        val userId = ConfigurationManager.getCurrentUserId() ?: "usuario_default"
        Log.d(TAG, "üîÑ Obteniendo pr√≥ximo mercadillo para usuario: $userId")
        val fechaActual = dateFormat.format(Date())
        mercadilloDao.getProximoMercadillo(userId, fechaActual)
    }

    /**
     * Obtiene mercadillos que requieren atenci√≥n - VERSION REACTIVA
     */
    fun getMercadillosRequierenAtencion(): Flow<List<MercadilloEntity>> {
        return ConfigurationManager.usuarioLogueado.flatMapLatest { userId ->
            Log.d(TAG, "üîÑ Usuario cambi√≥: $userId - Recargando mercadillos que requieren atenci√≥n")
            if (userId != null && userId != "usuario_default") {
                mercadilloDao.getMercadillosPendientesArqueo(userId)
            } else {
                flowOf(emptyList())
            }
        }
    }

    /**
     * Obtiene todos los mercadillos desde hoy en adelante para un usuario
     */
    suspend fun getMercadillosDesdeHoy(userId: String): List<MercadilloEntity> = withContext(Dispatchers.IO) {
        try {
            // Obtener fecha actual en formato dd-MM-yyyy
            val fechaActual = dateFormat.format(Date())

            // Usar la nueva consulta del DAO
            val mercadillos = mercadilloDao.getMercadillosDesdeHoy(userId, fechaActual)

            Log.d(TAG, "üìÖ Encontrados ${mercadillos.size} mercadillos desde $fechaActual para usuario $userId")

            return@withContext mercadillos

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error obteniendo mercadillos desde hoy", e)
            return@withContext emptyList()
        }
    }

    /**
     * Obtiene estad√≠sticas de mercadillos por estado
     */
    suspend fun getEstadisticasPorEstado(): Map<EstadosMercadillo.Estado, Int> = withContext(Dispatchers.IO) {
        val userId = ConfigurationManager.getCurrentUserId() ?: return@withContext emptyMap()

        try {
            val estadisticas = mercadilloDao.getEstadisticasPorEstado(userId)
            return@withContext estadisticas.associate { estadisticaEstado ->
                val estado = EstadosMercadillo.Estado.fromCodigo(estadisticaEstado.estado)
                    ?: EstadosMercadillo.Estado.PROGRAMADO_PARCIAL
                estado to estadisticaEstado.cantidad
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error obteniendo estad√≠sticas", e)
            return@withContext emptyMap()
        }
    }


    // ========== ESTRATEGIA H√çBRIDA INTELIGENTE ==========

    /**
     * Obtiene datos h√≠bridos: combina lo mejor de Room y Firebase
     */
    suspend fun getHybridMercadillos(userId: String): List<MercadilloEntity> = withContext(Dispatchers.IO) {
        try {
            // 1. Verificar cambios pendientes en Room
            val mercadillosNoSincronizados = mercadilloDao.getMercadillosNoSincronizadosByUser(userId)

            if (mercadillosNoSincronizados.isNotEmpty()) {
                // HAY CAMBIOS PENDIENTES ‚Üí Room es fuente de verdad
                Log.d(TAG, "üì± Usando Room (${mercadillosNoSincronizados.size} cambios pendientes)")
                return@withContext mercadilloDao.getMercadillosByUser(userId).first()
            } else {
                // NO HAY CAMBIOS PENDIENTES ‚Üí Intentar Firebase
                Log.d(TAG, "‚òÅÔ∏è Intentando Firebase (sin cambios pendientes)")

                if (connectivityObserver.isConnected.first()) {
                    try {
                        val firebaseMercadillos = descargarMercadillosDesdeFirebase(userId)
                        if (firebaseMercadillos.isNotEmpty()) {
                            // Actualizar Room con datos frescos
                            firebaseMercadillos.forEach { mercadillo ->
                                mercadilloDao.insertOrUpdate(mercadillo.copy(sincronizadoFirebase = true))
                            }
                            Log.d(TAG, "‚úÖ Datos frescos de Firebase aplicados")
                        }
                    } catch (e: Exception) {
                        Log.w(TAG, "‚ö†Ô∏è Error con Firebase, usando Room como fallback", e)
                    }
                }

                // Devolver datos de Room (actualizados o fallback)
                return@withContext mercadilloDao.getMercadillosByUser(userId).first()
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error en estrategia h√≠brida", e)
            // Fallback total a Room
            return@withContext mercadilloDao.getMercadillosByUser(userId).first()
        }
    }

    // ========== SINCRONIZACI√ìN CON FIREBASE ==========

    /**
     * Sincroniza un mercadillo espec√≠fico con Firebase
     */
    private suspend fun sincronizarMercadilloConFirebase(mercadillo: MercadilloEntity) {
        try {
            if (!connectivityObserver.isConnected.first()) {
                Log.d(TAG, "‚ö†Ô∏è Sin conexi√≥n, mercadillo quedar√° pendiente de sincronizaci√≥n")
                return
            }

            val datos = mapOf(
                "idMercadillo" to mercadillo.idMercadillo,
                "userId" to mercadillo.userId,
                "fecha" to mercadillo.fecha,
                "lugar" to mercadillo.lugar,
                "organizador" to mercadillo.organizador,
                "esGratis" to mercadillo.esGratis,
                "importeSuscripcion" to mercadillo.importeSuscripcion,
                "requiereMesa" to mercadillo.requiereMesa,
                "requiereCarpa" to mercadillo.requiereCarpa,
                "hayPuntoLuz" to mercadillo.hayPuntoLuz,
                "horaInicio" to mercadillo.horaInicio,
                "horaFin" to mercadillo.horaFin,
                "estado" to mercadillo.estado,
                "pendienteArqueo" to mercadillo.pendienteArqueo,
                "pendienteAsignarSaldo" to mercadillo.pendienteAsignarSaldo,
                "saldoInicial" to mercadillo.saldoInicial,
                "saldoFinal" to mercadillo.saldoFinal,
                "arqueoCaja" to mercadillo.arqueoCaja,
                "totalVentas" to mercadillo.totalVentas,
                "totalGastos" to mercadillo.totalGastos,
                "arqueoMercadillo" to mercadillo.arqueoMercadillo,
                "activo" to mercadillo.activo,
                "version" to mercadillo.version,
                "lastModified" to mercadillo.lastModified,
                "fechaSync" to System.currentTimeMillis()
            )

            firestore.collection("mercadillos")
                .document(mercadillo.idMercadillo)
                .set(datos)
                .await()

            // Marcar como sincronizado en Room
            mercadilloDao.marcarComoSincronizado(mercadillo.idMercadillo)
            Log.d(TAG, "‚òÅÔ∏è Mercadillo sincronizado con Firebase: ${mercadillo.lugar}")

        } catch (e: Exception) {
            Log.w(TAG, "‚ö†Ô∏è Error sincronizando con Firebase: ${mercadillo.lugar}", e)
            // El mercadillo queda marcado como no sincronizado para reintento posterior
        }
    }

    /**
     * Elimina mercadillo de Firebase
     */
    private suspend fun eliminarMercadilloDeFirebase(mercadilloId: String) {
        try {
            if (connectivityObserver.isConnected.first()) {
                firestore.collection("mercadillos")
                    .document(mercadilloId)
                    .delete()
                    .await()
                Log.d(TAG, "‚òÅÔ∏è Mercadillo eliminado de Firebase: $mercadilloId")
            }
        } catch (e: Exception) {
            Log.w(TAG, "‚ö†Ô∏è Error eliminando de Firebase: $mercadilloId", e)
        }
    }

    /**
     * Sincroniza mercadillos no sincronizados cuando hay conexi√≥n
     */
    private suspend fun sincronizarMercadillosNoSincronizados(userId: String) {
        try {
            val pendientes = mercadilloDao.getMercadillosNoSincronizadosByUser(userId)
            Log.d(TAG, "üîÑ Sincronizando ${pendientes.size} mercadillos pendientes")

            pendientes.forEach { mercadillo ->
                sincronizarMercadilloConFirebase(mercadillo)
                delay(100) // Evitar saturar Firebase
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error sincronizando pendientes", e)
        }
    }

    /**
     * Descarga mercadillos desde Firebase
     */
    private suspend fun descargarMercadillosDesdeFirebase(userId: String): List<MercadilloEntity> {
        return try {
            val snapshot = firestore.collection("mercadillos")
                .whereEqualTo("userId", userId)
                .whereEqualTo("activo", true)
                .get()
                .await()

            val mercadillos = snapshot.documents.mapNotNull { doc ->
                try {
                    val data = doc.data ?: return@mapNotNull null
                    MercadilloEntity(
                        idMercadillo = data["idMercadillo"] as? String ?: "",
                        userId = data["userId"] as? String ?: "",
                        fecha = data["fecha"] as? String ?: "",
                        lugar = data["lugar"] as? String ?: "",
                        organizador = data["organizador"] as? String ?: "",
                        esGratis = data["esGratis"] as? Boolean ?: true,
                        importeSuscripcion = (data["importeSuscripcion"] as? Number)?.toDouble() ?: 0.0,
                        requiereMesa = data["requiereMesa"] as? Boolean ?: true,
                        requiereCarpa = data["requiereCarpa"] as? Boolean ?: true,
                        hayPuntoLuz = data["hayPuntoLuz"] as? Boolean ?: false,
                        horaInicio = data["horaInicio"] as? String ?: "09:00",
                        horaFin = data["horaFin"] as? String ?: "14:00",
                        estado = (data["estado"] as? Long)?.toInt() ?: 1,
                        pendienteArqueo = data["pendienteArqueo"] as? Boolean ?: false,
                        pendienteAsignarSaldo = data["pendienteAsignarSaldo"] as? Boolean ?: false,
                        saldoInicial = (data["saldoInicial"] as? Number)?.toDouble(),
                        saldoFinal = (data["saldoFinal"] as? Number)?.toDouble(),
                        arqueoCaja = (data["arqueoCaja"] as? Number)?.toDouble(),
                        totalVentas = (data["totalVentas"] as? Number)?.toDouble() ?: 0.0,
                        totalGastos = (data["totalGastos"] as? Number)?.toDouble() ?: 0.0,
                        arqueoMercadillo = (data["arqueoMercadillo"] as? Number)?.toDouble(),
                        activo = data["activo"] as? Boolean ?: true,
                        version = data["version"] as? Long ?: 1L,
                        lastModified = data["lastModified"] as? Long ?: System.currentTimeMillis(),
                        sincronizadoFirebase = true
                    )
                } catch (e: Exception) {
                    Log.w(TAG, "‚ö†Ô∏è Error parseando mercadillo de Firebase", e)
                    null
                }
            }

            Log.d(TAG, "‚òÅÔ∏è Descargados ${mercadillos.size} mercadillos de Firebase")
            mercadillos

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error descargando de Firebase", e)
            emptyList()
        }
    }

    // ========== SINCRONIZACI√ìN SIN ESTADOS AUTOM√ÅTICOS ==========

    /**
     * Sincroniza SIN recalcular estados autom√°ticos
     */
    suspend fun sincronizarSinEstadosAutomaticos(): Boolean = withContext(Dispatchers.IO) {
        try {
            val userId = ConfigurationManager.getCurrentUserId() ?: return@withContext false

            // 1. Sincronizar pendientes
            sincronizarMercadillosNoSincronizados(userId)

            // 2. Descargar datos frescos de Firebase
            getHybridMercadillos(userId)

            // 3. NO llamar a actualizarEstadosAutomaticos(userId)

            Log.d(TAG, "‚úÖ Sincronizaci√≥n completada SIN estados autom√°ticos")
            true
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error en sincronizaci√≥n sin estados autom√°ticos", e)
            false
        }
    }

    // ========== UTILIDADES ==========

    /**
     * Fuerza sincronizaci√≥n completa
     */
    suspend fun forzarSincronizacion(): Boolean = withContext(Dispatchers.IO) {
        try {
            val userId = ConfigurationManager.getCurrentUserId() ?: return@withContext false

            sincronizarMercadillosNoSincronizados(userId)
            getHybridMercadillos(userId) // Esto descargar√° datos frescos de Firebase
            actualizarEstadosAutomaticos(userId) // Actualizar estados tras sincronizaci√≥n

            true
        } catch (e: Exception) {
            false
        }
    }

    // Agregar en MercadilloRepository.kt:

    /**
     * Obtiene mercadillos de una fecha espec√≠fica para validaciones
     */
    suspend fun getMercadillosPorFecha(userId: String, fecha: String): List<MercadilloEntity> = withContext(Dispatchers.IO) {
        return@withContext mercadilloDao.getMercadillosByUserAndFecha(userId, fecha)
    }
}

// app/src/main/java/es/nuskysoftware/marketsales/ui/components/BottomBarMercadillo.kt
package es.nuskysoftware.marketsales.ui.components

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import es.nuskysoftware.marketsales.R
import es.nuskysoftware.marketsales.data.local.entity.MercadilloEntity
import es.nuskysoftware.marketsales.utils.StringResourceManager

/**
 * BottomBar para operaciones con mercadillos activos
 * Solo se muestra cuando hay mercadillos en estado EN_CURSO
 */
@Composable
fun BottomBarMercadillo(
    mercadilloActivo: MercadilloEntity?,
    onVentasClick: () -> Unit,
    onGastosClick: () -> Unit,
    onResumenClick: () -> Unit,
    onCambiarMercadillo: () -> Unit,
    currentLanguage: String,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .padding(8.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 8.dp),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surface
        ),
        shape = RoundedCornerShape(16.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(12.dp)
        ) {
            // Header con informaci√≥n del mercadillo activo
            mercadilloActivo?.let { mercadillo ->
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Column(modifier = Modifier.weight(1f)) {
                        Text(
                            text = "Mercadillo Activo:",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                        )
                        Text(
                            text = mercadillo.lugar,
                            style = MaterialTheme.typography.bodyMedium,
                            fontWeight = FontWeight.Bold,
                            color = MaterialTheme.colorScheme.primary
                        )
                    }

                    // Bot√≥n para cambiar mercadillo
                    TextButton(
                        onClick = onCambiarMercadillo,
                        modifier = Modifier.padding(start = 8.dp)
                    ) {
                        Text(
                            text = "Cambiar",
                            fontSize = 12.sp,
                            color = MaterialTheme.colorScheme.primary
                        )
                    }
                }

                Spacer(modifier = Modifier.height(12.dp))
            }

            // Botones de acciones
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                // Bot√≥n Ventas
                BottomBarButton(
                    icon = R.drawable.ic_ventas, // Nombre temporal del icono
                    text = "Ventas",
                    onClick = onVentasClick,
                    color = Color(0xFF4CAF50), // Verde
                    modifier = Modifier.weight(1f)
                )

                Spacer(modifier = Modifier.width(8.dp))

                // Bot√≥n Gastos
                BottomBarButton(
                    icon = R.drawable.ic_gastos, // Nombre temporal del icono
                    text = "Gastos",
                    onClick = onGastosClick,
                    color = Color(0xFFF44336), // Rojo
                    modifier = Modifier.weight(1f)
                )

                Spacer(modifier = Modifier.width(8.dp))

                // Bot√≥n Resumen
                BottomBarButton(
                    icon = R.drawable.ic_resumen, // Nombre temporal del icono
                    text = "Resumen",
                    onClick = onResumenClick,
                    color = Color(0xFF2196F3), // Azul
                    modifier = Modifier.weight(1f)
                )
            }
        }
    }
}

/**
 * Bot√≥n individual del BottomBar
 */
@Composable
private fun BottomBarButton(
    icon: Int,
    text: String,
    onClick: () -> Unit,
    color: Color,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .height(60.dp),
        onClick = onClick,
        colors = CardDefaults.cardColors(
            containerColor = color.copy(alpha = 0.1f)
        ),
        border = androidx.compose.foundation.BorderStroke(
            1.dp,
            color.copy(alpha = 0.3f)
        ),
        shape = RoundedCornerShape(12.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(8.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            Icon(
                painter = painterResource(id = icon),
                contentDescription = text,
                tint = color,
                modifier = Modifier.size(20.dp)
            )

            Spacer(modifier = Modifier.height(4.dp))

            Text(
                text = text,
                style = MaterialTheme.typography.bodySmall,
                color = color,
                fontWeight = FontWeight.Medium,
                textAlign = TextAlign.Center,
                fontSize = 10.sp
            )
        }
    }
}

/**
 * Di√°logo para seleccionar mercadillo activo cuando hay m√∫ltiples en curso
 */
@Composable
fun DialogoSeleccionMercadilloActivo(
    mercadillosEnCurso: List<MercadilloEntity>,
    onMercadilloSeleccionado: (MercadilloEntity) -> Unit,
    onDismiss: () -> Unit,
    currentLanguage: String
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = {
            Text(
                text = "Seleccionar Mercadillo Activo",
                style = MaterialTheme.typography.titleLarge,
                fontWeight = FontWeight.Bold
            )
        },
        text = {
            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Text(
                    text = "Hay m√∫ltiples mercadillos en curso. Selecciona uno para realizar operaciones:",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                )

                Spacer(modifier = Modifier.height(8.dp))

                mercadillosEnCurso.forEach { mercadillo ->
                    Card(
                        modifier = Modifier
                            .fillMaxWidth(),
                        onClick = { onMercadilloSeleccionado(mercadillo) },
                        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),
                        colors = CardDefaults.cardColors(
                            containerColor = MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.3f)
                        )
                    ) {
                        Column(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(12.dp)
                        ) {
                            Text(
                                text = mercadillo.lugar,
                                style = MaterialTheme.typography.titleMedium,
                                fontWeight = FontWeight.Bold,
                                color = MaterialTheme.colorScheme.onSurface
                            )

                            Spacer(modifier = Modifier.height(4.dp))

                            Text(
                                text = "${mercadillo.organizador} ‚Ä¢ ${mercadillo.horaInicio} - ${mercadillo.horaFin}",
                                style = MaterialTheme.typography.bodyMedium,
                                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                            )

                            if (mercadillo.saldoInicial != null) {
                                Spacer(modifier = Modifier.height(4.dp))
                                Text(
                                    text = "üí∞ Saldo inicial: ‚Ç¨${String.format("%.2f", mercadillo.saldoInicial)}",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = Color(0xFF4CAF50),
                                    fontWeight = FontWeight.Medium
                                )
                            }
                        }
                    }
                }
            }
        },
        confirmButton = { },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancelar")
            }
        }
    )
}
// MenuHamburguesa.kt V10 - SIMPLIFICADO PARA SISTEMA MONOUSUARIO
package es.nuskysoftware.marketsales.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import es.nuskysoftware.marketsales.R
import es.nuskysoftware.marketsales.ui.viewmodel.AuthViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.AuthViewModelFactory
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.StringResourceManager
import kotlinx.coroutines.launch

@Composable
fun MenuHamburguesa(
    navController: NavController,
    drawerState: DrawerState
) {
    val scope = rememberCoroutineScope()
    val context = LocalContext.current

    // AuthViewModel para detectar estado de usuario
    val authViewModel: AuthViewModel = viewModel(factory = AuthViewModelFactory(context))
    val currentUser by authViewModel.currentUser.collectAsState()

    // Estados V10 simplificados
    val currentLanguage by ConfigurationManager.idioma.collectAsState()
    val esPremium by ConfigurationManager.esPremium.collectAsState()
    val isAuthenticated by ConfigurationManager.isAuthenticated.collectAsState()
    val estaAutenticado by ConfigurationManager.isAuthenticated.collectAsState()
    val usuarioEmail by ConfigurationManager.usuarioEmail.collectAsState()
    val displayName by ConfigurationManager.displayName.collectAsState()

    // Versi√≥n V10
    val versionText = if (esPremium) "Premium V10.0" else "Free V10.0"

    ModalDrawerSheet(
        modifier = Modifier.width(280.dp),
        drawerContainerColor = MaterialTheme.colorScheme.surface
    ) {
        // Header del men√∫ V10
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .height(120.dp)
                .background(MaterialTheme.colorScheme.primary),
            contentAlignment = Alignment.CenterStart
        ) {
            Column(
                modifier = Modifier.padding(16.dp)
            ) {
                Text(
                    text = StringResourceManager.getString("app_name", currentLanguage),
                    fontSize = 24.sp,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.onPrimary
                )

                Text(
                    text = versionText,
                    fontSize = 14.sp,
                    color = MaterialTheme.colorScheme.onPrimary.copy(alpha = 0.8f)
                )

                // Informaci√≥n del usuario V10
                if (isAuthenticated && currentUser != null) {
                    Text(
                        text = "üë§ ${usuarioEmail ?: displayName ?: "Usuario"}",
                        fontSize = 12.sp,
                        color = MaterialTheme.colorScheme.onPrimary.copy(alpha = 0.7f)
                    )
                } else {
                    Text(
                        text = "üë§ Usuario Invitado",
                        fontSize = 12.sp,
                        color = MaterialTheme.colorScheme.onPrimary.copy(alpha = 0.7f)
                    )
                }
            }
        }

        Spacer(modifier = Modifier.height(8.dp))

        // Opciones del men√∫
        LazyColumn {
            // Opciones principales
            item {
                MenuOption(
                    iconRes = R.drawable.ic_store,
                    title = StringResourceManager.getString("mercadillos", currentLanguage),
                    onClick = {
                        scope.launch { drawerState.close() }
                        navController.navigate("mercadillos") {
                            popUpTo("mercadillos") { inclusive = true }
                        }
                    }
                )
            }

            item {
                MenuOption(
                    iconRes = R.drawable.ic_list,
                    title = StringResourceManager.getString("articulos", currentLanguage),
                    onClick = {
                        scope.launch { drawerState.close() }
                        navController.navigate("articulos")
                    }
                )
            }

            item {
                MenuOption(
                    iconRes = R.drawable.ic_category,
                    title = StringResourceManager.getString("categorias", currentLanguage),
                    onClick = {
                        scope.launch { drawerState.close() }
                        navController.navigate("categorias")
                    }
                )
            }

            item {
                MenuOption(
                    iconRes = R.drawable.ic_inventory,
                    title = StringResourceManager.getString("inventario", currentLanguage),
                    onClick = {
                        scope.launch { drawerState.close() }
                        navController.navigate("inventario")
                    }
                )
            }

            item {
                MenuOption(
                    iconRes = R.drawable.ic_list,
                    title = StringResourceManager.getString("listados", currentLanguage),
                    onClick = {
                        scope.launch { drawerState.close() }
                        navController.navigate("listados")
                    }
                )
            }

            item {
                HorizontalDivider(
                    modifier = Modifier.padding(vertical = 8.dp),
                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f)
                )
            }

            // Perfil (solo para usuarios autenticados)
           // if (isAuthenticated && currentUser != null) {
            if (estaAutenticado ) {
                item {
                    MenuOption(
                        iconRes = R.drawable.ic_account,
                        title = StringResourceManager.getString("perfil", currentLanguage),
                        onClick = {
                            scope.launch { drawerState.close() }
                            navController.navigate("perfil")
                        }
                    )
                }
            }

            // Configuraci√≥n
            item {
                MenuOption(
                    iconRes = R.drawable.ic_settings,
                    title = StringResourceManager.getString("configuracion", currentLanguage),
                    onClick = {
                        scope.launch { drawerState.close() }
                        navController.navigate("configuracion")
                    }
                )
            }

            // Login/Logout condicional V10
            item {
                //if (isAuthenticated && currentUser != null) {
                if (estaAutenticado ) {
                    // Usuario autenticado - mostrar LOGOUT
                    MenuOption(
                        iconRes = R.drawable.ic_logout,
                        title = StringResourceManager.getString("cerrar_sesion", currentLanguage),
                        onClick = {
                            scope.launch {
                                drawerState.close()
                                authViewModel.logout()
                            }
                        }
                    )
                } else {
                    // Usuario NO autenticado - mostrar LOGIN
                    MenuOption(
                        iconRes = R.drawable.ic_login,
                        title = StringResourceManager.getString("iniciar_sesion", currentLanguage),
                        onClick = {
                            scope.launch { drawerState.close() }
                            navController.navigate("login")
                        }
                    )
                }
            }

            // Salir app
            item {
                MenuOption(
                    iconRes = R.drawable.ic_exit,
                    title = StringResourceManager.getString("salir", currentLanguage),
                    onClick = {
                        scope.launch { drawerState.close() }
                        (context as? androidx.activity.ComponentActivity)?.finishAffinity()
                    }
                )
            }
        }
    }
}

@Composable
private fun MenuOption(
    iconRes: Int,
    title: String,
    onClick: () -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onClick() }
            .padding(horizontal = 16.dp, vertical = 12.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Icon(
            painter = painterResource(id = iconRes),
            contentDescription = title,
            tint = MaterialTheme.colorScheme.onSurface,
            modifier = Modifier.size(24.dp)
        )

        Spacer(modifier = Modifier.width(16.dp))

        Text(
            text = title,
            fontSize = 16.sp,
            color = MaterialTheme.colorScheme.onSurface,
            fontWeight = FontWeight.Medium
        )
    }
}

// app/src/main/java/es/nuskysoftware/marketsales/ui/pantallas/PantallaAltaMercadillo.kt
// VERSI√ìN COMPLETA CON DATEPICKER, TIMEPICKER Y DEBUG ESTADOS

package es.nuskysoftware.marketsales.ui.pantallas

import es.nuskysoftware.marketsales.data.repository.SyncState
import es.nuskysoftware.marketsales.ui.viewmodel.AuthViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.AuthViewModelFactory


import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import es.nuskysoftware.marketsales.data.local.entity.MercadilloEntity
import es.nuskysoftware.marketsales.ui.viewmodel.MercadilloViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.MercadilloViewModelFactory
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.EstadosMercadillo
import es.nuskysoftware.marketsales.utils.StringResourceManager
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable


fun PantallaAltaMercadillo(
    navController: NavController,
    mercadilloId: String? = null, // null = crear, no-null = editar
    fechaPreseleccionada: String? = null // ‚úÖ NUEVO PAR√ÅMETRO PARA FECHA DEL CALENDARIO
) {
    val context = LocalContext.current
    val mercadilloViewModel: MercadilloViewModel = viewModel(
        factory = MercadilloViewModelFactory(context)
    )

    // Estados del ViewModel
    val uiState by mercadilloViewModel.uiState.collectAsState()
    val currentLanguage by ConfigurationManager.idioma.collectAsState()

    val esEdicion = mercadilloId != null
    val mercadilloParaEditar by mercadilloViewModel.mercadilloParaEditar.collectAsState()

    // Estados del formulario
    var fecha by remember { mutableStateOf(fechaPreseleccionada ?: "") }
    var lugar by remember { mutableStateOf("") }
    var organizador by remember { mutableStateOf("") }
    var esGratis by remember { mutableStateOf(true) }
    var importeSuscripcion by remember { mutableStateOf("") }
    var requiereMesa by remember { mutableStateOf(true) }
    var requiereCarpa by remember { mutableStateOf(true) }
    var hayPuntoLuz by remember { mutableStateOf(false) }
    var horaInicio by remember { mutableStateOf("09:00") }
    var horaFin by remember { mutableStateOf("14:00") }
    var saldoInicial by remember { mutableStateOf("") }

    // ‚úÖ ESTADO PARA DEBUG DE ESTADOS (SOLO EN EDICI√ìN)
    var estadoDebugSeleccionado by remember { mutableStateOf<EstadosMercadillo.Estado?>(null) }

    // ‚úÖ ESTADOS PARA DI√ÅLOGOS DE FECHA Y HORA
    var mostrarDatePicker by remember { mutableStateOf(false) }
    var mostrarTimePickerInicio by remember { mutableStateOf(false) }
    var mostrarTimePickerFin by remember { mutableStateOf(false) }

    val snackbarHostState = remember { SnackbarHostState() }
    val scope = rememberCoroutineScope()

    // Cargar mercadillo para edici√≥n
    LaunchedEffect(mercadilloId) {
        if (mercadilloId != null) {
            mercadilloViewModel.cargarMercadillo(mercadilloId)
        }
    }

    // Actualizar campos cuando se carga el mercadillo para edici√≥n
    LaunchedEffect(mercadilloParaEditar) {
        mercadilloParaEditar?.let { mercadillo ->
            fecha = mercadillo.fecha
            lugar = mercadillo.lugar
            organizador = mercadillo.organizador
            esGratis = mercadillo.esGratis
            importeSuscripcion = if (mercadillo.importeSuscripcion > 0) mercadillo.importeSuscripcion.toString() else ""
            requiereMesa = mercadillo.requiereMesa
            requiereCarpa = mercadillo.requiereCarpa
            hayPuntoLuz = mercadillo.hayPuntoLuz
            horaInicio = mercadillo.horaInicio
            horaFin = mercadillo.horaFin
            saldoInicial = mercadillo.saldoInicial?.toString() ?: ""

            // ‚úÖ CARGAR ESTADO ACTUAL PARA DEBUG
            estadoDebugSeleccionado = EstadosMercadillo.Estado.fromCodigo(mercadillo.estado)
        }
    }

    // Validar fecha preseleccionada
    LaunchedEffect(fechaPreseleccionada) {
        if (fechaPreseleccionada != null && fechaPreseleccionada.isNotBlank()) {
            val validacionFecha = mercadilloViewModel.validarFecha(fechaPreseleccionada)
            if (validacionFecha == null) {
                fecha = fechaPreseleccionada
            }
        }
    }

    // ‚úÖ NUEVA VARIABLE PARA CONTROLAR EL CIERRE
    var deberiaNavegar by remember { mutableStateOf(false) }

    // Manejar mensajes del ViewModel
    LaunchedEffect(uiState.message) {
        uiState.message?.let { message ->
            snackbarHostState.showSnackbar(message)
            mercadilloViewModel.limpiarMensaje()

            // ‚úÖ AMPLIAR LAS CONDICIONES PARA CERRAR LA PANTALLA
            if (message.contains("exitosamente") ||
                message.contains("creado") ||
                message.contains("actualizado") ||
                message.contains("Estado") ||
                message.contains("cambiado") ||
                message.contains("guardado") ||
                message.contains("saved") ||
                message.contains("success")) {

                // ‚úÖ MARCAR QUE DEBE NAVEGAR
                deberiaNavegar = true
            }
        }
    }

    // ‚úÖ EFECTO SEPARADO PARA LA NAVEGACI√ìN
    LaunchedEffect(deberiaNavegar) {
        if (deberiaNavegar) {
            // ‚úÖ PEQUE√ëO DELAY para que se vea el mensaje
            kotlinx.coroutines.delay(800)
            navController.popBackStack()
        }
    }

    LaunchedEffect(uiState.error) {
        uiState.error?.let { error ->
            snackbarHostState.showSnackbar(error)
            mercadilloViewModel.limpiarError()
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        text = if (esEdicion) "Editar Mercadillo" else "Nuevo Mercadillo",
                        fontWeight = FontWeight.Bold
                    )
                },
                // ‚úÖ SIN navigationIcon - NO HAY FLECHA ATR√ÅS
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary
                )
            )
        },
        snackbarHost = { SnackbarHost(snackbarHostState) }
    ) { paddingValues ->

        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {

            // ‚úÖ FORMULARIO CON SCROLL
            LazyColumn(
                modifier = Modifier
                    .weight(1f)
                    .padding(horizontal = 16.dp),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {

                item { Spacer(modifier = Modifier.height(8.dp)) }

                // ‚úÖ Campo fecha CON DATEPICKER
                item {
                    CampoFecha(
                        fecha = fecha,
                        onFechaChange = { fecha = it },
                        onMostrarDatePicker = { mostrarDatePicker = true },
                        esEdicion = esEdicion,
                        mercadilloParaEditar = mercadilloParaEditar
                    )
                }

                // Campo lugar
                item {
                    CampoTexto(
                        valor = lugar,
                        onValueChange = { lugar = it },
                        label = "Lugar",
                        placeholder = "Ej: Plaza Mayor"
                    )
                }

                // Campo organizador
                item {
                    CampoTexto(
                        valor = organizador,
                        onValueChange = { organizador = it },
                        label = "Organizador",
                        placeholder = "Ej: Ayuntamiento"
                    )
                }

                // Configuraci√≥n econ√≥mica
                item {
                    ConfiguracionEconomica(
                        esGratis = esGratis,
                        onEsGratisChange = { esGratis = it },
                        importeSuscripcion = importeSuscripcion,
                        onImporteSuscripcionChange = { importeSuscripcion = it }
                    )
                }

                // Configuraci√≥n log√≠stica
                item {
                    ConfiguracionLogistica(
                        requiereMesa = requiereMesa,
                        onRequiereMesaChange = { requiereMesa = it },
                        requiereCarpa = requiereCarpa,
                        onRequiereCarpaChange = { requiereCarpa = it },
                        hayPuntoLuz = hayPuntoLuz,
                        onHayPuntoLuzChange = { hayPuntoLuz = it }
                    )
                }

                // ‚úÖ Configuraci√≥n horarios CON TIMEPICKERS
                item {
                    ConfiguracionHorarios(
                        horaInicio = horaInicio,
                        onHoraInicioChange = { horaInicio = it },
                        horaFin = horaFin,
                        onHoraFinChange = { horaFin = it },
                        onMostrarTimePickerInicio = { mostrarTimePickerInicio = true },
                        onMostrarTimePickerFin = { mostrarTimePickerFin = true }
                    )
                }

                // Campo saldo inicial
                item {
                    CampoSaldoInicial(
                        saldoInicial = saldoInicial,
                        onSaldoInicialChange = { saldoInicial = it }
                    )
                }

                // ‚úÖ CAMPO DEBUG DE ESTADOS (SOLO EN EDICI√ìN)
                if (esEdicion && mercadilloParaEditar != null) {
                    item {
                        Spacer(modifier = Modifier.height(8.dp))

                        HorizontalDivider(
                            color = Color.Red.copy(alpha = 0.3f),
                            thickness = 2.dp
                        )

                        Spacer(modifier = Modifier.height(16.dp))

                        CampoEstadoDebug(
                            estadoActual = mercadilloParaEditar!!.estado,
                            onEstadoChange = { nuevoEstado ->
                                estadoDebugSeleccionado = nuevoEstado
                            },
                            modifier = Modifier.fillMaxWidth()
                        )
                    }
                }

                item { Spacer(modifier = Modifier.height(24.dp)) }
            }

            // ‚úÖ BOTONES FIJOS EN LA PARTE INFERIOR
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                horizontalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                // Bot√≥n Cancelar
                OutlinedButton(
                    onClick = {
                        // Limpiar el mercadillo para edici√≥n si existe
                        if (esEdicion) {
                            mercadilloViewModel.limpiarMercadilloParaEditar()
                        }
                        navController.popBackStack()
                    },
                    modifier = Modifier.weight(1f),
                    colors = ButtonDefaults.outlinedButtonColors(
                        contentColor = MaterialTheme.colorScheme.error
                    ),
                    border = BorderStroke(1.dp, MaterialTheme.colorScheme.error)
                ) {
                    Text("Cancelar")
                }

                // Bot√≥n Aceptar/Crear
                Button(
                    onClick = {
                        val saldoInicialDouble = saldoInicial.toDoubleOrNull()
                        val importeSuscripcionDouble = if (esGratis) 0.0 else importeSuscripcion.toDoubleOrNull() ?: 0.0

                        scope.launch {
                            try {
                                if (esEdicion && mercadilloId != null) {
                                    // ‚úÖ NUEVA L√ìGICA: Solo cambiar estado si realmente cambi√≥
                                    val estadoOriginal = mercadilloParaEditar?.estado
                                    val estadoNuevo = estadoDebugSeleccionado?.codigo

                                    if (estadoNuevo != null && estadoOriginal != null && estadoNuevo != estadoOriginal) {
                                        // El estado cambi√≥, actualizarlo primero
                                        mercadilloViewModel.cambiarEstadoMercadillo(
                                            mercadilloId = mercadilloId,
                                            nuevoEstado = estadoDebugSeleccionado!!
                                        )
                                    }

                                    // Actualizar el resto de campos
                                    mercadilloViewModel.actualizarMercadillo(
                                        mercadilloId = mercadilloId,
                                        fecha = fecha,
                                        lugar = lugar,
                                        organizador = organizador,
                                        esGratis = esGratis,
                                        importeSuscripcion = importeSuscripcionDouble,
                                        requiereMesa = requiereMesa,
                                        requiereCarpa = requiereCarpa,
                                        hayPuntoLuz = hayPuntoLuz,
                                        horaInicio = horaInicio,
                                        horaFin = horaFin,
                                        saldoInicial = saldoInicialDouble
                                    )
                                } else {
                                    mercadilloViewModel.crearMercadillo(
                                        fecha = fecha,
                                        lugar = lugar,
                                        organizador = organizador,
                                        esGratis = esGratis,
                                        importeSuscripcion = importeSuscripcionDouble,
                                        requiereMesa = requiereMesa,
                                        requiereCarpa = requiereCarpa,
                                        hayPuntoLuz = hayPuntoLuz,
                                        horaInicio = horaInicio,
                                        horaFin = horaFin,
                                        saldoInicial = saldoInicialDouble
                                    )
                                }

                                // ‚úÖ ESPERAR UN MOMENTO Y LUEGO NAVEGAR DE VUELTA
                                kotlinx.coroutines.delay(1000)

                                // ‚úÖ FORZAR LA NAVEGACI√ìN SI NO SE HA CERRADO AUTOM√ÅTICAMENTE
                                if (!deberiaNavegar) {
                                    deberiaNavegar = true
                                }

                            } catch (e: Exception) {
                                // En caso de error, no navegar
                                println("Error al guardar: ${e.message}")
                            }
                        }
                    },
                    enabled = !uiState.loading && fecha.isNotBlank() && lugar.isNotBlank() && organizador.isNotBlank(),
                    modifier = Modifier.weight(1f)
                ) {
                    if (uiState.loading) {
                        CircularProgressIndicator(
                            modifier = Modifier.size(16.dp),
                            color = MaterialTheme.colorScheme.onPrimary
                        )
                    } else {
                        Text(if (esEdicion) "Actualizar" else "Crear")
                    }
                }
            }
        }

        // ‚úÖ DI√ÅLOGOS DE FECHA Y HORA
        if (mostrarDatePicker) {
            DatePickerDialog(
                onDateSelected = { fechaSeleccionada ->
                    fecha = fechaSeleccionada
                    mostrarDatePicker = false
                },
                onDismiss = { mostrarDatePicker = false },
                currentLanguage = currentLanguage
            )
        }

        if (mostrarTimePickerInicio) {
            TimePickerDialog(
                onTimeSelected = { horaSeleccionada ->
                    horaInicio = horaSeleccionada
                    mostrarTimePickerInicio = false
                },
                onDismiss = { mostrarTimePickerInicio = false },
                initialTime = horaInicio,
                currentLanguage = currentLanguage
            )
        }

        if (mostrarTimePickerFin) {
            TimePickerDialog(
                onTimeSelected = { horaSeleccionada ->
                    horaFin = horaSeleccionada
                    mostrarTimePickerFin = false
                },
                onDismiss = { mostrarTimePickerFin = false },
                initialTime = horaFin,
                currentLanguage = currentLanguage
            )
        }
    }
}

// ‚úÖ CAMPO DE SELECCI√ìN DE ESTADO PARA DEBUG
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CampoEstadoDebug(
    estadoActual: Int,
    onEstadoChange: (EstadosMercadillo.Estado) -> Unit,
    modifier: Modifier = Modifier
) {
    var expanded by remember { mutableStateOf(false) }

    // ‚úÖ ESTADO LOCAL que S√ç se actualiza visualmente
    var estadoSeleccionado by remember(estadoActual) {
        mutableStateOf(
            EstadosMercadillo.Estado.fromCodigo(estadoActual)
                ?: EstadosMercadillo.Estado.PROGRAMADO_PARCIAL
        )
    }

    Column(modifier = modifier) {
        Text(
            text = "üîß Estado (DEBUG)",
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Medium,
            color = Color.Red
        )

        Spacer(modifier = Modifier.height(4.dp))

        ExposedDropdownMenuBox(
            expanded = expanded,
            onExpandedChange = { expanded = !expanded }
        ) {
            OutlinedTextField(
                // ‚úÖ USAR EL ESTADO LOCAL en lugar de estadoActual
                value = "${estadoSeleccionado.codigo} - ${estadoSeleccionado.descripcion}",
                onValueChange = { },
                readOnly = true,
                trailingIcon = {
                    ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded)
                },
                colors = OutlinedTextFieldDefaults.colors(
                    focusedBorderColor = Color.Red,
                    unfocusedBorderColor = Color.Red.copy(alpha = 0.5f)
                ),
                modifier = Modifier
                    .menuAnchor()
                    .fillMaxWidth()
            )

            ExposedDropdownMenu(
                expanded = expanded,
                onDismissRequest = { expanded = false }
            ) {
                EstadosMercadillo.obtenerTodosLosEstados().forEach { estado ->
                    DropdownMenuItem(
                        text = {
                            Row(
                                verticalAlignment = Alignment.CenterVertically,
                                modifier = Modifier.fillMaxWidth()
                            ) {
                                // C√≠rculo de color
                                Box(
                                    modifier = Modifier
                                        .size(12.dp)
                                        .background(
                                            EstadosMercadillo.obtenerColor(estado),
                                            CircleShape
                                        )
                                )

                                Spacer(modifier = Modifier.width(8.dp))

                                // Icono
                                Text(
                                    text = EstadosMercadillo.obtenerIcono(estado),
                                    fontSize = 14.sp
                                )

                                Spacer(modifier = Modifier.width(8.dp))

                                // C√≥digo y descripci√≥n
                                Text(
                                    text = "${estado.codigo} - ${estado.descripcion}",
                                    style = MaterialTheme.typography.bodyMedium
                                )
                            }
                        },
                        onClick = {
                            // ‚úÖ ACTUALIZAR AMBOS: local y notificar cambio
                            estadoSeleccionado = estado
                            onEstadoChange(estado)
                            expanded = false
                        }
                    )
                }
            }
        }

        // Advertencia
        Text(
            text = "‚ö†Ô∏è Solo para debugging - Se eliminar√° en producci√≥n",
            style = MaterialTheme.typography.bodySmall,
            color = Color.Red.copy(alpha = 0.7f),
            fontSize = 10.sp
        )
    }
}

// ‚úÖ COMPONENTES AUXILIARES PARA EL FORMULARIO

@Composable
fun CampoFecha(
    fecha: String,
    onFechaChange: (String) -> Unit,
    onMostrarDatePicker: () -> Unit,
    esEdicion: Boolean,
    mercadilloParaEditar: MercadilloEntity?
) {
    Column {
        Text(
            text = "Fecha",
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Medium
        )
        Spacer(modifier = Modifier.height(4.dp))
        OutlinedTextField(
            value = fecha,
            onValueChange = onFechaChange,
            placeholder = { Text("dd-MM-yyyy") },
            modifier = Modifier
                .fillMaxWidth()
                .clickable { onMostrarDatePicker() },
            readOnly = true,
            trailingIcon = {
                IconButton(onClick = onMostrarDatePicker) {
                    Text("üìÖ", fontSize = 18.sp)
                }
            }
        )
    }
}

@Composable
fun CampoTexto(
    valor: String,
    onValueChange: (String) -> Unit,
    label: String,
    placeholder: String
) {
    Column {
        Text(
            text = label,
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Medium
        )
        Spacer(modifier = Modifier.height(4.dp))
        OutlinedTextField(
            value = valor,
            onValueChange = onValueChange,
            placeholder = { Text(placeholder) },
            modifier = Modifier.fillMaxWidth()
        )
    }
}

@Composable
fun ConfiguracionEconomica(
    esGratis: Boolean,
    onEsGratisChange: (Boolean) -> Unit,
    importeSuscripcion: String,
    onImporteSuscripcionChange: (String) -> Unit
) {
    Column {
        Text(
            text = "Configuraci√≥n Econ√≥mica",
            style = MaterialTheme.typography.titleMedium,
            fontWeight = FontWeight.Bold
        )
        Spacer(modifier = Modifier.height(8.dp))

        Row(verticalAlignment = Alignment.CenterVertically) {
            Switch(
                checked = esGratis,
                onCheckedChange = onEsGratisChange
            )
            Spacer(modifier = Modifier.width(8.dp))
            Text("Mercadillo gratuito")
        }

        if (!esGratis) {
            Spacer(modifier = Modifier.height(8.dp))
            OutlinedTextField(
                value = importeSuscripcion,
                onValueChange = onImporteSuscripcionChange,
                label = { Text("Importe suscripci√≥n (‚Ç¨)") },
                placeholder = { Text("0.00") },
                modifier = Modifier.fillMaxWidth()
            )
        }
    }
}

@Composable
fun ConfiguracionLogistica(
    requiereMesa: Boolean,
    onRequiereMesaChange: (Boolean) -> Unit,
    requiereCarpa: Boolean,
    onRequiereCarpaChange: (Boolean) -> Unit,
    hayPuntoLuz: Boolean,
    onHayPuntoLuzChange: (Boolean) -> Unit
) {
    Column {
        Text(
            text = "Configuraci√≥n Log√≠stica",
            style = MaterialTheme.typography.titleMedium,
            fontWeight = FontWeight.Bold
        )
        Spacer(modifier = Modifier.height(8.dp))

        Row(verticalAlignment = Alignment.CenterVertically) {
            Checkbox(checked = requiereMesa, onCheckedChange = onRequiereMesaChange)
            Text("Requiere mesa")
        }

        Row(verticalAlignment = Alignment.CenterVertically) {
            Checkbox(checked = requiereCarpa, onCheckedChange = onRequiereCarpaChange)
            Text("Requiere carpa")
        }

        Row(verticalAlignment = Alignment.CenterVertically) {
            Checkbox(checked = hayPuntoLuz, onCheckedChange = onHayPuntoLuzChange)
            Text("Hay punto de luz")
        }
    }
}

@Composable
fun ConfiguracionHorarios(
    horaInicio: String,
    onHoraInicioChange: (String) -> Unit,
    horaFin: String,
    onHoraFinChange: (String) -> Unit,
    onMostrarTimePickerInicio: () -> Unit,
    onMostrarTimePickerFin: () -> Unit
) {
    Column {
        Text(
            text = "Horarios",
            style = MaterialTheme.typography.titleMedium,
            fontWeight = FontWeight.Bold
        )
        Spacer(modifier = Modifier.height(8.dp))

        Row(modifier = Modifier.fillMaxWidth()) {
            // ‚úÖ Hora inicio CON TIMEPICKER
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = "Hora inicio",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                )
                OutlinedTextField(
                    value = horaInicio,
                    onValueChange = onHoraInicioChange,
                    placeholder = { Text("HH:mm") },
                    modifier = Modifier
                        .fillMaxWidth()
                        .clickable { onMostrarTimePickerInicio() },
                    readOnly = true,
                    trailingIcon = {
                        IconButton(onClick = onMostrarTimePickerInicio) {
                            Text("üïê", fontSize = 18.sp)
                        }
                    }
                )
            }

            Spacer(modifier = Modifier.width(8.dp))

            // ‚úÖ Hora fin CON TIMEPICKER
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = "Hora fin",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                )
                OutlinedTextField(
                    value = horaFin,
                    onValueChange = onHoraFinChange,
                    placeholder = { Text("HH:mm") },
                    modifier = Modifier
                        .fillMaxWidth()
                        .clickable { onMostrarTimePickerFin() },
                    readOnly = true,
                    trailingIcon = {
                        IconButton(onClick = onMostrarTimePickerFin) {
                            Text("üïê", fontSize = 18.sp)
                        }
                    }
                )
            }
        }
    }
}

@Composable
fun CampoSaldoInicial(
    saldoInicial: String,
    onSaldoInicialChange: (String) -> Unit
) {
    Column {
        Text(
            text = "Saldo Inicial (Opcional)",
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Medium
        )
        Spacer(modifier = Modifier.height(4.dp))
        OutlinedTextField(
            value = saldoInicial,
            onValueChange = onSaldoInicialChange,
            placeholder = { Text("0.00") },
            modifier = Modifier.fillMaxWidth(),
            suffix = { Text("‚Ç¨") }
        )
    }
}

// ‚úÖ IMPLEMENTACI√ìN COMPLETA DE DATEPICKER Y TIMEPICKER

@Composable
private fun DatePickerDialog(
    onDateSelected: (String) -> Unit,
    onDismiss: () -> Unit,
    currentLanguage: String
) {
    val calendar = remember {
        Calendar.getInstance().apply {
            firstDayOfWeek = Calendar.MONDAY
            time = Date()
        }
    }

    var selectedDate by remember {
        mutableStateOf(calendar.clone() as Calendar)
    }

    var currentViewDate by remember {
        mutableStateOf(calendar.clone() as Calendar)
    }

    val dateFormat = SimpleDateFormat("dd-MM-yyyy", if (currentLanguage == "es") Locale("es", "ES") else Locale.ENGLISH)

    AlertDialog(
        onDismissRequest = onDismiss,
        title = {
            Text(
                text = StringResourceManager.getString("seleccionar_fecha", currentLanguage),
                style = MaterialTheme.typography.titleLarge,
                fontWeight = FontWeight.Bold
            )
        },
        text = {
            Column(
                horizontalAlignment = Alignment.CenterHorizontally,
                modifier = Modifier.width(320.dp)
            ) {
                SelectedDateDisplay(selectedDate, currentLanguage)

                Spacer(modifier = Modifier.height(16.dp))

                MonthYearNavigation(
                    currentViewDate = currentViewDate,
                    onMonthChange = { newDate ->
                        currentViewDate = newDate
                    },
                    currentLanguage = currentLanguage
                )

                Spacer(modifier = Modifier.height(16.dp))

                CalendarGrid(
                    currentViewDate = currentViewDate,
                    selectedDate = selectedDate,
                    onDateSelected = { newDate ->
                        selectedDate = newDate
                    },
                    currentLanguage = currentLanguage
                )
            }
        },
        confirmButton = {
            Button(
                onClick = {
                    val formattedDate = dateFormat.format(selectedDate.time)
                    onDateSelected(formattedDate)
                }
            ) {
                Text(StringResourceManager.getString("aceptar", currentLanguage))
            }
        },
        dismissButton = {
            OutlinedButton(onClick = onDismiss) {
                Text(StringResourceManager.getString("cancelar", currentLanguage))
            }
        }
    )
}

@Composable
private fun SelectedDateDisplay(
    selectedDate: Calendar,
    currentLanguage: String
) {
    val dayFormat = SimpleDateFormat("EEEE", if (currentLanguage == "es") Locale("es", "ES") else Locale.ENGLISH)
    val displayFormat = if (currentLanguage == "es") {
        SimpleDateFormat("d 'de' MMMM 'de' yyyy", Locale("es", "ES"))
    } else {
        SimpleDateFormat("MMMM d, yyyy", Locale.ENGLISH)
    }

    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.primaryContainer
        )
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(
                text = dayFormat.format(selectedDate.time).replaceFirstChar {
                    if (it.isLowerCase()) it.titlecase() else it.toString()
                },
                style = MaterialTheme.typography.bodyLarge,
                color = MaterialTheme.colorScheme.onPrimaryContainer
            )
            Text(
                text = displayFormat.format(selectedDate.time),
                style = MaterialTheme.typography.headlineSmall,
                color = MaterialTheme.colorScheme.onPrimaryContainer,
                fontWeight = FontWeight.Bold
            )
        }
    }
}

@Composable
private fun MonthYearNavigation(
    currentViewDate: Calendar,
    onMonthChange: (Calendar) -> Unit,
    currentLanguage: String
) {
    val monthFormat = if (currentLanguage == "es") {
        SimpleDateFormat("MMMM yyyy", Locale("es", "ES"))
    } else {
        SimpleDateFormat("MMMM yyyy", Locale.ENGLISH)
    }

    Row(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        IconButton(onClick = {
            val newDate = (currentViewDate.clone() as Calendar).apply {
                add(Calendar.MONTH, -1)
            }
            onMonthChange(newDate)
        }) {
            Text(
                text = "‚Üê",
                fontSize = 20.sp,
                color = MaterialTheme.colorScheme.primary,
                fontWeight = FontWeight.Bold
            )
        }

        Text(
            text = monthFormat.format(currentViewDate.time).replaceFirstChar {
                if (it.isLowerCase()) it.titlecase() else it.toString()
            },
            style = MaterialTheme.typography.titleMedium,
            fontWeight = FontWeight.Bold,
            color = MaterialTheme.colorScheme.onSurface
        )

        IconButton(onClick = {
            val newDate = (currentViewDate.clone() as Calendar).apply {
                add(Calendar.MONTH, 1)
            }
            onMonthChange(newDate)
        }) {
            Text(
                text = "‚Üí",
                fontSize = 20.sp,
                color = MaterialTheme.colorScheme.primary,
                fontWeight = FontWeight.Bold
            )
        }
    }
}

@Composable
private fun CalendarGrid(
    currentViewDate: Calendar,
    selectedDate: Calendar,
    onDateSelected: (Calendar) -> Unit,
    currentLanguage: String
) {
    val diasSemana = if (currentLanguage == "es") {
        listOf(
            StringResourceManager.getString("lunes", currentLanguage),
            StringResourceManager.getString("martes", currentLanguage),
            StringResourceManager.getString("miercoles", currentLanguage),
            StringResourceManager.getString("jueves", currentLanguage),
            StringResourceManager.getString("viernes", currentLanguage),
            StringResourceManager.getString("sabado", currentLanguage),
            StringResourceManager.getString("domingo", currentLanguage)
        )
    } else {
        listOf("M", "T", "W", "T", "F", "S", "S")
    }

    Column {
        Row(modifier = Modifier.fillMaxWidth()) {
            diasSemana.forEach { dia ->
                Text(
                    text = dia,
                    modifier = Modifier.weight(1f),
                    textAlign = TextAlign.Center,
                    style = MaterialTheme.typography.bodySmall,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.primary
                )
            }
        }

        Spacer(modifier = Modifier.height(8.dp))

        val year = currentViewDate.get(Calendar.YEAR)
        val month = currentViewDate.get(Calendar.MONTH)

        val firstDayOfMonth = (currentViewDate.clone() as Calendar).apply {
            set(Calendar.DAY_OF_MONTH, 1)
        }

        val firstDayOfWeek = (firstDayOfMonth.get(Calendar.DAY_OF_WEEK) + 5) % 7
        val daysInMonth = currentViewDate.getActualMaximum(Calendar.DAY_OF_MONTH)
        val totalCells = 42

        LazyVerticalGrid(
            columns = GridCells.Fixed(7),
            modifier = Modifier.height(240.dp),
            verticalArrangement = Arrangement.spacedBy(4.dp),
            horizontalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            items(totalCells) { index ->
                val dayNumber = index - firstDayOfWeek + 1

                if (dayNumber in 1..daysInMonth) {
                    val dayDate = (currentViewDate.clone() as Calendar).apply {
                        set(Calendar.DAY_OF_MONTH, dayNumber)
                    }

                    val isSelected = isSameDay(dayDate, selectedDate)
                    val isToday = isSameDay(dayDate, Calendar.getInstance())

                    DayCell(
                        day = dayNumber,
                        isSelected = isSelected,
                        isToday = isToday,
                        onClick = { onDateSelected(dayDate) }
                    )
                } else {
                    Box(modifier = Modifier.size(40.dp))
                }
            }
        }
    }
}

@Composable
private fun DayCell(
    day: Int,
    isSelected: Boolean,
    isToday: Boolean,
    onClick: () -> Unit
) {
    Box(
        modifier = Modifier
            .size(40.dp)
            .clickable { onClick() }
            .background(
                color = when {
                    isSelected -> MaterialTheme.colorScheme.primary
                    isToday -> MaterialTheme.colorScheme.primaryContainer
                    else -> Color.Transparent
                },
                shape = RoundedCornerShape(8.dp)
            ),
        contentAlignment = Alignment.Center
    ) {
        Text(
            text = day.toString(),
            style = MaterialTheme.typography.bodyMedium,
            color = when {
                isSelected -> MaterialTheme.colorScheme.onPrimary
                isToday -> MaterialTheme.colorScheme.onPrimaryContainer
                else -> MaterialTheme.colorScheme.onSurface
            },
            fontWeight = if (isSelected || isToday) FontWeight.Bold else FontWeight.Normal
        )
    }
}

private fun isSameDay(cal1: Calendar, cal2: Calendar): Boolean {
    return cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR)
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun TimePickerDialog(
    onTimeSelected: (String) -> Unit,
    onDismiss: () -> Unit,
    initialTime: String = "09:00",
    currentLanguage: String
) {
    val timeParts = initialTime.split(":")
    val initialHour = timeParts.getOrNull(0)?.toIntOrNull() ?: 9
    val initialMinute = timeParts.getOrNull(1)?.toIntOrNull() ?: 0

    val timePickerState = rememberTimePickerState(
        initialHour = initialHour,
        initialMinute = initialMinute,
        is24Hour = true
    )

    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text(StringResourceManager.getString("seleccionar_hora", currentLanguage)) },
        text = {
            Column(
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                TimePicker(
                    state = timePickerState,
                    modifier = Modifier.padding(16.dp)
                )
            }
        },
        confirmButton = {
            TextButton(
                onClick = {
                    val hour = String.format("%02d", timePickerState.hour)
                    val minute = String.format("%02d", timePickerState.minute)
                    onTimeSelected("$hour:$minute")
                }
            ) {
                Text(StringResourceManager.getString("aceptar", currentLanguage))
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text(StringResourceManager.getString("cancelar", currentLanguage))
            }
        }
    )
}

// app/src/main/java/es/nuskysoftware/marketsales/ui/viewmodel/MercadilloViewModel.kt
package es.nuskysoftware.marketsales.ui.viewmodel

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import es.nuskysoftware.marketsales.data.local.entity.MercadilloEntity
import es.nuskysoftware.marketsales.data.repository.MercadilloRepository
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.EstadosMercadillo
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.*

/**
 * MercadilloViewModel V14 - Market Sales
 *
 * ARQUITECTURA REACTIVA + REGLAS DE NEGOCIO + BOTTOMBAR + PR√ìXIMOS:
 * - StateFlow para estados reactivos
 * - Observa cambios en tiempo real
 * - Compatible con sistema h√≠brido "Reloj Suizo"
 * - Estados de UI para loading, errores, etc.
 * - Gesti√≥n completa de mercadillos y estados autom√°ticos
 * - L√≥gica espec√≠fica para calendario y pr√≥ximos mercadillos
 * - NUEVAS REGLAS DE NEGOCIO IMPLEMENTADAS
 * - GESTI√ìN DE MERCADILLO ACTIVO PARA BOTTOMBAR
 * - FUNCIONALIDAD DEBUG PARA CAMBIO DE ESTADOS
 * - ‚úÖ NUEVA: LISTADO COMPLETO DE MERCADILLOS PR√ìXIMOS
 */
class MercadilloViewModel(
    private val repository: MercadilloRepository
) : ViewModel() {

    companion object {
        private const val TAG = "MercadilloViewModel"
    }

    // Formateadores de fecha
    private val dateFormat = SimpleDateFormat("dd-MM-yyyy", Locale.getDefault())
    private val timeFormat = SimpleDateFormat("HH:mm", Locale.getDefault())

    // ========== ESTADOS REACTIVOS ==========

    private val _uiState = MutableStateFlow(MercadilloUiState())
    val uiState: StateFlow<MercadilloUiState> = _uiState.asStateFlow()

    // Estado del calendario (mes/a√±o actual visible)
    private val _calendarioState = MutableStateFlow(CalendarioState())
    val calendarioState: StateFlow<CalendarioState> = _calendarioState.asStateFlow()

    // ========== ESTADOS PARA EDICI√ìN ==========
    private val _mercadilloParaEditar = MutableStateFlow<MercadilloEntity?>(null)
    val mercadilloParaEditar: StateFlow<MercadilloEntity?> = _mercadilloParaEditar.asStateFlow()

    // ========== GESTI√ìN DE MERCADILLO ACTIVO (BOTTOMBAR) ==========

    /**
     * Mercadillo seleccionado para operaciones (ventas/gastos/resumen)
     * Se mantiene durante la sesi√≥n
     */
    private val _mercadilloActivoSeleccionado = MutableStateFlow<MercadilloEntity?>(null)
    val mercadilloActivoSeleccionado: StateFlow<MercadilloEntity?> = _mercadilloActivoSeleccionado.asStateFlow()

    // Mercadillos del usuario actual en tiempo real
    val mercadillos = repository.getMercadillosUsuarioActual()
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    /**
     * Obtiene mercadillos en curso (estado EN_CURSO = 3)
     */
    val mercadillosEnCurso: StateFlow<List<MercadilloEntity>> = mercadillos
        .map { listaMercadillos ->
            listaMercadillos.filter { mercadillo ->
                mercadillo.estado == EstadosMercadillo.Estado.EN_CURSO.codigo
            }
        }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    /**
     * Indica si debe mostrarse el BottomBar (hay mercadillos en curso)
     */
    val mostrarBottomBar: StateFlow<Boolean> = mercadillosEnCurso
        .map { it.isNotEmpty() }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), false)

    /**
     * Obtiene el mercadillo activo para operaciones
     * Si hay uno seleccionado previamente y sigue en curso, lo usa
     * Si no, devuelve null para que se muestre el di√°logo de selecci√≥n
     */
    val mercadilloActivoParaOperaciones: StateFlow<MercadilloEntity?> = combine(
        mercadillosEnCurso,
        mercadilloActivoSeleccionado
    ) { enCurso, seleccionado ->
        when {
            enCurso.isEmpty() -> {
                // No hay mercadillos en curso, limpiar selecci√≥n
                _mercadilloActivoSeleccionado.value = null
                null
            }
            enCurso.size == 1 -> {
                // Solo hay uno en curso, seleccionarlo autom√°ticamente
                val unico = enCurso.first()
                if (seleccionado?.idMercadillo != unico.idMercadillo) {
                    _mercadilloActivoSeleccionado.value = unico
                }
                unico
            }
            seleccionado != null && enCurso.any { it.idMercadillo == seleccionado.idMercadillo } -> {
                // El seleccionado sigue en curso, mantenerlo
                seleccionado
            }
            else -> {
                // Hay m√∫ltiples y no hay selecci√≥n v√°lida
                null
            }
        }
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), null)

    // ========== ‚úÖ NUEVA FUNCIONALIDAD: MERCADILLOS PR√ìXIMOS ==========

    /**
     * ‚úÖ NUEVA: Obtiene TODOS los mercadillos desde hoy en adelante
     */
    val mercadillosProximos: StateFlow<List<MercadilloEntity>> =
        ConfigurationManager.usuarioLogueado.flatMapLatest { userId ->
            val effectiveUserId = userId ?: "usuario_default"
            Log.d(TAG, "üîÑ Usuario cambi√≥ a: $effectiveUserId - Recargando mercadillos pr√≥ximos")

            flow {
                while (true) {
                    val proximosMercadillos = repository.getMercadillosDesdeHoy(effectiveUserId)
                    emit(proximosMercadillos)
                    kotlinx.coroutines.delay(60_000) // Actualizar cada minuto
                }
            }
        }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    /**
     * ‚úÖ MANTENER COMPATIBILIDAD: El pr√≥ximo mercadillo (primer elemento de la lista)
     */
    val proximoMercadillo: StateFlow<MercadilloEntity?> = mercadillosProximos
        .map { lista -> lista.firstOrNull() }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), null)

    /**
     * ‚úÖ NUEVA: Indica si hay mercadillos pr√≥ximos
     */
    val tieneMercadillosProximos: StateFlow<Boolean> = mercadillosProximos
        .map { it.isNotEmpty() }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), false)

    /**
     * ‚úÖ NUEVA: Cuenta el n√∫mero de mercadillos pr√≥ximos
     */
    val totalMercadillosProximos: StateFlow<Int> = mercadillosProximos
        .map { it.size }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), 0)

    init {
        Log.d(TAG, "‚úÖ MercadilloViewModel inicializado con funcionalidad mercadillosProximos")

        // Inicializar calendario con mes actual
        val hoy = Calendar.getInstance()
        _calendarioState.value = CalendarioState(
            ano = hoy.get(Calendar.YEAR),
            mes = hoy.get(Calendar.MONTH) + 1 // Calendar.MONTH es 0-based
        )
    }

    // ========== OPERACIONES CRUD ==========

    /**
     * Crea un nuevo mercadillo - CON REGLAS DE NEGOCIO
     */
    fun crearMercadillo(
        fecha: String,
        lugar: String,
        organizador: String,
        esGratis: Boolean = true,
        importeSuscripcion: Double = 0.0,
        requiereMesa: Boolean = true,
        requiereCarpa: Boolean = true,
        hayPuntoLuz: Boolean = false,
        horaInicio: String = "09:00",
        horaFin: String = "14:00",
        saldoInicial: Double? = null
    ) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(loading = true, error = null)

            try {
                // ‚úÖ NUEVA VALIDACI√ìN DE FECHA PARA ALTA
                val validacionFechaAlta = validarFechaParaAlta(fecha)
                if (validacionFechaAlta != null) {
                    _uiState.value = _uiState.value.copy(loading = false, error = validacionFechaAlta)
                    return@launch
                }

                // ‚úÖ NUEVA VALIDACI√ìN DE M√öLTIPLES MERCADILLOS
                val validacionMultiples = validarMultiplesMercadillosPorDia(fecha)
                if (validacionMultiples != null) {
                    _uiState.value = _uiState.value.copy(loading = false, error = validacionMultiples)
                    return@launch
                }

                // Validaciones b√°sicas existentes
                val validacionLugar = validarLugar(lugar)
                if (validacionLugar != null) {
                    _uiState.value = _uiState.value.copy(loading = false, error = validacionLugar)
                    return@launch
                }

                val validacionOrganizador = validarOrganizador(organizador)
                if (validacionOrganizador != null) {
                    _uiState.value = _uiState.value.copy(loading = false, error = validacionOrganizador)
                    return@launch
                }

                val validacionHorarios = validarHorarios(horaInicio, horaFin)
                if (validacionHorarios != null) {
                    _uiState.value = _uiState.value.copy(loading = false, error = validacionHorarios)
                    return@launch
                }

                // Validar suscripci√≥n si no es gratis
                if (!esGratis) {
                    val validacionSuscripcion = validarImporteSuscripcion(importeSuscripcion)
                    if (validacionSuscripcion != null) {
                        _uiState.value = _uiState.value.copy(loading = false, error = validacionSuscripcion)
                        return@launch
                    }
                }

                // Validar saldo inicial si se proporcion√≥
                if (saldoInicial != null) {
                    val validacionSaldo = validarSaldoInicial(saldoInicial)
                    if (validacionSaldo != null) {
                        _uiState.value = _uiState.value.copy(loading = false, error = validacionSaldo)
                        return@launch
                    }
                }

                val mercadilloId = repository.crearMercadillo(
                    fecha = fecha,
                    lugar = lugar,
                    organizador = organizador,
                    esGratis = esGratis,
                    importeSuscripcion = importeSuscripcion,
                    requiereMesa = requiereMesa,
                    requiereCarpa = requiereCarpa,
                    hayPuntoLuz = hayPuntoLuz,
                    horaInicio = horaInicio,
                    horaFin = horaFin,
                    saldoInicial = saldoInicial
                )

                // Mensaje personalizado seg√∫n si hay saldo inicial
                val mensaje = if (saldoInicial != null) {
                    "Mercadillo creado con saldo inicial de ‚Ç¨${String.format("%.2f", saldoInicial)}"
                } else {
                    "Mercadillo creado exitosamente"
                }

                _uiState.value = _uiState.value.copy(
                    loading = false,
                    message = mensaje,
                    error = null
                )

                Log.d(TAG, "‚úÖ Mercadillo creado: $lugar - $fecha (ID: $mercadilloId)${if (saldoInicial != null) " - Saldo inicial: ‚Ç¨$saldoInicial" else ""}")

            } catch (e: Exception) {
                val errorMsg = when {
                    e.message?.contains("Ya existe un mercadillo") == true ->
                        "Ya existe un mercadillo en esa fecha y hora"
                    else -> "Error creando mercadillo: ${e.message}"
                }

                _uiState.value = _uiState.value.copy(loading = false, error = errorMsg)
                Log.e(TAG, "‚ùå Error creando mercadillo", e)
            }
        }
    }

    /**
     * Carga un mercadillo para edici√≥n
     */
    fun cargarMercadillo(mercadilloId: String) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(loading = true, error = null)

            try {
                val mercadillo = repository.getMercadilloById(mercadilloId)
                if (mercadillo != null) {
                    // ‚úÖ VALIDAR SI SE PUEDE EDITAR SEG√öN ESTADO
                    val puedeEditar = puedeEditarMercadillo(mercadillo)
                    if (!puedeEditar.first) {
                        _uiState.value = _uiState.value.copy(
                            loading = false,
                            error = puedeEditar.second
                        )
                        return@launch
                    }

                    _mercadilloParaEditar.value = mercadillo
                    Log.d(TAG, "‚úÖ Mercadillo cargado para edici√≥n: ${mercadillo.lugar}")
                } else {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        error = "Mercadillo no encontrado"
                    )
                }
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    loading = false,
                    error = "Error cargando mercadillo: ${e.message}"
                )
                Log.e(TAG, "‚ùå Error cargando mercadillo para edici√≥n", e)
            } finally {
                _uiState.value = _uiState.value.copy(loading = false)
            }
        }
    }

    /**
     * Actualiza un mercadillo existente - CON REGLAS DE NEGOCIO
     */
    fun actualizarMercadillo(
        mercadilloId: String,
        fecha: String,
        lugar: String,
        organizador: String,
        esGratis: Boolean = true,
        importeSuscripcion: Double = 0.0,
        requiereMesa: Boolean = true,
        requiereCarpa: Boolean = true,
        hayPuntoLuz: Boolean = false,
        horaInicio: String = "09:00",
        horaFin: String = "14:00",
        saldoInicial: Double? = null
    ) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(loading = true, error = null)

            try {
                // Obtener mercadillo actual
                val mercadilloActual = repository.getMercadilloById(mercadilloId)
                if (mercadilloActual == null) {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        error = "Mercadillo no encontrado"
                    )
                    return@launch
                }

                // ‚úÖ VALIDAR SI SE PUEDE EDITAR SEG√öN ESTADO
                val puedeEditar = puedeEditarMercadillo(mercadilloActual)
                if (!puedeEditar.first) {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        error = puedeEditar.second
                    )
                    return@launch
                }

                // ‚úÖ VALIDAR CAMPOS ESPEC√çFICOS SEG√öN ESTADO
                val validacionCampos = validarCamposSegunEstado(mercadilloActual, fecha, saldoInicial)
                if (validacionCampos != null) {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        error = validacionCampos
                    )
                    return@launch
                }

                // Validaciones b√°sicas
                val validacionLugar = validarLugar(lugar)
                if (validacionLugar != null) {
                    _uiState.value = _uiState.value.copy(loading = false, error = validacionLugar)
                    return@launch
                }

                val validacionOrganizador = validarOrganizador(organizador)
                if (validacionOrganizador != null) {
                    _uiState.value = _uiState.value.copy(loading = false, error = validacionOrganizador)
                    return@launch
                }

                val validacionHorarios = validarHorarios(horaInicio, horaFin)
                if (validacionHorarios != null) {
                    _uiState.value = _uiState.value.copy(loading = false, error = validacionHorarios)
                    return@launch
                }

                // Validar suscripci√≥n si no es gratis
                if (!esGratis) {
                    val validacionSuscripcion = validarImporteSuscripcion(importeSuscripcion)
                    if (validacionSuscripcion != null) {
                        _uiState.value = _uiState.value.copy(loading = false, error = validacionSuscripcion)
                        return@launch
                    }
                }

                // Validar saldo inicial si se proporcion√≥
                if (saldoInicial != null) {
                    val validacionSaldo = validarSaldoInicial(saldoInicial)
                    if (validacionSaldo != null) {
                        _uiState.value = _uiState.value.copy(loading = false, error = validacionSaldo)
                        return@launch
                    }
                }

                // Crear mercadillo actualizado manteniendo algunos campos originales
                val mercadilloActualizado = mercadilloActual.copy(
                    fecha = fecha,
                    lugar = lugar,
                    organizador = organizador,
                    esGratis = esGratis,
                    importeSuscripcion = importeSuscripcion,
                    requiereMesa = requiereMesa,
                    requiereCarpa = requiereCarpa,
                    hayPuntoLuz = hayPuntoLuz,
                    horaInicio = horaInicio,
                    horaFin = horaFin,
                    saldoInicial = saldoInicial,
                    // ‚úÖ ACTUALIZAR ESTADO SI CAMBI√ì EL SALDO INICIAL
                    estado = calcularNuevoEstadoPorCambios(mercadilloActual, saldoInicial)
                )

                val exito = repository.actualizarMercadillo(mercadilloActualizado)

                if (exito) {
                    val mensaje = "Mercadillo actualizado exitosamente"
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        message = mensaje,
                        error = null
                    )

                    // Limpiar mercadillo para edici√≥n
                    _mercadilloParaEditar.value = null

                    Log.d(TAG, "‚úÖ Mercadillo actualizado: $lugar - $fecha (ID: $mercadilloId)")
                } else {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        error = "Error actualizando mercadillo"
                    )
                }

            } catch (e: Exception) {
                val errorMsg = "Error actualizando mercadillo: ${e.message}"
                _uiState.value = _uiState.value.copy(loading = false, error = errorMsg)
                Log.e(TAG, "‚ùå Error actualizando mercadillo", e)
            }
        }
    }

    /**
     * Limpia el mercadillo para edici√≥n
     */
    fun limpiarMercadilloParaEditar() {
        _mercadilloParaEditar.value = null
    }

    // ========== GESTI√ìN DE MERCADILLO ACTIVO (BOTTOMBAR) ==========

    /**
     * Selecciona un mercadillo espec√≠fico para operaciones
     */
    fun seleccionarMercadilloActivo(mercadillo: MercadilloEntity) {
        _mercadilloActivoSeleccionado.value = mercadillo
        Log.d(TAG, "‚úÖ Mercadillo activo seleccionado: ${mercadillo.lugar}")
    }

    /**
     * Limpia la selecci√≥n de mercadillo activo
     */
    fun limpiarMercadilloActivo() {
        _mercadilloActivoSeleccionado.value = null
        Log.d(TAG, "üßπ Mercadillo activo limpiado")
    }

    /**
     * Cambia el mercadillo activo seleccionado
     */
    fun cambiarMercadilloActivo() {
        // Esto activar√° el di√°logo de selecci√≥n en la UI
        _mercadilloActivoSeleccionado.value = null
    }

    // ========== NAVEGACI√ìN A OPERACIONES ==========

    /**
     * Maneja la navegaci√≥n a ventas
     * Devuelve true si puede navegar directamente, false si necesita selecci√≥n
     */
    fun manejarNavegacionVentas(): Pair<Boolean, MercadilloEntity?> {
        val mercadillosDisponibles = mercadillosEnCurso.value
        val activo = mercadilloActivoParaOperaciones.value

        return when {
            mercadillosDisponibles.isEmpty() -> {
                _uiState.value = _uiState.value.copy(error = "No hay mercadillos en curso")
                Pair(false, null)
            }
            activo != null -> {
                // Puede navegar directamente
                Pair(true, activo)
            }
            else -> {
                // Necesita selecci√≥n
                Pair(false, null)
            }
        }
    }

    /**
     * Maneja la navegaci√≥n a gastos
     */
    fun manejarNavegacionGastos(): Pair<Boolean, MercadilloEntity?> {
        return manejarNavegacionVentas() // Misma l√≥gica
    }

    /**
     * Maneja la navegaci√≥n a resumen
     */
    fun manejarNavegacionResumen(): Pair<Boolean, MercadilloEntity?> {
        return manejarNavegacionVentas() // Misma l√≥gica
    }

    // ========== FUNCIONALIDAD DEBUG - CAMBIO DE ESTADOS ==========

    /**
     * Cambia el estado de un mercadillo (SOLO PARA DEBUG)
     */
    fun cambiarEstadoMercadillo(mercadilloId: String, nuevoEstado: EstadosMercadillo.Estado) {
        viewModelScope.launch {
            try {
                val mercadillo = repository.getMercadilloById(mercadilloId)
                if (mercadillo != null) {
                    val mercadilloActualizado = mercadillo.copy(
                        estado = nuevoEstado.codigo,
                        version = mercadillo.version + 1,
                        lastModified = System.currentTimeMillis(),
                        sincronizadoFirebase = false
                    )

                    val exito = repository.actualizarMercadillo(mercadilloActualizado)

                    if (exito) {
                        _uiState.value = _uiState.value.copy(
                            message = "Estado cambiado a: ${nuevoEstado.descripcion}"
                        )
                        Log.d(TAG, "üîß DEBUG: Estado cambiado - ${mercadillo.lugar} -> ${nuevoEstado.descripcion}")
                    } else {
                        _uiState.value = _uiState.value.copy(
                            error = "Error cambiando estado"
                        )
                    }
                }
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    error = "Error cambiando estado: ${e.message}"
                )
                Log.e(TAG, "‚ùå Error cambiando estado DEBUG", e)
            }
        }
    }

    // ========== NUEVAS VALIDACIONES CON REGLAS DE NEGOCIO ==========

    /**
     * Valida si una fecha es v√°lida para crear mercadillos (no anterior a hoy)
     */
    fun validarFechaParaAlta(fecha: String): String? {
        // Validaci√≥n b√°sica de formato
        val validacionBasica = validarFecha(fecha)
        if (validacionBasica != null) return validacionBasica

        try {
            val fechaMercadillo = dateFormat.parse(fecha)
            val fechaActual = Date()

            // ‚úÖ REGLA 1: No permitir fechas anteriores a hoy
            if (fechaMercadillo != null && fechaMercadillo.before(fechaActual)) {
                return "No se puede crear un mercadillo en una fecha anterior a hoy"
            }

            return null
        } catch (e: Exception) {
            return "Fecha inv√°lida"
        }
    }

    /**
     * Valida si el usuario puede crear m√∫ltiples mercadillos en una fecha
     */
    private suspend fun validarMultiplesMercadillosPorDia(fecha: String): String? {
        try {
            val userId = ConfigurationManager.getCurrentUserId() ?: return "Usuario no autenticado"
            val esPremium = ConfigurationManager.getIsPremium()

            // Contar mercadillos existentes en esa fecha
            val mercadillosEnFecha = repository.getMercadillosPorFecha(userId, fecha)

            // ‚úÖ REGLA 2: Solo Premium puede crear m√∫ltiples mercadillos por d√≠a
            if (mercadillosEnFecha.isNotEmpty() && !esPremium) {
                return "Los usuarios FREE solo pueden crear un mercadillo por d√≠a. Actualiza a Premium para crear m√∫ltiples mercadillos."
            }

            return null
        } catch (e: Exception) {
            Log.e(TAG, "Error validando m√∫ltiples mercadillos", e)
            return "Error validando disponibilidad de fecha"
        }
    }

    /**
     * Valida si un mercadillo puede ser editado seg√∫n su estado
     */
    private fun puedeEditarMercadillo(mercadillo: MercadilloEntity): Pair<Boolean, String> {
        val estado = EstadosMercadillo.Estado.fromCodigo(mercadillo.estado)
            ?: return Pair(false, "Estado de mercadillo no v√°lido")

        return when (estado) {
            EstadosMercadillo.Estado.PROGRAMADO_PARCIAL,
            EstadosMercadillo.Estado.PROGRAMADO_TOTAL -> {
                // ‚úÖ REGLA 3: Programado (1,2): todo modificable
                Pair(true, "")
            }
            EstadosMercadillo.Estado.EN_CURSO -> {
                // ‚úÖ REGLA 4: Actual (3): modificable pero con restricciones
                Pair(true, "")
            }
            EstadosMercadillo.Estado.PENDIENTE_ARQUEO,
            EstadosMercadillo.Estado.PENDIENTE_ASIGNAR_SALDO,
            EstadosMercadillo.Estado.CERRADO_COMPLETO,
            EstadosMercadillo.Estado.CANCELADO -> {
                // ‚úÖ REGLA 5: Otros estados (4,5,6,7): no modificable
                Pair(false, "No se puede modificar un mercadillo en estado: ${estado.descripcion}")
            }
        }
    }

    /**
     * Valida campos espec√≠ficos seg√∫n el estado del mercadillo
     */
    private fun validarCamposSegunEstado(
        mercadilloActual: MercadilloEntity,
        nuevaFecha: String,
        nuevoSaldoInicial: Double?
    ): String? {
        val estado = EstadosMercadillo.Estado.fromCodigo(mercadilloActual.estado)
            ?: return "Estado de mercadillo no v√°lido"

        when (estado) {
            EstadosMercadillo.Estado.EN_CURSO -> {
                // ‚úÖ REGLA 4: Actual (3): no fecha ni saldo inicial
                if (nuevaFecha != mercadilloActual.fecha) {
                    return "No se puede modificar la fecha de un mercadillo en curso"
                }
                if (nuevoSaldoInicial != mercadilloActual.saldoInicial) {
                    return "No se puede modificar el saldo inicial de un mercadillo en curso"
                }
            }
            EstadosMercadillo.Estado.PROGRAMADO_PARCIAL,
            EstadosMercadillo.Estado.PROGRAMADO_TOTAL -> {
                // ‚úÖ REGLA 3: Programado: todo modificable (sin restricciones adicionales)
            }
            else -> {
                // Ya validado en puedeEditarMercadillo
            }
        }

        return null
    }

    /**
     * Calcula el nuevo estado basado en los cambios realizados
     */
    private fun calcularNuevoEstadoPorCambios(
        mercadilloActual: MercadilloEntity,
        nuevoSaldoInicial: Double?
    ): Int {
        val estadoActual = EstadosMercadillo.Estado.fromCodigo(mercadilloActual.estado)
            ?: return mercadilloActual.estado

        // ‚úÖ REGLA 9: Todos los datos ‚Üí Programado Total
        when (estadoActual) {
            EstadosMercadillo.Estado.PROGRAMADO_PARCIAL -> {
                // Si se agrega saldo inicial, pasa a PROGRAMADO_TOTAL
                if (nuevoSaldoInicial != null && mercadilloActual.saldoInicial == null) {
                    return EstadosMercadillo.Estado.PROGRAMADO_TOTAL.codigo
                }
            }
            EstadosMercadillo.Estado.PROGRAMADO_TOTAL -> {
                // Si se quita saldo inicial, pasa a PROGRAMADO_PARCIAL
                if (nuevoSaldoInicial == null && mercadilloActual.saldoInicial != null) {
                    return EstadosMercadillo.Estado.PROGRAMADO_PARCIAL.codigo
                }
            }
            else -> {
                // Para otros estados, mantener el estado actual
            }
        }

        return mercadilloActual.estado
    }

    // ========== GESTI√ìN DEL CALENDARIO ==========

    /**
     * Navega al mes anterior en el calendario
     */
    fun navegarMesAnterior() {
        val estadoActual = _calendarioState.value
        val nuevaFecha = Calendar.getInstance().apply {
            set(Calendar.YEAR, estadoActual.ano)
            set(Calendar.MONTH, estadoActual.mes - 1) // Calendar.MONTH es 0-based
            add(Calendar.MONTH, -1)
        }

        _calendarioState.value = estadoActual.copy(
            ano = nuevaFecha.get(Calendar.YEAR),
            mes = nuevaFecha.get(Calendar.MONTH) + 1
        )

        Log.d(TAG, "üìÖ Navegando a: ${nuevaFecha.get(Calendar.MONTH) + 1}/${nuevaFecha.get(Calendar.YEAR)}")
    }

    /**
     * Navega al mes siguiente en el calendario
     */
    fun navegarMesSiguiente() {
        val estadoActual = _calendarioState.value
        val nuevaFecha = Calendar.getInstance().apply {
            set(Calendar.YEAR, estadoActual.ano)
            set(Calendar.MONTH, estadoActual.mes - 1) // Calendar.MONTH es 0-based
            add(Calendar.MONTH, 1)
        }

        _calendarioState.value = estadoActual.copy(
            ano = nuevaFecha.get(Calendar.YEAR),
            mes = nuevaFecha.get(Calendar.MONTH) + 1
        )

        Log.d(TAG, "üìÖ Navegando a: ${nuevaFecha.get(Calendar.MONTH) + 1}/${nuevaFecha.get(Calendar.YEAR)}")
    }

    /**
     * Obtiene mercadillos del mes actual visible en el calendario
     */
    val mercadillosDelMesVisible: StateFlow<List<MercadilloEntity>> =
        calendarioState.flatMapLatest { estado ->
            repository.getMercadillosPorMes(estado.ano, estado.mes)
        }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    /**
     * Agrupa mercadillos por d√≠a para el calendario
     */
    val mercadillosPorDia: StateFlow<Map<Int, List<MercadilloEntity>>> =
        mercadillosDelMesVisible.map { mercadillos ->
            mercadillos.groupBy { mercadillo ->
                try {
                    mercadillo.fecha.split("-")[0].toInt() // D√≠a del formato "dd-MM-yyyy"
                } catch (e: Exception) {
                    0 // Si hay error en el formato, usar d√≠a 0 (no se mostrar√°)
                }
            }.filterKeys { it > 0 } // Filtrar d√≠as inv√°lidos
        }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyMap())

    // ========== CONSULTAS ESPEC√çFICAS ==========

    /**
     * Obtiene mercadillos que requieren atenci√≥n
     */
    val mercadillosRequierenAtencion = repository.getMercadillosRequierenAtencion()
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    /**
     * Obtiene estad√≠sticas de mercadillos por estado
     */
    val estadisticasPorEstado: StateFlow<Map<EstadosMercadillo.Estado, Int>> = flow {
        while (true) {
            emit(repository.getEstadisticasPorEstado())
            kotlinx.coroutines.delay(5 * 60_000) // Actualizar cada 5 minutos
        }
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyMap())

    // ========== SINCRONIZACI√ìN ==========

    /**
     * Fuerza sincronizaci√≥n manual
     */
    fun forzarSincronizacion() {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(loading = true, error = null)

            try {
                val exito = repository.forzarSincronizacion()

                _uiState.value = _uiState.value.copy(
                    loading = false,
                    message = if (exito) "Sincronizaci√≥n completada" else "Error en sincronizaci√≥n",
                    error = if (!exito) "No se pudo completar la sincronizaci√≥n" else null
                )

                Log.d(TAG, if (exito) "‚úÖ Sincronizaci√≥n forzada exitosa" else "‚ö†Ô∏è Error en sincronizaci√≥n forzada")

            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    loading = false,
                    error = "Error en sincronizaci√≥n: ${e.message}"
                )
                Log.e(TAG, "‚ùå Error en sincronizaci√≥n forzada", e)
            }
        }
    }

    /**
     * Sincroniza SOLO desde Firebase sin recalcular estados autom√°ticos
     */
    fun sincronizarSoloDesdeFirebase() {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(loading = true, error = null)

            try {
                val userId = ConfigurationManager.getCurrentUserId()
                if (userId != null) {
                    // Solo sincronizar mercadillos pendientes y descargar de Firebase
                    // SIN llamar a actualizarEstadosAutomaticos()
                    repository.sincronizarSinEstadosAutomaticos()

                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        message = "Sincronizaci√≥n completada (sin cambios autom√°ticos)",
                        error = null
                    )
                    Log.d(TAG, "‚úÖ Sincronizaci√≥n desde Firebase sin estados autom√°ticos")
                }
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    loading = false,
                    error = "Error en sincronizaci√≥n: ${e.message}"
                )
                Log.e(TAG, "‚ùå Error en sincronizaci√≥n desde Firebase", e)
            }
        }
    }

    // ========== GESTI√ìN DE UI ==========

    /**
     * Limpia mensajes de error o √©xito
     */
    fun limpiarMensajes() {
        _uiState.value = _uiState.value.copy(
            error = null,
            message = null
        )
    }

    /**
     * Limpia solo el mensaje de error
     */
    fun limpiarError() {
        _uiState.value = _uiState.value.copy(error = null)
    }

    /**
     * Limpia solo el mensaje de √©xito
     */
    fun limpiarMensaje() {
        _uiState.value = _uiState.value.copy(message = null)
    }

    // ========== VALIDACIONES EXISTENTES ==========

    /**
     * Valida si una fecha es v√°lida
     */
    fun validarFecha(fecha: String): String? {
        return when {
            fecha.isBlank() -> "La fecha no puede estar vac√≠a"
            !fecha.matches(Regex("\\d{2}-\\d{2}-\\d{4}")) -> "Formato de fecha inv√°lido (dd-MM-yyyy)"
            else -> {
                try {
                    dateFormat.parse(fecha)
                    null
                } catch (e: Exception) {
                    "Fecha inv√°lida"
                }
            }
        }
    }

    /**
     * Valida si un lugar es v√°lido
     */
    fun validarLugar(lugar: String): String? {
        return when {
            lugar.isBlank() -> "El lugar no puede estar vac√≠o"
            lugar.length < 3 -> "El lugar debe tener al menos 3 caracteres"
            lugar.length > 100 -> "El lugar no puede tener m√°s de 100 caracteres"
            else -> null
        }
    }

    /**
     * Valida si un organizador es v√°lido
     */
    fun validarOrganizador(organizador: String): String? {
        return when {
            organizador.isBlank() -> "El organizador no puede estar vac√≠o"
            organizador.length < 3 -> "El organizador debe tener al menos 3 caracteres"
            organizador.length > 100 -> "El organizador no puede tener m√°s de 100 caracteres"
            else -> null
        }
    }

    /**
     * Valida horarios de inicio y fin
     */
    fun validarHorarios(horaInicio: String, horaFin: String): String? {
        return when {
            !horaInicio.matches(Regex("\\d{2}:\\d{2}")) -> "Formato de hora de inicio inv√°lido (HH:mm)"
            !horaFin.matches(Regex("\\d{2}:\\d{2}")) -> "Formato de hora de fin inv√°lido (HH:mm)"
            else -> {
                try {
                    val inicio = timeFormat.parse(horaInicio)
                    val fin = timeFormat.parse(horaFin)
                    if (inicio != null && fin != null && inicio.after(fin)) {
                        "La hora de inicio debe ser anterior a la hora de fin"
                    } else null
                } catch (e: Exception) {
                    "Horarios inv√°lidos"
                }
            }
        }
    }

    /**
     * Valida importe de suscripci√≥n
     */
    fun validarImporteSuscripcion(importe: Double): String? {
        return when {
            importe < 0 -> "El importe no puede ser negativo"
            importe > 999999.99 -> "El importe es demasiado alto"
            else -> null
        }
    }

    /**
     * Valida saldo inicial
     */
    fun validarSaldoInicial(saldo: Double): String? {
        return when {
            saldo < 0 -> "El saldo inicial no puede ser negativo"
            saldo > 999999.99 -> "El saldo inicial es demasiado alto"
            else -> null
        }
    }

    /**
     * Valida saldo final
     */
    fun validarSaldoFinal(saldo: Double): String? {
        return when {
            saldo < 0 -> "El saldo final no puede ser negativo"
            saldo > 999999.99 -> "El saldo final es demasiado alto"
            else -> null
        }
    }

    // ========== UTILIDADES ==========

    /**
     * Obtiene el n√∫mero total de mercadillos del usuario
     */
    val totalMercadillos: StateFlow<Int> = mercadillos
        .map { it.size }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), 0)

    /**
     * Indica si hay mercadillos creados
     */
    val tieneMercadillos: StateFlow<Boolean> = mercadillos
        .map { it.isNotEmpty() }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), false)

    /**
     * Obtiene el nombre del mes actual en espa√±ol
     */
    val nombreMesActual: StateFlow<String> = calendarioState.map { estado ->
        val meses = arrayOf(
            "Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio",
            "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"
        )
        "${meses[estado.mes - 1]} ${estado.ano}"
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), "")

    /**
     * Obtiene informaci√≥n de un d√≠a espec√≠fico del calendario
     */
    fun getInformacionDia(dia: Int): List<EstadosMercadillo.Estado> {
        val mercadillosDelDia = mercadillosPorDia.value[dia] ?: emptyList()
        return mercadillosDelDia.map { mercadillo ->
            EstadosMercadillo.Estado.fromCodigo(mercadillo.estado)
                ?: EstadosMercadillo.Estado.PROGRAMADO_PARCIAL
        }.sortedBy { EstadosMercadillo.obtenerPrioridad(it) }
    }

    /**
     * Verifica si un mercadillo puede recibir ventas
     */
    fun puedeRecibirVentas(mercadillo: MercadilloEntity): Boolean {
        val estado = EstadosMercadillo.Estado.fromCodigo(mercadillo.estado)
            ?: EstadosMercadillo.Estado.PROGRAMADO_PARCIAL
        return EstadosMercadillo.puedeRecibirVentas(estado)
    }

    /**
     * Verifica si un mercadillo puede ser cancelado
     */
    fun puedeSerCancelado(mercadillo: MercadilloEntity, tieneVentas: Boolean): Boolean {
        val estado = EstadosMercadillo.Estado.fromCodigo(mercadillo.estado)
            ?: EstadosMercadillo.Estado.PROGRAMADO_PARCIAL
        return EstadosMercadillo.puedeSerCancelado(estado, tieneVentas)
    }

    /**
     * Recarga todos los datos cuando cambia el usuario
     */
    fun recargarDatos() {
        viewModelScope.launch {
            Log.d(TAG, "üîÑ Recargando datos para nuevo usuario")

            // Actualizar estados autom√°ticos del nuevo usuario
            val userId = ConfigurationManager.getCurrentUserId()
            if (userId != null && userId != "usuario_default") {
                repository.actualizarEstadosAutomaticos(userId)
            }
        }
    }
}

/**
 * Estado de la UI del MercadilloViewModel
 */
data class MercadilloUiState(
    val loading: Boolean = false,
    val error: String? = null,
    val message: String? = null
)

/**
 * Estado del calendario
 */
data class CalendarioState(
    val ano: Int = Calendar.getInstance().get(Calendar.YEAR),
    val mes: Int = Calendar.getInstance().get(Calendar.MONTH) + 1 // 1-based para facilidad de uso
)

// app/src/main/java/es/nuskysoftware/marketsales/ui/viewmodel/MercadilloViewModelFactory.kt
package es.nuskysoftware.marketsales.ui.viewmodel

import android.content.Context
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import es.nuskysoftware.marketsales.data.repository.MercadilloRepository

/**
 * Factory para MercadilloViewModel que inyecta MercadilloRepository con Context
 * ‚úÖ FINAL: Context requerido para MercadilloRepository (AppDatabase + ConnectivityObserver)
 */
class MercadilloViewModelFactory(
    private val context: Context
) : ViewModelProvider.Factory {

    @Suppress("UNCHECKED_CAST")
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(MercadilloViewModel::class.java)) {
            return MercadilloViewModel(MercadilloRepository(context)) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class: ${modelClass.name}")
    }
}

// app/src/main/java/es/nuskysoftware/marketsales/utils/EstadosMercadillo.kt
package es.nuskysoftware.marketsales.utils

import android.util.Log
import androidx.compose.ui.graphics.Color
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Locale

/**
 * EstadosMercadillo V11 - Market Sales
 *
 * ‚úÖ Sistema centralizado para gestionar todos los estados de mercadillos
 * ‚úÖ Incluye colores, descripciones y l√≥gica relacionada
 * ‚úÖ Estados autom√°ticos basados en condiciones de negocio
 * ‚úÖ Compatible con arquitectura h√≠brida "Reloj Suizo"
 */
object EstadosMercadillo {

    /**
     * Enum con todos los estados posibles de un mercadillo
     * Los c√≥digos coinciden con el campo 'estado' en MercadilloEntity
     */
    enum class Estado(val codigo: Int, val descripcion: String) {
        PROGRAMADO_PARCIAL(1, "Programado parcialmente"),
        PROGRAMADO_TOTAL(2, "Programado totalmente"),
        EN_CURSO(3, "En curso"),
        PENDIENTE_ARQUEO(4, "Terminado (pendiente arqueo)"),
        PENDIENTE_ASIGNAR_SALDO(5, "Arqueo realizado (pendiente asignar saldo)"),
        CERRADO_COMPLETO(6, "Cerrado completamente"),
        CANCELADO(7, "Cancelado");

        companion object {
            /**
             * Obtiene el estado por su c√≥digo
             */
            fun fromCodigo(codigo: Int): Estado? = values().find { it.codigo == codigo }

            /**
             * Obtiene el estado por defecto para nuevos mercadillos
             */
            fun getEstadoInicial(): Estado = PROGRAMADO_PARCIAL
        }
    }

    /**
     * Obtiene el color asociado a cada estado para la UI
     */
    fun obtenerColor(estado: Estado): Color {
        return when (estado) {
            Estado.PROGRAMADO_PARCIAL -> Color(0xFF81C7E8)      // Azul claro
            Estado.PROGRAMADO_TOTAL -> Color(0xFF1976D2)        // Azul oscuro
            Estado.EN_CURSO -> Color(0xFF4CAF50)                // Verde
            Estado.PENDIENTE_ARQUEO -> Color(0xFFFF9800)        // Naranja ‚ö†Ô∏è
            Estado.PENDIENTE_ASIGNAR_SALDO -> Color(0xFFF44336) // Rojo ‚ö†Ô∏è
            Estado.CERRADO_COMPLETO -> Color(0xFF2E7D32)        // Verde oscuro
            Estado.CANCELADO -> Color(0xFF757575)               // Gris
        }
    }

    /**
     * Obtiene el color de texto m√°s apropiado para cada fondo
     */
    fun obtenerColorTexto(estado: Estado): Color {
        return when (estado) {
            Estado.PROGRAMADO_PARCIAL -> Color.Black
            Estado.PROGRAMADO_TOTAL -> Color.White
            Estado.EN_CURSO -> Color.White
            Estado.PENDIENTE_ARQUEO -> Color.Black
            Estado.PENDIENTE_ASIGNAR_SALDO -> Color.White
            Estado.CERRADO_COMPLETO -> Color.White
            Estado.CANCELADO -> Color.White
        }
    }

    /**
     * Devuelve todos los estados para mostrar en la leyenda
     */
    fun obtenerTodosLosEstados(): List<Estado> {
        return Estado.values().toList()
    }

    /**
     * Obtiene el icono/emoji representativo de cada estado
     */
    fun obtenerIcono(estado: Estado): String {
        return when (estado) {
            Estado.PROGRAMADO_PARCIAL -> "üìã"
            Estado.PROGRAMADO_TOTAL -> "üìÖ"
            Estado.EN_CURSO -> "üü¢"
            Estado.PENDIENTE_ARQUEO -> "‚ö†Ô∏è"
            Estado.PENDIENTE_ASIGNAR_SALDO -> "üî¥"
            Estado.CERRADO_COMPLETO -> "‚úÖ"
            Estado.CANCELADO -> "‚ùå"
        }
    }

    /**
     * Indica si el estado requiere atenci√≥n urgente del usuario
     */
    fun requiereAtencion(estado: Estado): Boolean {
        return estado == Estado.PENDIENTE_ARQUEO || estado == Estado.PENDIENTE_ASIGNAR_SALDO
    }

    /**
     * Obtiene el orden de prioridad para mostrar en calendario cuando hay m√∫ltiples mercadillos
     * Menor n√∫mero = mayor prioridad
     */
    fun obtenerPrioridad(estado: Estado): Int {
        return when (estado) {
            Estado.EN_CURSO -> 1                    // M√°xima prioridad
            Estado.PENDIENTE_ARQUEO -> 2            // Urgente
            Estado.PENDIENTE_ASIGNAR_SALDO -> 3     // Urgente
            Estado.PROGRAMADO_TOTAL -> 4
            Estado.PROGRAMADO_PARCIAL -> 5
            Estado.CERRADO_COMPLETO -> 6
            Estado.CANCELADO -> 7                   // M√≠nima prioridad
        }
    }

    /**
     * Indica si un mercadillo puede ser cancelado
     * Solo se puede cancelar si no tiene ventas asociadas
     */
    fun puedeSerCancelado(estado: Estado, tieneVentas: Boolean): Boolean {
        return !tieneVentas && estado != Estado.CANCELADO && estado != Estado.CERRADO_COMPLETO
    }

    /**
     * Indica si se pueden asignar ventas a un mercadillo
     * Solo se pueden asignar ventas a mercadillos EN_CURSO
     */
    fun puedeRecibirVentas(estado: Estado): Boolean {
        return estado == Estado.EN_CURSO
    }

    /**
     * Calcula el estado autom√°tico basado en fecha, hora y datos del mercadillo
     */
    fun calcularEstadoAutomatico(
        saldoInicial: Double?,
        fecha: String,
        horaFin: String,
        arqueoCaja: Double?,
        pendienteAsignarSaldo: Boolean,
        fechaActual: String,
        horaActual: String
    ): Estado {
        try {
            val dateFormat = SimpleDateFormat("dd-MM-yyyy", Locale.getDefault())
            val timeFormat = SimpleDateFormat("HH:mm", Locale.getDefault())

            val fechaMercadillo = dateFormat.parse(fecha)
            val fechaHoy = dateFormat.parse(fechaActual)
            val horaFinMercadillo = timeFormat.parse(horaFin)
            val horaAhora = timeFormat.parse(horaActual)

            if (fechaMercadillo == null || fechaHoy == null || horaFinMercadillo == null || horaAhora == null) {
                return Estado.PROGRAMADO_PARCIAL
            }

            // Calcular ayer
            val calendar = Calendar.getInstance()
            calendar.time = fechaHoy
            calendar.add(Calendar.DAY_OF_MONTH, -1)
            val ayer = calendar.time

            // Si es anterior a ayer ‚Üí mantener estado actual
            if (fechaMercadillo.before(ayer)) {
                return when {
                    arqueoCaja != null -> Estado.CERRADO_COMPLETO
                    pendienteAsignarSaldo -> Estado.PENDIENTE_ASIGNAR_SALDO
                    else -> if (saldoInicial != null) Estado.PROGRAMADO_TOTAL else Estado.PROGRAMADO_PARCIAL
                }
            }

            // Si es ma√±ana o futuro ‚Üí PROGRAMADO
            if (fechaMercadillo.after(fechaHoy)) {
                return if (saldoInicial != null) Estado.PROGRAMADO_TOTAL else Estado.PROGRAMADO_PARCIAL
            }

            // Si es HOY ‚Üí ACTUAL
            if (fechaMercadillo.equals(fechaHoy)) {
                return Estado.EN_CURSO
            }

            // Si es AYER y son menos de las 5:00am ‚Üí ACTUAL (mercadillos nocturnos)
            calendar.time = fechaHoy
            calendar.set(Calendar.HOUR_OF_DAY, 5)
            calendar.set(Calendar.MINUTE, 0)
            calendar.set(Calendar.SECOND, 0)
            val cincoAM = timeFormat.format(calendar.time)
            val cincoAMTime = timeFormat.parse(cincoAM)

            if (fechaMercadillo.equals(ayer) && horaAhora != null && cincoAMTime != null && horaAhora.before(cincoAMTime)) {
                return Estado.EN_CURSO
            }

            // Si es AYER y son las 5:00am o m√°s tarde ‚Üí PENDIENTE_ARQUEO
            if (fechaMercadillo.equals(ayer)) {
                return when {
                    arqueoCaja != null && pendienteAsignarSaldo -> Estado.PENDIENTE_ASIGNAR_SALDO
                    arqueoCaja != null -> Estado.CERRADO_COMPLETO
                    else -> Estado.PENDIENTE_ARQUEO
                }
            }

            // Por defecto
            return when {
                arqueoCaja != null && !pendienteAsignarSaldo -> Estado.CERRADO_COMPLETO
                arqueoCaja != null && pendienteAsignarSaldo -> Estado.PENDIENTE_ASIGNAR_SALDO
                else -> Estado.PENDIENTE_ARQUEO
            }

        } catch (e: Exception) {
            Log.e("EstadosMercadillo", "Error calculando estado autom√°tico", e)
            return if (saldoInicial != null) Estado.PROGRAMADO_TOTAL else Estado.PROGRAMADO_PARCIAL
        }
    }
}



// app/src/main/java/es/nuskysoftware/marketsales/utils/ConfigurationManager.kt
package es.nuskysoftware.marketsales.utils

import android.content.ContentValues.TAG
import android.util.Log
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow

/**
 * ‚úÖ COMPLETO V10 - ConfigurationManager con TODOS los m√©todos necesarios
 */
object ConfigurationManager {

    // ========== ESTADOS V10 ==========
    private val _idioma = MutableStateFlow("es")
    private val _fuente = MutableStateFlow("Montserrat")
    private val _temaOscuro = MutableStateFlow(false)
    private val _moneda = MutableStateFlow("‚Ç¨ Euro")
    private val _usuarioLogueado = MutableStateFlow<String?>("usuario_default")
    // O si quieres que el valor inicial cuando nadie est√° logueado sea null:
    // private val _usuarioLogueado = MutableStateFlow<String?>(null)
    private val _usuarioEmail = MutableStateFlow<String?>(null)
    private val _displayName = MutableStateFlow<String?>(null)
    private val _versionApp = MutableStateFlow(0) // Para compatibilidad

    private val _isAuthenticated = MutableStateFlow(false)

    private var lastSuccessfulPremiumState: Boolean? = null

    private var lastUpdateTimestamp = 0L


    // ========== ESTADOS P√öBLICOS ==========
    val idioma: StateFlow<String> = _idioma.asStateFlow()
    val fuente: StateFlow<String> = _fuente.asStateFlow()
    val temaOscuro: StateFlow<Boolean> = _temaOscuro.asStateFlow()
    val moneda: StateFlow<String> = _moneda.asStateFlow()
    val usuarioEmail: StateFlow<String?> = _usuarioEmail.asStateFlow()
    val versionApp: StateFlow<Int> = _versionApp.asStateFlow()

    val isAuthenticated: StateFlow<Boolean> = _isAuthenticated.asStateFlow()
    val displayName: StateFlow<String?> = _displayName.asStateFlow()
    val usuarioLogueado: StateFlow<String?> = _usuarioLogueado.asStateFlow()

    private val _esPremium = MutableStateFlow(false)
    val esPremium: StateFlow<Boolean> = _esPremium.asStateFlow()

    /**
     * Toggle Premium para desarrollo - SIMPLIFICADO SIN PROTECCIONES
     */
    fun togglePremiumForDevelopment() {
        val newValue = !_esPremium.value

        Log.d("ConfigurationManager", "üîß TOGGLE PREMIUM (Development):")
        Log.d("ConfigurationManager", "   - Antes: ${_esPremium.value}")
        Log.d("ConfigurationManager", "   - Despu√©s: $newValue")

        // Cambio directo sin protecciones para desarrollo
        _esPremium.value = newValue
        _versionApp.value = if (newValue) 1 else 0

        Log.d("ConfigurationManager", "‚úÖ Premium toggled exitosamente")
    }

    /**
     * Establece estado premium directamente (para desarrollo)
     */
    fun setPremiumForDevelopment(isPremium: Boolean) {
        Log.d("ConfigurationManager", "üîß SET PREMIUM (Development): ${_esPremium.value} ‚Üí $isPremium")

        _esPremium.value = isPremium
        _versionApp.value = if (isPremium) 1 else 0

        Log.d("ConfigurationManager", "‚úÖ Premium establecido: $isPremium")
    }

    // ========== M√âTODOS PRINCIPALES ==========
    fun updateUserConfigurationProtected(
        displayName: String? = null,
        usuarioEmail: String? = null,
        planUsuario: String = "FREE",
        isAuthenticated: Boolean = false,
        source: String = "unknown"
    ) {
        val currentTime = System.currentTimeMillis()

        // ‚úÖ PROTECCI√ìN: Si el displayName cambi√≥ hace menos de 5 segundos, no sobrescribir
        if (displayName != null && _displayName.value != displayName) {
            if (currentTime - lastUpdateTimestamp < 5000) {
                Log.w("ConfigurationManager", "üö´ PROTECCI√ìN: Evitando sobrescribir displayName reciente")
                Log.w("ConfigurationManager", "   - Valor actual: ${_displayName.value}")
                Log.w("ConfigurationManager", "   - Valor que se quiere poner: $displayName")
                Log.w("ConfigurationManager", "   - Tiempo desde √∫ltimo cambio: ${currentTime - lastUpdateTimestamp}ms")
                return
            }
        }

        // Actualizar timestamp si hay cambio de displayName
        if (displayName != null && _displayName.value != displayName) {
            lastUpdateTimestamp = currentTime
            Log.d("ConfigurationManager", "üïí Actualizando timestamp de protecci√≥n")
        }

        // Llamar al m√©todo normal
        updateUserConfiguration(
            displayName = displayName,
            usuarioEmail = usuarioEmail,
            planUsuario = planUsuario,
            isAuthenticated = isAuthenticated
        )
    }
    /**
     * Obtiene el ID del usuario actual
     */
    fun getCurrentUserId(): String? {
        return _usuarioLogueado.value
    }

    // ========== M√âTODOS GET ==========
    fun getIdioma(): String = _idioma.value
    fun getFuente(): String = _fuente.value
    fun getModoOscuro(): Boolean = _temaOscuro.value
    fun getTemaOscuro(): Boolean = _temaOscuro.value
    fun getMoneda(): String = _moneda.value
    fun getUsuarioEmail(): String? = _usuarioEmail.value
    fun getUsuarioId(): String? = _usuarioLogueado.value.takeIf { it != "usuario_default" }
    fun getVersionApp(): Int = _versionApp.value
    fun getIsPremium(): Boolean = _esPremium.value

    // ========== M√âTODOS DE AUTENTICACI√ìN ==========

    /**
     * Login de usuario
     */
    fun login(userId: String, email: String?, displayName: String? = null, isPremium: Boolean = false) {
        _usuarioLogueado.value = userId
        _usuarioEmail.value = email
        _displayName.value = displayName
       //_esPremium.value = isPremium
        setEsPremiumProtected(isPremium, "updateUserConfiguration")

        _versionApp.value = if (isPremium) 1 else 0
        _isAuthenticated.value = true
    }


    private fun setEsPremiumProtected(newValue: Boolean, source: String = "unknown") {
        val oldValue = _esPremium.value

        Log.d("ConfigurationManager", "üîÑ INTENTO CAMBIO esPremium: $oldValue ‚Üí $newValue")
        Log.d("ConfigurationManager", "   - Fuente: $source")
        Log.d("ConfigurationManager", "   - lastSuccessfulPremiumState: $lastSuccessfulPremiumState")
        Log.d("ConfigurationManager", "   - isAuthenticated: ${_isAuthenticated.value}")

        // üõ°Ô∏è PROTECCI√ìN MEJORADA: Solo bloquear si usuario est√° autenticado
        if (oldValue == true && newValue == false && _isAuthenticated.value == true) {
            Log.e("ConfigurationManager", "üö® BLOQUEANDO CAMBIO - Usuario autenticado premium")
            Thread.currentThread().stackTrace.take(15).forEach { frame ->
                Log.e("ConfigurationManager", "     at ${frame.className}.${frame.methodName}(${frame.fileName}:${frame.lineNumber})")
            }
            return
        }

        // ‚úÖ PERMITIR logout cuando isAuthenticated = false
        if (oldValue == true && newValue == false && _isAuthenticated.value == false) {
            Log.w("ConfigurationManager", "‚úÖ PERMITIENDO logout - Usuario no autenticado")
        }

        _esPremium.value = newValue
        Log.d("ConfigurationManager", "‚úÖ esPremium cambiado: $oldValue ‚Üí $newValue (fuente: $source)")
    }
    /**
     * Logout de usuario
     */

    fun logout() {
        Log.d("ConfigurationManager", "üö™ logout() llamado!")
        Log.d("ConfigurationManager", "   - esPremium antes: ${_esPremium.value}")
        Log.d("ConfigurationManager", "   - STACK TRACE:")
        Thread.currentThread().stackTrace.take(8).forEach { frame ->
            Log.d("ConfigurationManager", "     at ${frame.className}.${frame.methodName}(${frame.fileName}:${frame.lineNumber})")
        }

        // üîì Limpiar estado de protecci√≥n en logout real
        lastSuccessfulPremiumState = null
        Log.d("ConfigurationManager", "   - Protecci√≥n premium limpiada")

        // üîÑ Llamar a reset despu√©s de limpiar protecci√≥n
        resetToDefaults()

        Log.d("ConfigurationManager", "   - esPremium despu√©s: ${_esPremium.value}")
        Log.d("ConfigurationManager", "   - ‚úÖ Logout completado")
    }
    // ========== M√âTODOS DE CONFIGURACI√ìN ==========

    /**
     * Verifica si el usuario puede cambiar configuraci√≥n
     */
    fun canChangeConfiguration(): Boolean {
        return _esPremium.value
    }

    /**
     * Actualiza configuraci√≥n global
     */
    fun updateGlobalConfiguration(
        idioma: String,
        fuente: String,
        temaOscuro: Boolean,
        moneda: String
    ) {
        _idioma.value = idioma
        _fuente.value = fuente
        _temaOscuro.value = temaOscuro
        _moneda.value = moneda
    }

    /**
     * Actualiza premium del usuario
     */
    fun updateUserPremium(isPremium: Boolean) {
        setEsPremiumProtected(isPremium, "updateUserConfiguration")
        _versionApp.value = if (isPremium) 1 else 0
    }

    // ========== M√âTODOS UPDATE EXISTENTES ==========
    fun updateConfiguration(
        idioma: String,
        fuente: String,
        modoOscuro: Boolean,
        isPremium: Boolean
    ) {
        _idioma.value = idioma
        _fuente.value = fuente
        _temaOscuro.value = modoOscuro
        setEsPremiumProtected(isPremium, "updateUserConfiguration")
        _versionApp.value = if (isPremium) 1 else 0
    }

    // A√±ade estos logs TEMPORALES en ConfigurationManager.kt en estos m√©todos:

    fun updateUserConfiguration(
        idioma: String = _idioma.value,
        fuente: String = _fuente.value,
        temaOscuro: Boolean = _temaOscuro.value,
        usuarioEmail: String? = _usuarioEmail.value,
        usuarioId: String? = null,
        planUsuario: String = "FREE",
        empresaId: String? = null,
        tipoUsuario: String? = null,
        displayName: String? = null,
        photoUrl: String? = null,
        isAuthenticated: Boolean = false,
        moneda: String = _moneda.value ,


        ) {
        // üîç LOG TEMPORAL
        Log.d("ConfigurationManager", "üîß updateUserConfiguration llamado:")
        Log.d("ConfigurationManager", "   - planUsuario: $planUsuario")
        Log.d("ConfigurationManager", "   - isAuthenticated: $isAuthenticated")
        Log.d("ConfigurationManager", "   - esPremium antes: ${_esPremium.value}")

        Log.d("ConfigurationManager", "üîß updateUserConfiguration - displayName recibido: $displayName")
        Log.d("ConfigurationManager", "üîß _displayName.value antes: ${_displayName.value}")

        Log.d("ConfigurationManager", "üîß FINAL updateUserConfiguration:")
        Log.d("ConfigurationManager", "   - displayName: ${_displayName.value}")
        Log.d("ConfigurationManager", "   - isAuthenticated: ${_isAuthenticated.value}")
        Log.d("ConfigurationManager", "   - esPremium: ${_esPremium.value}")


        // Actualizar valores de configuraci√≥n
        _idioma.value = idioma
        _fuente.value = fuente
        _temaOscuro.value = temaOscuro
        _usuarioEmail.value = usuarioEmail
        _displayName.value = displayName
        _moneda.value = moneda
        _isAuthenticated.value = isAuthenticated

        // Calcular estado premium
        val isPremium = planUsuario == "PREMIUM" && isAuthenticated
        setEsPremiumProtected(isPremium, "updateUserConfiguration")
        _versionApp.value = if (isPremium) 1 else 0

        // Configurar usuario
        _usuarioLogueado.value = if (isAuthenticated && usuarioId != null) {
            usuarioId
        } else {
            "usuario_default"
        }

        // üíæ Guardar √∫ltimo estado premium v√°lido para protecci√≥n
        if (isPremium) {
            lastSuccessfulPremiumState = true
            Log.d("ConfigurationManager", "   - esPremium despu√©s: ${_esPremium.value}")
        }
        if (displayName != null) {
            _displayName.value = displayName
        }

        Log.d("ConfigurationManager", "üîß _displayName.value despu√©s: ${_displayName.value}")

        // ... resto del c√≥digo ...


        // üîç LOG TEMPORAL
        Log.d("ConfigurationManager", "   - esPremium despu√©s: ${_esPremium.value}")
        Log.d("ConfigurationManager", "   - STACK TRACE:")
        Thread.currentThread().stackTrace.take(8).forEach { frame ->
            Log.d("ConfigurationManager", "     at ${frame.className}.${frame.methodName}(${frame.fileName}:${frame.lineNumber})")
        }
    }

    fun forceUpdateDisplayName(newDisplayName: String) {
        Log.d(TAG, "üîß forceUpdateDisplayName: ${_displayName.value} ‚Üí $newDisplayName")
        _displayName.value = newDisplayName
        Log.d(TAG, "üîß forceUpdateDisplayName DESPU√âS: ${_displayName.value}")
    }


    // ========== M√âTODOS SET ==========
    fun setIdioma(idioma: String) {
        _idioma.value = idioma
    }

    fun setFuente(fuente: String) {
        _fuente.value = fuente
    }

    fun setTemaOscuro(temaOscuro: Boolean) {
        _temaOscuro.value = temaOscuro
    }

    fun setModoOscuro(modoOscuro: Boolean) {
        _temaOscuro.value = modoOscuro
    }

    fun setUsuarioEmail(email: String?) {
        _usuarioEmail.value = email
    }

    fun setUsuarioLogueado(userId: String?) {
        _usuarioLogueado.value = userId ?: "usuario_default"
    }

    fun setUsuarioId(userId: String?) {
        setUsuarioLogueado(userId)
    }

    fun setMoneda(moneda: String) {
        _moneda.value = moneda
    }

    fun setIsPremium(isPremium: Boolean) {
        setEsPremiumProtected(isPremium, "updateUserConfiguration")
        _versionApp.value = if (isPremium) 1 else 0
    }

    fun setVersionApp(versionApp: Int) {
        _versionApp.value = versionApp
        setEsPremiumProtected(versionApp == 1, "setVersionApp")
    }

    fun resetToDefaults() {
        // üîç LOG TEMPORAL
        Log.d("ConfigurationManager", "üîÑ resetToDefaults() llamado!")
        Log.d("ConfigurationManager", "   - esPremium antes: ${_esPremium.value}")
        Log.d("ConfigurationManager", "   - lastSuccessfulPremiumState: $lastSuccessfulPremiumState")
        Log.d("ConfigurationManager", "   - STACK TRACE:")
        Thread.currentThread().stackTrace.take(8).forEach { frame ->
            Log.d("ConfigurationManager", "     at ${frame.className}.${frame.methodName}(${frame.fileName}:${frame.lineNumber})")
        }

        // üõ°Ô∏è PROTECCI√ìN: No resetear si hay un estado premium v√°lido y el usuario est√° autenticado
        if (lastSuccessfulPremiumState == true && _isAuthenticated.value) {
            Log.w("ConfigurationManager", "üö´ EVITANDO RESET - Usuario premium autenticado detectado")
            return
        }

        // Resetear todos los valores a defaults
        _idioma.value = "es"
        _fuente.value = "Montserrat"
        _temaOscuro.value = false
        _moneda.value = "‚Ç¨ Euro"
        _usuarioLogueado.value = "usuario_default"
        _usuarioEmail.value = null
        _displayName.value = null
        setEsPremiumProtected(false, "resetToDefaults")
        _versionApp.value = 0
        _isAuthenticated.value = false

        // Limpiar estado de protecci√≥n solo en logout real
        lastSuccessfulPremiumState = null

        Log.d("ConfigurationManager", "   - ‚úÖ Reset completado")

        Log.d("ConfigurationManager", "   - esPremium despu√©s: ${_esPremium.value}")
        Log.d("ConfigurationManager", "   - ‚úÖ Reset completado")
    }

    // ========== VERIFICACIONES ==========
    fun isUsuarioLogueado(): Boolean {
        return _usuarioLogueado.value != "usuario_default"
    }

    fun isPremium(): Boolean = _esPremium.value
    fun isFree(): Boolean = !_esPremium.value
}






