// app/src/main/java/es/nuskysoftware/marketsales/data/local/dao/ArticuloDao.kt
package es.nuskysoftware.marketsales.data.local.dao

import androidx.room.*
import es.nuskysoftware.marketsales.data.local.entity.ArticuloEntity
import kotlinx.coroutines.flow.Flow

/**
 * ArticuloDao V11 - Market Sales
 *
 * DIFERENCIAS CON CAJA MERCADILLOS:
 * - Todas las consultas filtradas por userId
 * - Arquitectura h√≠brida con sincronizadoFirebase
 * - Compatibilidad con sistema "Reloj Suizo"
 */
@Dao
interface ArticuloDao {

    // ========== OPERACIONES B√ÅSICAS ==========

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsertAll(items: List<ArticuloEntity>)

    @Query("DELETE FROM articulos WHERE userId = :userId")
    suspend fun borrarPorUsuario(userId: String)

    @Upsert
    suspend fun upsert(articulo: ArticuloEntity)

    @Query("SELECT EXISTS(SELECT 1 FROM articulos WHERE userId = :uid LIMIT 1)")
    suspend fun existeAlgunoDeUsuario(uid: String): Boolean

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertArticulo(articulo: ArticuloEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOrUpdate(articulo: ArticuloEntity)

    @Update
    suspend fun updateArticulo(articulo: ArticuloEntity)

    @Delete
    suspend fun deleteArticulo(articulo: ArticuloEntity)

    // ========== CONSULTAS FILTRADAS POR USUARIO ==========

    /**
     * Obtiene todos los art√≠culos del usuario actual ordenados por nombre
     */
    @Query("SELECT * FROM articulos WHERE userId = :userId AND activo = 1 ORDER BY nombre ASC")
    fun getArticulosByUser(userId: String): Flow<List<ArticuloEntity>>

    /**
     * Obtiene art√≠culos filtrados por categor√≠a
     */
    @Query("SELECT * FROM articulos WHERE userId = :userId AND idCategoria = :categoriaId AND activo = 1 ORDER BY nombre ASC")
    fun getArticulosByUserAndCategoria(userId: String, categoriaId: String): Flow<List<ArticuloEntity>>

    /**
     * Obtiene un art√≠culo espec√≠fico por ID
     */
    @Query("SELECT * FROM articulos WHERE idArticulo = :id")
    suspend fun getArticuloById(id: String): ArticuloEntity?

    /**
     * Elimina art√≠culo por ID
     */
    @Query("DELETE FROM articulos WHERE idArticulo = :id")
    suspend fun deleteArticuloById(id: String)

    // ========== SINCRONIZACI√ìN H√çBRIDA ==========

    /**
     * Obtiene art√≠culos no sincronizados de un usuario espec√≠fico
     */
    @Query("SELECT * FROM articulos WHERE userId = :userId AND sincronizadoFirebase = 0")
    suspend fun getArticulosNoSincronizadosByUser(userId: String): List<ArticuloEntity>

    /**
     * Marca art√≠culo como sincronizado
     */
    @Query("UPDATE articulos SET sincronizadoFirebase = 1, lastModified = :timestamp WHERE idArticulo = :id")
    suspend fun marcarComoSincronizado(id: String, timestamp: Long = System.currentTimeMillis())

    /**
     * Marca art√≠culo como no sincronizado (para cambios locales)
     */
    @Query("UPDATE articulos SET sincronizadoFirebase = 0 WHERE idArticulo = :id")
    suspend fun marcarComoNoSincronizado(id: String)

    /**
     * Obtiene la versi√≥n actual de un art√≠culo
     */
    @Query("SELECT version FROM articulos WHERE idArticulo = :id")
    suspend fun getArticuloVersion(id: String): Long?

    // ========== UTILIDADES ==========

    /**
     * Cuenta el total de art√≠culos de un usuario
     */
    @Query("SELECT COUNT(*) FROM articulos WHERE userId = :userId AND activo = 1")
    suspend fun getArticuloCountByUser(userId: String): Int

    /**
     * Verifica si existe un art√≠culo con el mismo nombre para un usuario
     */
    @Query("SELECT COUNT(*) > 0 FROM articulos WHERE userId = :userId AND nombre = :nombre AND activo = 1 AND idArticulo != :excludeId")
    suspend fun existeArticuloConNombre(userId: String, nombre: String, excludeId: String = ""): Boolean

    /**
     * Obtiene nombres √∫nicos de art√≠culos para autocompletado
     */
    @Query("SELECT DISTINCT nombre FROM articulos WHERE userId = :userId AND activo = 1 ORDER BY nombre ASC")
    suspend fun getNombresArticulosUnicos(userId: String): List<String>

    /**
     * Busca art√≠culos por nombre
     */
    @Query("SELECT * FROM articulos WHERE userId = :userId AND nombre LIKE '%' || :query || '%' AND activo = 1 ORDER BY nombre ASC")
    fun searchArticulosByNombre(userId: String, query: String): Flow<List<ArticuloEntity>>

    // ========== MANTENIMIENTO ==========

    /**
     * Elimina art√≠culos inactivos antiguos
     */
    @Query("DELETE FROM articulos WHERE userId = :userId AND activo = 0 AND lastModified < :limiteFecha")
    suspend fun limpiarArticulosInactivosAntiguos(userId: String, limiteFecha: Long)

    /**
     * Resetea sincronizaci√≥n para forzar re-sync
     */
    @Query("UPDATE articulos SET sincronizadoFirebase = 0 WHERE userId = :userId")
    suspend fun resetearSincronizacion(userId: String)
}

// app/src/main/java/es/nuskysoftware/marketsales/data/local/dao/CategoriaDao.kt
package es.nuskysoftware.marketsales.data.local.dao

import androidx.room.*
import es.nuskysoftware.marketsales.data.local.entity.CategoriaEntity
import kotlinx.coroutines.flow.Flow

/**
 * CategoriaDao V11 - Market Sales
 *
 * DIFERENCIAS CON CAJA MERCADILLOS:
 * - Todas las consultas filtradas por userId
 * - Arquitectura h√≠brida con sincronizadoFirebase
 * - Compatibilidad con sistema "Reloj Suizo"
 */
@Dao
interface CategoriaDao {

    // ========== OPERACIONES B√ÅSICAS ==========


    @Upsert
    suspend fun upsert(categoria: CategoriaEntity)

    @Query("SELECT EXISTS(SELECT 1 FROM categorias WHERE userId = :uid LIMIT 1)")
    suspend fun existeAlgunoDeUsuario(uid: String): Boolean
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertCategoria(categoria: CategoriaEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOrUpdate(categoria: CategoriaEntity)

    @Update
    suspend fun updateCategoria(categoria: CategoriaEntity)

    @Delete
    suspend fun deleteCategoria(categoria: CategoriaEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsertAll(items: List<CategoriaEntity>)

    @Query("DELETE FROM categorias WHERE userId = :userId")
    suspend fun borrarPorUsuario(userId: String)

    // ========== CONSULTAS FILTRADAS POR USUARIO ==========

    /**
     * Obtiene todas las categor√≠as del usuario actual ordenadas por nombre
     */


    @Query("SELECT * FROM categorias WHERE userId = :userId AND activa = 1 ORDER BY nombre ASC")
    fun getCategoriasByUser(userId: String): Flow<List<CategoriaEntity>>

    /**
     * Obtiene una categor√≠a espec√≠fica por ID
     */
    @Query("SELECT * FROM categorias WHERE idCategoria = :id")
    suspend fun getCategoriaById(id: String): CategoriaEntity?

    /**
     * Elimina categor√≠a por ID
     */
    @Query("DELETE FROM categorias WHERE idCategoria = :id")
    suspend fun deleteCategoriaById(id: String)

    // ========== SINCRONIZACI√ìN H√çBRIDA ==========

    /**
     * Obtiene categor√≠as no sincronizadas de un usuario espec√≠fico
     */
    @Query("SELECT * FROM categorias WHERE userId = :userId AND sincronizadoFirebase = 0")
    suspend fun getCategoriasNoSincronizadasByUser(userId: String): List<CategoriaEntity>

    /**
     * Marca categor√≠a como sincronizada
     */
    @Query("UPDATE categorias SET sincronizadoFirebase = 1, lastModified = :timestamp WHERE idCategoria = :id")
    suspend fun marcarComoSincronizada(id: String, timestamp: Long = System.currentTimeMillis())

    /**
     * Marca categor√≠a como no sincronizada (para cambios locales)
     */
    @Query("UPDATE categorias SET sincronizadoFirebase = 0 WHERE idCategoria = :id")
    suspend fun marcarComoNoSincronizada(id: String)

    /**
     * Obtiene la versi√≥n actual de una categor√≠a
     */
    @Query("SELECT version FROM categorias WHERE idCategoria = :id")
    suspend fun getCategoriaVersion(id: String): Long?

    // ========== UTILIDADES ==========

    /**
     * Cuenta el total de categor√≠as de un usuario
     */
    @Query("SELECT COUNT(*) FROM categorias WHERE userId = :userId AND activa = 1")
    suspend fun getCategoriaCountByUser(userId: String): Int

    /**
     * Verifica si existe una categor√≠a con el mismo nombre para un usuario
     */
    @Query("SELECT COUNT(*) > 0 FROM categorias WHERE userId = :userId AND nombre = :nombre AND activa = 1 AND idCategoria != :excludeId")
    suspend fun existeCategoriaConNombre(userId: String, nombre: String, excludeId: String = ""): Boolean

    /**
     * Obtiene nombres √∫nicos de categor√≠as para autocompletado
     */
    @Query("SELECT DISTINCT nombre FROM categorias WHERE userId = :userId AND activa = 1 ORDER BY nombre ASC")
    suspend fun getNombresCategoriasUnicas(userId: String): List<String>

    // ========== MANTENIMIENTO ==========

    /**
     * Elimina categor√≠as inactivas antiguas
     */
    @Query("DELETE FROM categorias WHERE userId = :userId AND activa = 0 AND lastModified < :limiteFecha")
    suspend fun limpiarCategoriasInactivasAntiguas(userId: String, limiteFecha: Long)

    /**
     * Resetea sincronizaci√≥n para forzar re-sync
     */
    @Query("UPDATE categorias SET sincronizadoFirebase = 0 WHERE userId = :userId")
    suspend fun resetearSincronizacion(userId: String)
}

// app/src/main/java/es/nuskysoftware/marketsales/data/local/dao/ConfiguracionDao.kt
package es.nuskysoftware.marketsales.data.local.dao

import androidx.room.*
import kotlinx.coroutines.flow.Flow
import es.nuskysoftware.marketsales.data.local.entity.ConfiguracionEntity

/**
 * ConfiguracionDao V10 - ACTUALIZADO PARA SISTEMA MONOUSUARIO
 *
 * CAMBIOS V10:
 * - Agregados m√©todos para usuarioLogueado
 * - Agregados m√©todos para sincronizaci√≥n (version, lastModified)
 * - Eliminados m√©todos obsoletos (usuarioPassword, usuarioEmail, usuarioId, versionApp)
 * - Mantenidos m√©todos legacy marcados como @Deprecated
 */
@Dao
interface ConfiguracionDao {

    // ========== M√âTODOS B√ÅSICOS (sin cambios) ==========
    @Query("SELECT EXISTS(SELECT 1 FROM configuracion WHERE id = 1)")
    suspend fun existeConfiguracion(): Boolean

    @Query("SELECT * FROM configuracion WHERE id = 1")
    suspend fun getConfiguracion(): ConfiguracionEntity?

    @Query("SELECT * FROM configuracion WHERE id = 1")
    suspend fun getConfiguracionSync(): ConfiguracionEntity?

    @Query("SELECT * FROM configuracion WHERE id = 1")
    fun getConfiguracionFlow(): Flow<ConfiguracionEntity?>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertarConfiguracion(configuracion: ConfiguracionEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOrUpdate(configuracion: ConfiguracionEntity)

    @Update
    suspend fun actualizarConfiguracion(configuracion: ConfiguracionEntity)

    @Query("DELETE FROM configuracion")
    suspend fun eliminarTodasLasConfiguraciones()

    // ========== CONFIGURACI√ìN GLOBAL V10 ==========

    /** Actualiza la moneda (com√∫n a todos los usuarios) */
    @Query("UPDATE configuracion SET moneda = :moneda, version = version + 1, lastModified = :timestamp, pendienteSync = 1 WHERE id = 1")
    suspend fun updateMoneda(moneda: String, timestamp: Long = System.currentTimeMillis())

    /** Actualiza el idioma (com√∫n a todos los usuarios) */
    @Query("UPDATE configuracion SET idioma = :idioma, version = version + 1, lastModified = :timestamp, pendienteSync = 1 WHERE id = 1")
    suspend fun updateIdioma(idioma: String, timestamp: Long = System.currentTimeMillis())

    /** Actualiza la fuente (com√∫n a todos los usuarios) */
    @Query("UPDATE configuracion SET fuente = :fuente, version = version + 1, lastModified = :timestamp, pendienteSync = 1 WHERE id = 1")
    suspend fun updateFuente(fuente: String, timestamp: Long = System.currentTimeMillis())

    /** Actualiza el tema oscuro (com√∫n a todos los usuarios) */
    @Query("UPDATE configuracion SET temaOscuro = :esTemaOscuro, version = version + 1, lastModified = :timestamp, pendienteSync = 1 WHERE id = 1")
    suspend fun updateTemaOscuro(esTemaOscuro: Boolean, timestamp: Long = System.currentTimeMillis())

    // ========== USUARIO LOGUEADO V10 ==========

    /** Establece el usuario actualmente logueado */
    @Query("UPDATE configuracion SET usuarioLogueado = :usuarioUid, version = version + 1, lastModified = :timestamp WHERE id = 1")
    suspend fun setUsuarioLogueado(usuarioUid: String, timestamp: Long = System.currentTimeMillis())

    /** Obtiene el UID del usuario actualmente logueado */
    @Query("SELECT usuarioLogueado FROM configuracion WHERE id = 1")
    suspend fun getUsuarioLogueado(): String?

    /** Flow que emite el usuario logueado */
    @Query("SELECT usuarioLogueado FROM configuracion WHERE id = 1")
    fun getUsuarioLogueadoFlow(): Flow<String?>

    /** Verifica si es usuario por defecto */
    @Query("SELECT usuarioLogueado = 'usuario_default' FROM configuracion WHERE id = 1")
    suspend fun isUsuarioDefault(): Boolean

    // ========== SINCRONIZACI√ìN V10 ==========

    /** Marca si hay pendiente de sincronizar en Firebase */
    @Query("UPDATE configuracion SET pendienteSync = :pendiente WHERE id = 1")
    suspend fun updatePendienteSync(pendiente: Boolean)

    /** Flujo que emite true/false seg√∫n si hay pendienteSync */
    @Query("SELECT pendienteSync FROM configuracion WHERE id = 1")
    fun getPendienteSyncFlow(): Flow<Boolean>

    /** Actualiza campos de sincronizaci√≥n despu√©s de sync exitoso */
    @Query("UPDATE configuracion SET version = :version, lastModified = :timestamp, pendienteSync = 0 WHERE id = 1")
    suspend fun markSyncSuccessful(version: Long, timestamp: Long = System.currentTimeMillis())

    /** Obtiene versi√≥n actual para resoluci√≥n de conflictos */
    @Query("SELECT version FROM configuracion WHERE id = 1")
    suspend fun getCurrentVersion(): Long?

    /** Obtiene timestamp de √∫ltima modificaci√≥n */
    @Query("SELECT lastModified FROM configuracion WHERE id = 1")
    suspend fun getLastModified(): Long?

    // ========== M√âTODOS LEGACY (mantener para compatibilidad) ==========

    /** Actualiza la fecha de √∫ltima sincronizaci√≥n */
    @Query("UPDATE configuracion SET fechaUltimaSync = :fecha WHERE id = 1")
    suspend fun updateFechaUltimaSync(fecha: String?)

    /** Actualiza el √∫ltimo dispositivo */
    @Query("UPDATE configuracion SET ultimoDispositivo = :dispositivo WHERE id = 1")
    suspend fun updateUltimoDispositivo(dispositivo: String?)

    /** Actualiza el n√∫mero de versi√≥n de la app */
    @Query("UPDATE configuracion SET numeroVersion = :version WHERE id = 1")
    suspend fun updateNumeroVersion(version: String)

    // ========== M√âTODOS OBSOLETOS V10 (mantener por compatibilidad) ==========

    @Deprecated("Campo eliminado en V10 - usar UserRepository para gestionar usuarios", ReplaceWith("UserRepository.updateUserPassword()"))
    @Query("SELECT 1") // Query dummy que no hace nada
    suspend fun updateUsuarioPassword(password: String?) { /* No-op */ }

    @Deprecated("Campo eliminado en V10 - usar UserRepository para gestionar usuarios", ReplaceWith("UserRepository.updateUserEmail()"))
    @Query("SELECT 1") // Query dummy que no hace nada
    suspend fun updateUsuarioEmail(email: String?) { /* No-op */ }

    @Deprecated("Campo eliminado en V10 - usar setUsuarioLogueado()", ReplaceWith("setUsuarioLogueado(usuarioId)"))
    @Query("SELECT 1") // Query dummy que no hace nada
    suspend fun updateUsuarioId(usuarioId: String?) { /* No-op */ }

    @Deprecated("Campo eliminado en V10 - usar UserRepository.updateUserPremium()", ReplaceWith("UserRepository.updateUserPremium()"))
    @Query("SELECT 1") // Query dummy que no hace nada
    suspend fun updateVersionApp(version: Int) { /* No-op */ }
}


// app/src/main/java/es/nuskysoftware/marketsales/data/local/dao/LineasVentaDao.kt
package es.nuskysoftware.marketsales.data.local.dao

import androidx.room.*
import es.nuskysoftware.marketsales.data.local.entity.LineaVentaEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface LineasVentaDao {

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsertAll(items: List<LineaVentaEntity>)

    @Query("DELETE FROM lineas_venta WHERE idUsuario = :userId")
    suspend fun borrarPorUsuario(userId: String)


    @Upsert
    suspend fun upsert(linea: LineaVentaEntity)

    @Query("SELECT EXISTS(SELECT 1 FROM lineas_venta WHERE idUsuario = :uid LIMIT 1)")
    suspend fun existeAlgunoDeUsuario(uid: String): Boolean

    @Query("SELECT * FROM lineas_venta WHERE idRecibo = :idRecibo ORDER BY numeroLinea")
    fun obtenerLineasPorRecibo(idRecibo: String): Flow<List<LineaVentaEntity>>

    @Query("SELECT * FROM lineas_venta WHERE idMercadillo = :idMercadillo ORDER BY numeroLinea")
    fun obtenerLineasPorMercadillo(idMercadillo: String): Flow<List<LineaVentaEntity>>

    // ‚ö†Ô∏è Con PK compuesta, una √∫nica 'idLinea' ya no identifica por s√≠ sola; mantenemos el m√©todo por compatibilidad,
    // pero para lecturas puntuales es mejor usar ambos campos.
    @Query("SELECT * FROM lineas_venta WHERE idMercadillo = :idMercadillo AND idLinea = :idLinea")
    suspend fun obtenerLineaPorId(idMercadillo: String, idLinea: String): LineaVentaEntity?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertarLinea(linea: LineaVentaEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertarLineas(lineas: List<LineaVentaEntity>)

    @Update
    suspend fun actualizarLinea(linea: LineaVentaEntity)

    @Delete
    suspend fun eliminarLinea(linea: LineaVentaEntity)

    @Query("DELETE FROM lineas_venta WHERE idRecibo = :idRecibo")
    suspend fun eliminarLineasPorRecibo(idRecibo: String)

    @Query("DELETE FROM lineas_venta WHERE idMercadillo = :idMercadillo")
    suspend fun eliminarLineasPorMercadillo(idMercadillo: String)

    // ‚úÖ √ötil si alguna vez quieres contar (opcional)
    @Query("SELECT COUNT(*) FROM lineas_venta WHERE idMercadillo = :idMercadillo")
    suspend fun contarLineasPorMercadillo(idMercadillo: String): Int

    // ‚úÖ Para reinicio por mercadillo: devuelve el mayor idLinea (lexicogr√°fico funciona con 0-padding)
    @Query("SELECT MAX(idLinea) FROM lineas_venta WHERE idMercadillo = :idMercadillo")
    suspend fun obtenerMaxIdLineaPorMercadillo(idMercadillo: String): String?
}

// app/src/main/java/es/nuskysoftware/marketsales/data/local/dao/MercadilloDao.kt
package es.nuskysoftware.marketsales.data.local.dao

import androidx.room.*
import es.nuskysoftware.marketsales.data.local.entity.MercadilloEntity
import kotlinx.coroutines.flow.Flow

/**
 * MercadilloDao V11 - Market Sales
 *
 * DIFERENCIAS CON CAJA MERCADILLOS:
 * - Todas las consultas filtradas por userId
 * - Arquitectura h√≠brida con sincronizadoFirebase
 * - Compatibilidad con sistema "Reloj Suizo"
 * - M√©todos espec√≠ficos para gesti√≥n de estados y saldos
 */
@Dao
interface MercadilloDao {


    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsertAll(items: List<MercadilloEntity>)

    @Query("DELETE FROM mercadillos WHERE userId = :userId")
    suspend fun borrarPorUsuario(userId: String)


    // ========== OPERACIONES B√ÅSICAS ==========

    @Upsert
    suspend fun upsert(mercadillo: MercadilloEntity)

    @Query("SELECT EXISTS(SELECT 1 FROM mercadillos WHERE userId = :uid LIMIT 1)")
    suspend fun existeAlgunoDeUsuario(uid: String): Boolean

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertMercadillo(mercadillo: MercadilloEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOrUpdate(mercadillo: MercadilloEntity)

    @Update
    suspend fun updateMercadillo(mercadillo: MercadilloEntity)

    @Delete
    suspend fun deleteMercadillo(mercadillo: MercadilloEntity)

    // ========== CONSULTAS FILTRADAS POR USUARIO ==========

    // Agregar en MercadilloDao.kt:

    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND fecha = :fecha AND activo = 1")
    suspend fun getMercadillosByUserAndFecha(userId: String, fecha: String): List<MercadilloEntity>

    /**
     * Obtiene todos los mercadillos del usuario actual ordenados por fecha DESC
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND activo = 1 ORDER BY fecha DESC, horaInicio DESC")
    fun getMercadillosByUser(userId: String): Flow<List<MercadilloEntity>>

    /**
     * Obtiene mercadillos de un mes espec√≠fico para el calendario
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND fecha LIKE :mesPattern AND activo = 1 ORDER BY fecha ASC")
    fun getMercadillosByUserAndMes(userId: String, mesPattern: String): Flow<List<MercadilloEntity>>

    /**
     * Obtiene un mercadillo espec√≠fico por ID
     */
    @Query("SELECT * FROM mercadillos WHERE idMercadillo = :id")
    suspend fun getMercadilloById(id: String): MercadilloEntity?

    /**
     * Elimina mercadillo por ID
     */
    @Query("DELETE FROM mercadillos WHERE idMercadillo = :id")
    suspend fun deleteMercadilloById(id: String)

    // ========== CONSULTAS POR ESTADO ==========

    /**
     * Obtiene mercadillos por estado espec√≠fico
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND estado = :estado AND activo = 1 ORDER BY fecha ASC")
    fun getMercadillosByUserAndEstado(userId: String, estado: Int): Flow<List<MercadilloEntity>>

    /**
     * Obtiene mercadillos programados parcialmente (sin saldo inicial)
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND saldoInicial IS NULL AND activo = 1 ORDER BY fecha ASC")
    fun getMercadillosProgramadosParciales(userId: String): Flow<List<MercadilloEntity>>

    /**
     * Obtiene mercadillos pendientes de arqueo
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND pendienteArqueo = 1 AND activo = 1 ORDER BY fecha ASC")
    fun getMercadillosPendientesArqueo(userId: String): Flow<List<MercadilloEntity>>

    /**
     * Obtiene mercadillos pendientes de asignar saldo
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND pendienteAsignarSaldo = 1 AND activo = 1 ORDER BY fecha ASC")
    fun getMercadillosPendientesAsignarSaldo(userId: String): Flow<List<MercadilloEntity>>

    // ========== CONSULTAS PARA L√ìGICA DE NEGOCIO ==========

    /**
     * Obtiene el pr√≥ximo mercadillo programado
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND fecha >= :fechaActual AND activo = 1 ORDER BY fecha ASC, horaInicio ASC LIMIT 1")
    suspend fun getProximoMercadillo(userId: String, fechaActual: String): MercadilloEntity?

    /**
     * Obtiene mercadillos de una fecha espec√≠fica
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND fecha = :fecha AND activo = 1 ORDER BY horaInicio ASC")
    suspend fun getMercadillosByFecha(userId: String, fecha: String): List<MercadilloEntity>

    /**
     * Obtiene el √∫ltimo mercadillo con saldo final para asignaci√≥n autom√°tica
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND saldoFinal IS NOT NULL AND pendienteAsignarSaldo = 1 AND activo = 1 ORDER BY fecha DESC, horaFin DESC LIMIT 1")
    suspend fun getUltimoMercadilloConSaldoFinal(userId: String): MercadilloEntity?

    /**
     * Verifica si existe un mercadillo en la misma fecha y hora
     */
    @Query("SELECT COUNT(*) > 0 FROM mercadillos WHERE userId = :userId AND fecha = :fecha AND horaInicio = :horaInicio AND activo = 1 AND idMercadillo != :excludeId")
    suspend fun existeMercadilloEnFechaHora(userId: String, fecha: String, horaInicio: String, excludeId: String = ""): Boolean

    // ========== SINCRONIZACI√ìN H√çBRIDA ==========

    /**
     * Obtiene mercadillos no sincronizados de un usuario espec√≠fico
     */
    @Query("SELECT * FROM mercadillos WHERE userId = :userId AND sincronizadoFirebase = 0")
    suspend fun getMercadillosNoSincronizadosByUser(userId: String): List<MercadilloEntity>

    /**
     * Marca mercadillo como sincronizado
     */
    @Query("UPDATE mercadillos SET sincronizadoFirebase = 1, lastModified = :timestamp WHERE idMercadillo = :id")
    suspend fun marcarComoSincronizado(id: String, timestamp: Long = System.currentTimeMillis())

    /**
     * Marca mercadillo como no sincronizado (para cambios locales)
     */
    @Query("UPDATE mercadillos SET sincronizadoFirebase = 0 WHERE idMercadillo = :id")
    suspend fun marcarComoNoSincronizado(id: String)

    /**
     * Obtiene la versi√≥n actual de un mercadillo
     */
    @Query("SELECT version FROM mercadillos WHERE idMercadillo = :id")
    suspend fun getMercadilloVersion(id: String): Long?

    // ========== ACTUALIZACI√ìN DE ESTADOS Y SALDOS ==========

    /**
     * Asigna saldo inicial a un mercadillo
     */
    @Query("UPDATE mercadillos SET saldoInicial = :saldoInicial, estado = 2, version = version + 1, lastModified = :timestamp, sincronizadoFirebase = 0 WHERE idMercadillo = :id")
    suspend fun asignarSaldoInicial(id: String, saldoInicial: Double, timestamp: Long = System.currentTimeMillis())

    /**
     * Actualiza estado del mercadillo
     */
    @Query("UPDATE mercadillos SET estado = :nuevoEstado, version = version + 1, lastModified = :timestamp, sincronizadoFirebase = 0 WHERE idMercadillo = :id")
    suspend fun actualizarEstado(id: String, nuevoEstado: Int, timestamp: Long = System.currentTimeMillis())

    /**
     * Realiza arqueo de caja
     */
    @Query("UPDATE mercadillos SET arqueoCaja = :arqueoCaja, saldoFinal = :saldoFinal, pendienteArqueo = 0, pendienteAsignarSaldo = 1, estado = 5, version = version + 1, lastModified = :timestamp, sincronizadoFirebase = 0 WHERE idMercadillo = :id")
    suspend fun realizarArqueoCaja(id: String, arqueoCaja: Double, saldoFinal: Double, timestamp: Long = System.currentTimeMillis())

    /**
     * Marca saldo como asignado (mercadillo cerrado completo)
     */
    @Query("UPDATE mercadillos SET pendienteAsignarSaldo = 0, estado = 6, version = version + 1, lastModified = :timestamp, sincronizadoFirebase = 0 WHERE idMercadillo = :id")
    suspend fun marcarSaldoAsignado(id: String, timestamp: Long = System.currentTimeMillis())

    /**
     * Actualiza totales de ventas y gastos (calculados desde otras tablas)
     */
    @Query("UPDATE mercadillos SET totalVentas = :totalVentas, totalGastos = :totalGastos, arqueoMercadillo = :arqueoMercadillo, version = version + 1, lastModified = :timestamp, sincronizadoFirebase = 0 WHERE idMercadillo = :id")
    suspend fun actualizarTotales(id: String, totalVentas: Double, totalGastos: Double, arqueoMercadillo: Double, timestamp: Long = System.currentTimeMillis())

    /**
     * Cancela un mercadillo
     */
    @Query("UPDATE mercadillos SET estado = 7, activo = 0, version = version + 1, lastModified = :timestamp, sincronizadoFirebase = 0 WHERE idMercadillo = :id")
    suspend fun cancelarMercadillo(id: String, timestamp: Long = System.currentTimeMillis())

    // ========== UTILIDADES ==========

    /**
     * Cuenta el total de mercadillos de un usuario
     */
    @Query("SELECT COUNT(*) FROM mercadillos WHERE userId = :userId AND activo = 1")
    suspend fun getMercadilloCountByUser(userId: String): Int

    /**
     * Obtiene estad√≠sticas b√°sicas de mercadillos por estado
     */
    @Query("SELECT estado, COUNT(*) as cantidad FROM mercadillos WHERE userId = :userId AND activo = 1 GROUP BY estado")
    suspend fun getEstadisticasPorEstado(userId: String): List<EstadisticaEstado>

    // ========== MANTENIMIENTO ==========

    /**
     * Elimina mercadillos cancelados antiguos
     */
    @Query("DELETE FROM mercadillos WHERE userId = :userId AND estado = 7 AND lastModified < :limiteFecha")
    suspend fun limpiarMercadillosCanceladosAntiguos(userId: String, limiteFecha: Long)

    /**
     * Resetea sincronizaci√≥n para forzar re-sync
     */
    @Query("UPDATE mercadillos SET sincronizadoFirebase = 0 WHERE userId = :userId")
    suspend fun resetearSincronizacion(userId: String)

    // AGREGAR ESTA FUNCI√ìN AL MercadilloDao.kt

    /**
     * Obtiene todos los mercadillos desde una fecha espec√≠fica en adelante
     * Ordenados por fecha ASC y luego por hora de inicio ASC
     */
    @Query("""
    SELECT * FROM mercadillos 
    WHERE userId = :userId 
    AND fecha >= :fechaActual 
    AND activo = 1 
    ORDER BY fecha ASC, horaInicio ASC
""")
    suspend fun getMercadillosDesdeHoy(userId: String, fechaActual: String): List<MercadilloEntity>

}




/**
 * Data class para estad√≠sticas por estado
 */
data class EstadisticaEstado(
    val estado: Int,
    val cantidad: Int
)


// app/src/main/java/es/nuskysoftware/marketsales/data/local/dao/RecibosDao.kt
package es.nuskysoftware.marketsales.data.local.dao

import androidx.room.*
import es.nuskysoftware.marketsales.data.local.entity.ReciboEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface RecibosDao {

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun upsertAll(items: List<ReciboEntity>)

    @Query("DELETE FROM recibos WHERE idUsuario = :userId")
    suspend fun borrarPorUsuario(userId: String)

    @Upsert
    suspend fun upsert(recibo: ReciboEntity)

    @Query("SELECT EXISTS(SELECT 1 FROM recibos WHERE idUsuario = :uid LIMIT 1)")
    suspend fun existeAlgunoDeUsuario(uid: String): Boolean

    @Query("SELECT * FROM recibos WHERE idMercadillo = :idMercadillo ORDER BY fechaHora DESC")
    fun obtenerRecibosPorMercadillo(idMercadillo: String): Flow<List<ReciboEntity>>

    @Query("SELECT * FROM recibos WHERE idRecibo = :idRecibo")
    suspend fun obtenerReciboPorId(idRecibo: String): ReciboEntity?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertarRecibo(recibo: ReciboEntity)

    @Update
    suspend fun actualizarRecibo(recibo: ReciboEntity)

    @Delete
    suspend fun eliminarRecibo(recibo: ReciboEntity)

    @Query("DELETE FROM recibos WHERE idMercadillo = :idMercadillo")
    suspend fun eliminarRecibosPorMercadillo(idMercadillo: String)
}

// app/src/main/java/es/nuskysoftware/marketsales/data/local/dao/UserDao.kt
package es.nuskysoftware.marketsales.data.local.dao

import androidx.room.*
import kotlinx.coroutines.flow.Flow
import es.nuskysoftware.marketsales.data.local.entity.UserEntity

/**
 * ‚úÖ UserDao COMPLETO con todos los m√©todos que necesita UserRepository
 */
@Dao
interface UserDao {

    // ========== M√âTODOS B√ÅSICOS ==========
    // ¬øExiste el usuario en Room?
    @Query("SELECT EXISTS(SELECT 1 FROM usuarios WHERE uid = :uid LIMIT 1)")
    suspend fun existeUsuario(uid: String): Boolean

    // ¬øEs Premium el usuario? (null si no existe)
    @Query("SELECT esPremium FROM usuarios WHERE uid = :uid")
    suspend fun isPremium(uid: String): Boolean?

    @Query("SELECT * FROM usuarios WHERE uid = :uid")
    suspend fun getUserById(uid: String): UserEntity?

    @Query("SELECT * FROM usuarios WHERE uid = :uid")
    suspend fun getUserByIdSync(uid: String): UserEntity?

    @Query("SELECT * FROM usuarios WHERE uid = :uid")
    fun getUserByIdFlow(uid: String): Flow<UserEntity?>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertUser(user: UserEntity)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOrUpdate(user: UserEntity)

    @Update
    suspend fun updateUser(user: UserEntity)

    @Delete
    suspend fun deleteUser(user: UserEntity)

    // ========== M√âTODOS FALTANTES PARA UserRepository ==========

    /**
     * Obtener usuario actual (dummy - UserRepository lo maneja)
     */
    @Query("SELECT * FROM usuarios WHERE uid != 'dummy'")
    fun getCurrentUserFlow(): Flow<UserEntity?>

    /**
     * Obtener usuarios pendientes de sincronizaci√≥n
     */
    @Query("SELECT * FROM usuarios WHERE sincronizadoFirebase = 0")
    suspend fun getUsersPendingSync(): List<UserEntity>

    /**
     * Actualizar estado Premium del usuario
     */
    @Query("UPDATE usuarios SET esPremium = :esPremium WHERE uid = :uid")
    suspend fun updateUserPremium(uid: String, esPremium: Boolean)

    /**
     * Actualizar email del usuario
     */
    @Query("UPDATE usuarios SET email = :email WHERE uid = :uid")
    suspend fun updateUserEmail(uid: String, email: String)

    /**
     * Actualizar nombre del usuario
     */
    @Query("UPDATE usuarios SET displayName = :displayName WHERE uid = :uid")
    suspend fun updateUserDisplayName(uid: String, displayName: String)

    /**
     * Actualizar foto del usuario
     */
    @Query("UPDATE usuarios SET photoUrl = :photoUrl WHERE uid = :uid")
    suspend fun updateUserPhotoUrl(uid: String, photoUrl: String)

    /**
     * Obtener todos los usuarios Premium
     */
    @Query("SELECT * FROM usuarios WHERE esPremium = 1 AND activo = 1")
    suspend fun getAllPremiumUsers(): List<UserEntity>

    /**
     * Obtener todos los usuarios Free
     */
    @Query("SELECT * FROM usuarios WHERE esPremium = 0 AND activo = 1")
    suspend fun getAllFreeUsers(): List<UserEntity>

    /**
     * Marcar usuario como sincronizado exitosamente
     */
    @Query("UPDATE usuarios SET sincronizadoFirebase = 1, version = :newVersion WHERE uid = :uid")
    suspend fun markUserSyncSuccessful(uid: String, newVersion: Long)

    /**
     * Actualizar fecha de √∫ltima sincronizaci√≥n
     */
    @Query("UPDATE usuarios SET fechaUltimaSync = :fecha WHERE uid = :uid")
    suspend fun updateFechaUltimaSync(uid: String, fecha: String)

    /**
     * Obtener versi√≥n de usuario
     */
    @Query("SELECT version FROM usuarios WHERE uid = :uid")
    suspend fun getUserVersion(uid: String): Long?

    // ========== M√âTODOS EXISTENTES ==========
    @Query("SELECT * FROM usuarios WHERE email = :email")
    suspend fun getUserByEmail(email: String): UserEntity?

    @Query("SELECT * FROM usuarios WHERE activo = 1")
    suspend fun getAllActiveUsers(): List<UserEntity>

    // En UserDao.kt - Alternativa m√°s robusta:

    @Query("UPDATE usuarios SET displayName = :displayName, email = :email WHERE uid = :userId")
    suspend fun updateUserProfile(userId: String, displayName: String, email: String): Int

    // M√©todo adicional para verificar si se actualiz√≥ correctamente
    @Query("SELECT COUNT(*) FROM usuarios WHERE uid = :userId")
    suspend fun userExists(userId: String): Int

    @Query("UPDATE usuarios SET sincronizadoFirebase = 0 WHERE uid = :uid")
    suspend fun markUserNotSynced(uid: String)
}


// app/src/main/java/es/nuskysoftware/marketsales/data/local/database/AppDatabase.kt
package es.nuskysoftware.marketsales.data.local.database

import android.content.Context
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase
import com.google.firebase.BuildConfig

import es.nuskysoftware.marketsales.data.local.dao.ArticuloDao
import es.nuskysoftware.marketsales.data.local.dao.CategoriaDao
import es.nuskysoftware.marketsales.data.local.dao.ConfiguracionDao
import es.nuskysoftware.marketsales.data.local.dao.LineasVentaDao
import es.nuskysoftware.marketsales.data.local.dao.MercadilloDao
import es.nuskysoftware.marketsales.data.local.dao.RecibosDao
import es.nuskysoftware.marketsales.data.local.dao.UserDao
import es.nuskysoftware.marketsales.data.local.entity.ArticuloEntity
import es.nuskysoftware.marketsales.data.local.entity.CategoriaEntity
import es.nuskysoftware.marketsales.data.local.entity.ConfiguracionEntity
import es.nuskysoftware.marketsales.data.local.entity.LineaVentaEntity
import es.nuskysoftware.marketsales.data.local.entity.MercadilloEntity
import es.nuskysoftware.marketsales.data.local.entity.ReciboEntity
import es.nuskysoftware.marketsales.data.local.entity.UserEntity

@Database(
    entities = [
        ConfiguracionEntity::class,
        MercadilloEntity::class,
        UserEntity::class,
        CategoriaEntity::class,
        ArticuloEntity::class,
        ReciboEntity::class,
        LineaVentaEntity::class
    ],
    version = 8, // ‚¨ÜÔ∏è nunca bajar versi√≥n; antes estaba en 7 y la BD del dispositivo en 8
    exportSchema = false
)
abstract class AppDatabase : RoomDatabase() {

    abstract fun configuracionDao(): ConfiguracionDao
    abstract fun mercadilloDao(): MercadilloDao
    abstract fun userDao(): UserDao
    abstract fun categoriaDao(): CategoriaDao
    abstract fun articuloDao(): ArticuloDao
    abstract fun recibosDao(): RecibosDao
    abstract fun lineasVentaDao(): LineasVentaDao

    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null

        // ‚ûï Migraci√≥n NO-OP de 7 ‚Üí 8 (ajusta aqu√≠ si realmente cambiaste esquema)
        private val MIGRATION_7_8 = object : Migration(7, 8) {
            override fun migrate(db: SupportSQLiteDatabase) {
                // No-op: si entre 7 y 8 no hubo cambios de esquema efectivos.
                // Si a√±adiste columnas/tablas de verdad, pon aqu√≠ tus ALTER TABLE ‚Ä¶ ADD COLUMN ‚Ä¶ DEFAULT ‚Ä¶
                // Ejemplo (com√©ntalo/aj√∫stalo si aplica):
                // db.execSQL("ALTER TABLE configuracion ADD COLUMN usuarioLogueado TEXT NOT NULL DEFAULT 'usuario_default'")
            }
        }

        fun getDatabase(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {

                val builder = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "marketsales_database_v10"
                )
                    // ‚úÖ Registra tus migraciones conocidas
                    .addMigrations(
                        Migrations.M6_TO_M7, // la que ya usabas
                        MIGRATION_7_8        // nueva para evitar el crash 8‚Üí7
                    )

                // üîß Solo en DEBUG: si por error instalas un APK m√°s viejo (downgrade), evita el crash
                if (BuildConfig.DEBUG) {
                    builder.fallbackToDestructiveMigrationOnDowngrade()
                }

                val instance = builder.build()
                INSTANCE = instance
                instance
            }
        }

        fun clearInstance() {
            INSTANCE = null
        }
    }
}


// app/src/main/java/es/nuskysoftware/marketsales/data/local/database/Migrations.kt
package es.nuskysoftware.marketsales.data.local.database

import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase

object Migrations {

    // Migraci√≥n de esquema: versi√≥n 6 -> 7
    // Crea las tablas 'recibos' y 'lineas_venta' sin tocar lo existente.
    val M6_TO_M7 = object : Migration(6, 7) {
        override fun migrate(db: SupportSQLiteDatabase) {

            // === Tabla RECIBOS (seg√∫n ReciboEntity) ===
            db.execSQL(
                """
                CREATE TABLE IF NOT EXISTS recibos (
                    idRecibo TEXT NOT NULL PRIMARY KEY,
                    idMercadillo TEXT NOT NULL,
                    idUsuario TEXT NOT NULL,
                    fechaHora INTEGER NOT NULL,
                    metodoPago TEXT NOT NULL,
                    totalTicket REAL NOT NULL,
                    estado TEXT NOT NULL DEFAULT 'COMPLETADO'
                )
                """.trimIndent()
            )

            // Opcionalmente √≠ndices √∫tiles:
            db.execSQL("CREATE INDEX IF NOT EXISTS idx_recibos_mercadillo ON recibos(idMercadillo)")
            db.execSQL("CREATE INDEX IF NOT EXISTS idx_recibos_usuario ON recibos(idUsuario)")

            // === Tabla LINEAS_VENTA (seg√∫n LineaVentaEntity) ===
            db.execSQL(
                """
                CREATE TABLE IF NOT EXISTS lineas_venta (
                    idLinea TEXT NOT NULL PRIMARY KEY,
                    idRecibo TEXT NOT NULL,
                    idMercadillo TEXT NOT NULL,
                    idUsuario TEXT NOT NULL,
                    numeroLinea INTEGER NOT NULL,
                    tipoLinea TEXT NOT NULL,
                    descripcion TEXT NOT NULL,
                    idProducto TEXT,
                    cantidad INTEGER NOT NULL,
                    precioUnitario REAL NOT NULL,
                    subtotal REAL NOT NULL,
                    idLineaOriginalAbonada TEXT
                )
                """.trimIndent()
            )

            // √çndices recomendados:
            db.execSQL("CREATE INDEX IF NOT EXISTS idx_lineas_recibo ON lineas_venta(idRecibo)")
            db.execSQL("CREATE INDEX IF NOT EXISTS idx_lineas_mercadillo ON lineas_venta(idMercadillo)")
            db.execSQL("CREATE INDEX IF NOT EXISTS idx_lineas_usuario ON lineas_venta(idUsuario)")
        }
    }
}


// app/src/main/java/es/nuskysoftware/marketsales/data/local/entity/ArticuloEntity.kt
package es.nuskysoftware.marketsales.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.UUID

/**
 * ArticuloEntity V11 - Market Sales
 *
 * CAMBIOS RESPECTO A CAJA MERCADILLOS:
 * - Agregado campo userId para vincular con usuario
 * - Compatible con arquitectura h√≠brida "Reloj Suizo"
 * - Sincronizaci√≥n con Firebase + Room offline-first
 * - Campos de control Premium (coste, stock)
 */
@Entity(tableName = "articulos")
data class ArticuloEntity(
    @PrimaryKey
    val idArticulo: String = UUID.randomUUID().toString(),

    // ‚úÖ NUEVO: Campo para vincular con usuario
    val userId: String = "",

    // Campos principales
    val nombre: String = "",
    val idCategoria: String = "",
    val precioVenta: Double = 0.0,

    // Campos Premium
    val precioCoste: Double? = null,
    val stock: Int? = null,
    val controlarStock: Boolean = false,
    val controlarCoste: Boolean = false,

    // Campos adicionales
    val favorito: Boolean = false,
    val fotoUri: String? = null,
    val activo: Boolean = true,

    // Campos de sincronizaci√≥n h√≠brida
    val version: Long = 1,
    val lastModified: Long = System.currentTimeMillis(),
    val sincronizadoFirebase: Boolean = false
) {
    // Constructor vac√≠o para Firestore
    constructor() : this(
        idArticulo = "",
        userId = "",
        nombre = "",
        idCategoria = "",
        precioVenta = 0.0,
        precioCoste = null,
        stock = null,
        controlarStock = false,
        controlarCoste = false,
        favorito = false,
        fotoUri = null,
        activo = true,
        version = 1,
        lastModified = System.currentTimeMillis(),
        sincronizadoFirebase = false
    )
}

// app/src/main/java/es/nuskysoftware/marketsales/data/local/entity/CategoriaEntity.kt
package es.nuskysoftware.marketsales.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.UUID

/**
 * CategoriaEntity V11 - Market Sales
 *
 * CAMBIOS RESPECTO A CAJA MERCADILLOS:
 * - Agregado campo userId para vincular con tabla usuarios
 * - Compatible con arquitectura h√≠brida "Reloj Suizo"
 * - Sincronizaci√≥n con Firebase + Room offline-first
 */
@Entity(tableName = "categorias")
data class CategoriaEntity(
    @PrimaryKey
    val idCategoria: String = UUID.randomUUID().toString(),

    // ‚úÖ NUEVO: Campo para vincular con usuario
    val userId: String = "",

    val nombre: String = "",
    val colorHex: String = "#FFFFFF",
    val orden: Int = 0,
    val activa: Boolean = true,

    // Campos de sincronizaci√≥n h√≠brida
    val version: Long = 1,
    val lastModified: Long = System.currentTimeMillis(),
    val sincronizadoFirebase: Boolean = false
) {
    // Constructor vac√≠o para Firestore
    constructor() : this(
        idCategoria = "",
        userId = "",
        nombre = "",
        colorHex = "#FFFFFF",
        orden = 0,
        activa = true,
        version = 1,
        lastModified = System.currentTimeMillis(),
        sincronizadoFirebase = false
    )
}

// app/src/main/java/es/nuskysoftware/marketsales/data/local/entity/ConfiguracionEntity.kt
package es.nuskysoftware.marketsales.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey

/**
 * ConfiguracionEntity V10 - SIMPLIFICADO MONOUSUARIO
 *
 * CAMBIOS V10:
 * - Configuraci√≥n GLOBAL (moneda, idioma, fuente, tema) com√∫n a todos los usuarios
 * - usuarioLogueado: UID del usuario actual o "usuario_default"
 * - Eliminado: versionApp, empresaId, tipoUsuario, etc. (l√≥gica multiusuario)
 * - Agregado: Campos de sincronizaci√≥n (version, lastModified, pendienteSync)
 */
@Entity(tableName = "configuracion")
data class ConfiguracionEntity(
    @PrimaryKey val id: Int = 1,

    // ========== CONFIGURACI√ìN GLOBAL (com√∫n a todos los usuarios) ==========
    val moneda: String = "‚Ç¨ Euro",           // Com√∫n a todos
    val idioma: String = "es",               // Com√∫n a todos
    val fuente: String = "Montserrat",       // Com√∫n a todos
    val temaOscuro: Boolean = false,         // Com√∫n a todos

    // ========== USUARIO ACTUAL ==========
    val usuarioLogueado: String = "usuario_default",  // UID actual o "usuario_default"

    // ========== CAMPOS LEGACY (mantener para compatibilidad) ==========
    val numeroVersion: String = "V10.0",
    val ultimoDispositivo: String? = android.os.Build.MODEL,
    val fechaUltimaSync: String? = null,

    // ========== SINCRONIZACI√ìN V10 ==========
    val version: Long = 1,
    val lastModified: Long = System.currentTimeMillis(),
    val pendienteSync: Boolean = false,
    val sincronizadoFirebase: Boolean = false
)

// ========== EXTENSION PROPERTIES (compatibilidad con c√≥digo existente) ==========

/**
 * Determina si el usuario actual es Premium
 * NOTA: Ahora se debe consultar desde la tabla usuarios
 */
@Deprecated("Usar UserRepository.getCurrentUser().esPremium", ReplaceWith("userRepository.getCurrentUser()?.esPremium ?: false"))
val ConfiguracionEntity.isPremium: Boolean
    get() = false // Siempre false, se consulta desde usuarios

/**
 * Alias para compatibilidad
 */
val ConfiguracionEntity.modoOscuro: Boolean
    get() = this.temaOscuro

/**
 * Indica si es usuario por defecto
 */
val ConfiguracionEntity.isUsuarioDefault: Boolean
    get() = this.usuarioLogueado == "usuario_default"


// app/src/main/java/es/nuskysoftware/marketsales/data/local/entity/LineaVentaEntity.kt
package es.nuskysoftware.marketsales.data.local.entity

import androidx.room.Entity

@Entity(
    tableName = "lineas_venta",
    primaryKeys = ["idMercadillo", "idLinea"] // PK compuesta
)
data class LineaVentaEntity(
    val idLinea: String,            // "0001", "0002"... reinicio por mercadillo
    val idRecibo: String,
    val idMercadillo: String,
    val idUsuario: String,
    val numeroLinea: Int,
    val tipoLinea: String,
    val descripcion: String,
    val idProducto: String? = null,
    val cantidad: Int,
    val precioUnitario: Double,
    val subtotal: Double,
    val idLineaOriginalAbonada: String? = null
)


// app/src/main/java/es/nuskysoftware/marketsales/data/local/entity/MercadilloEntity.kt
package es.nuskysoftware.marketsales.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.UUID

/**
 * MercadilloEntity V11 - Market Sales
 *
 * ARQUITECTURA H√çBRIDA "RELOJ SUIZO":
 * - Compatible con sincronizaci√≥n Firebase + Room offline-first
 * - Campo userId para vincular con usuario
 * - Estados autom√°ticos seg√∫n l√≥gica de negocio
 * - Gesti√≥n completa de saldos y arqueos
 * - Campos calculados almacenados en BD
 */
@Entity(tableName = "mercadillos")
data class MercadilloEntity(
    @PrimaryKey
    val idMercadillo: String = UUID.randomUUID().toString(),

    // ‚úÖ Campo para vincular con usuario
    val userId: String = "",

    // ========== DATOS B√ÅSICOS (M√çNIMOS REQUERIDOS) ==========
    val fecha: String = "", // Formato "dd-MM-yyyy"
    val lugar: String = "",
    val organizador: String = "",

    // ========== CONFIGURACI√ìN DEL MERCADILLO ==========
    val esGratis: Boolean = true,
    val importeSuscripcion: Double = 0.0, // Solo si esGratis = false
    val requiereMesa: Boolean = true,
    val requiereCarpa: Boolean = true,
    val hayPuntoLuz: Boolean = false,
    val horaInicio: String = "09:00", // Formato "HH:mm"
    val horaFin: String = "14:00", // Formato "HH:mm"

    // ========== ESTADOS Y CONTROL ==========
    val estado: Int = 1, // Seg√∫n EstadosMercadillo.Estado.codigo (autom√°tico)
    val pendienteArqueo: Boolean = false,
    val pendienteAsignarSaldo: Boolean = false,

    // ========== GESTI√ìN FINANCIERA ==========
    // null en saldoInicial = PROGRAMADO_PARCIAL, asignado = PROGRAMADO_TOTAL
    val saldoInicial: Double? = null,
    val saldoFinal: Double? = null,

    // Campos calculados pero almacenados:
    val arqueoCaja: Double? = null, // saldoInicial + ventasEfectivo - gastosEfectivo
    val totalVentas: Double = 0.0, // Ventas en cualquier forma de pago (calculado desde tabla ventas)
    val totalGastos: Double = 0.0, // Gastos en cualquier forma de pago (calculado desde tabla gastos)
    val arqueoMercadillo: Double? = null, // saldoInicial + totalVentas - totalGastos - importeSuscripcion

    // ========== CAMPOS DE CONTROL ==========
    val activo: Boolean = true,

    // ========== CAMPOS SINCRONIZACI√ìN H√çBRIDA ==========
    val version: Long = 1,
    val lastModified: Long = System.currentTimeMillis(),
    val sincronizadoFirebase: Boolean = false
) {
    // Constructor vac√≠o para Firestore
    constructor() : this(
        idMercadillo = "",
        userId = "",
        fecha = "",
        lugar = "",
        organizador = "",
        esGratis = true,
        importeSuscripcion = 0.0,
        requiereMesa = true,
        requiereCarpa = true,
        hayPuntoLuz = false,
        horaInicio = "09:00",
        horaFin = "14:00",
        estado = 1,
        pendienteArqueo = false,
        pendienteAsignarSaldo = false,
        saldoInicial = null,
        saldoFinal = null,
        arqueoCaja = null,
        totalVentas = 0.0,
        totalGastos = 0.0,
        arqueoMercadillo = null,
        activo = true,
        version = 1,
        lastModified = System.currentTimeMillis(),
        sincronizadoFirebase = false
    )
}


// app/src/main/java/es/nuskysoftware/marketsales/data/local/entity/ReciboEntity.kt
package es.nuskysoftware.marketsales.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "recibos")
data class ReciboEntity(
    @PrimaryKey val idRecibo: String,
    val idMercadillo: String,
    val idUsuario: String,
    val fechaHora: Long,
    val metodoPago: String,
    val totalTicket: Double,
    val estado: String = "COMPLETADO"
)

// app/src/main/java/es/nuskysoftware/marketsales/data/local/entity/UserEntity.kt
package es.nuskysoftware.marketsales.data.local.entity

import androidx.room.Entity
import androidx.room.PrimaryKey

/**
 * ‚úÖ COMPLETO V10 - UserEntity con todos los campos necesarios
 */
@Entity(tableName = "usuarios")
data class UserEntity(
    @PrimaryKey val uid: String,
    val email: String = "",
    val displayName: String = "",
    val photoUrl: String = "",
    val esPremium: Boolean = false,        // Premium/Free

    // ‚úÖ CAMPOS FALTANTES AGREGADOS
    val version: Long = 1,                 // Para versionado
    val lastModified: Long = System.currentTimeMillis(), // Para sincronizaci√≥n

    val fechaCreacion: Long = System.currentTimeMillis(),
    val fechaUltimaSync: String? = null,
    val sincronizadoFirebase: Boolean = false,
    val activo: Boolean = true
)

// app/src/main/java/es/nuskysoftware/marketsales/data/repository/ArticuloRepository.kt
package es.nuskysoftware.marketsales.data.repository

import android.content.Context
import android.util.Log
import com.google.firebase.firestore.FirebaseFirestore
import es.nuskysoftware.marketsales.data.local.dao.ArticuloDao
import es.nuskysoftware.marketsales.data.local.database.AppDatabase
import es.nuskysoftware.marketsales.data.local.entity.ArticuloEntity
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.ConnectivityObserver
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.tasks.await

/**
 * ArticuloRepository V11 - Market Sales
 *
 * ARQUITECTURA H√çBRIDA "RELOJ SUIZO":
 * - Local First: Toda operaci√≥n se ejecuta primero en Room
 * - Sync When Possible: Sincronizaci√≥n autom√°tica cuando hay conexi√≥n
 * - Never Block UI: La interfaz nunca espera operaciones de red
 * - Graceful Degradation: Funcionamiento completo offline
 * - Filtrado por usuario: Cada usuario solo ve sus datos
 */
class ArticuloRepository(
    context: Context
) {
    private val articuloDao: ArticuloDao = AppDatabase.getDatabase(context).articuloDao()
    private val firestore = FirebaseFirestore.getInstance()
    private val connectivityObserver = ConnectivityObserver(context)
    private val repositoryScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

    companion object {
        private const val TAG = "ArticuloRepository"
    }

    init {
        // Sincronizaci√≥n autom√°tica cuando volvemos online
        repositoryScope.launch {
            connectivityObserver.isConnected.collect { online ->
                if (online) {
                    val userId = ConfigurationManager.getCurrentUserId()
                    if (userId != null) {
                        sincronizarArticulosNoSincronizados(userId)
                    }
                }
            }
        }
    }

    // ========== OPERACIONES PRINCIPALES ==========

    /**
     * Obtiene todos los art√≠culos del usuario actual
     */
    fun getArticulosUsuarioActual(): Flow<List<ArticuloEntity>> {
        val userId = ConfigurationManager.getCurrentUserId()
        return if (userId != null) {
            articuloDao.getArticulosByUser(userId)
        } else {
            flowOf(emptyList())
        }
    }

    /**
     * Obtiene art√≠culos filtrados por categor√≠a
     */
    fun getArticulosByCategoria(categoriaId: String): Flow<List<ArticuloEntity>> {
        val userId = ConfigurationManager.getCurrentUserId()
        return if (userId != null) {
            articuloDao.getArticulosByUserAndCategoria(userId, categoriaId)
        } else {
            flowOf(emptyList())
        }
    }

    /**
     * Crea un nuevo art√≠culo - PATR√ìN H√çBRIDO
     */
    suspend fun crearArticulo(
        nombre: String,
        idCategoria: String,
        precioVenta: Double,
        precioCoste: Double? = null,
        stock: Int? = null,
        controlarStock: Boolean = false,
        controlarCoste: Boolean = false,
        favorito: Boolean = false,
        fotoUri: String? = null
    ): String = withContext(Dispatchers.IO) {
        val userId = ConfigurationManager.getCurrentUserId()
            ?: throw IllegalStateException("No se puede crear art√≠culo sin usuario")

        Log.d(TAG, "üîÑ Creando art√≠culo para usuario: $userId")

        val nuevoArticulo = ArticuloEntity(
            userId = userId,
            nombre = nombre,
            idCategoria = idCategoria,
            precioVenta = precioVenta,
            precioCoste = precioCoste,
            stock = stock,
            controlarStock = controlarStock,
            controlarCoste = controlarCoste,
            favorito = favorito,
            fotoUri = fotoUri,
            sincronizadoFirebase = false
        )

        try {
            // 1. GUARDAR EN ROOM PRIMERO (respuesta inmediata)
            articuloDao.insertArticulo(nuevoArticulo)
            Log.d(TAG, "‚úÖ Art√≠culo guardado en Room: ${nuevoArticulo.nombre}")

            // 2. INTENTAR SINCRONIZAR CON FIREBASE
            sincronizarArticuloConFirebase(nuevoArticulo)

            return@withContext nuevoArticulo.idArticulo

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error creando art√≠culo", e)
            throw e
        }
    }

    /**
     * Actualiza un art√≠culo existente - PATR√ìN H√çBRIDO
     */
    suspend fun actualizarArticulo(articulo: ArticuloEntity): Boolean = withContext(Dispatchers.IO) {
        try {
            val articuloActualizado = articulo.copy(
                version = articulo.version + 1,
                lastModified = System.currentTimeMillis(),
                sincronizadoFirebase = false
            )

            // 1. ACTUALIZAR EN ROOM PRIMERO
            articuloDao.updateArticulo(articuloActualizado)
            Log.d(TAG, "‚úÖ Art√≠culo actualizado en Room: ${articuloActualizado.nombre}")

            // 2. INTENTAR SINCRONIZAR CON FIREBASE
            sincronizarArticuloConFirebase(articuloActualizado)

            true
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error actualizando art√≠culo", e)
            false
        }
    }

    /**
     * Elimina un art√≠culo - PATR√ìN H√çBRIDO
     */
    suspend fun eliminarArticulo(articulo: ArticuloEntity): Boolean = withContext(Dispatchers.IO) {
        try {
            // 1. ELIMINAR DE ROOM PRIMERO
            articuloDao.deleteArticulo(articulo)
            Log.d(TAG, "‚úÖ Art√≠culo eliminado de Room: ${articulo.nombre}")

            // 2. INTENTAR ELIMINAR DE FIREBASE
            eliminarArticuloDeFirebase(articulo.idArticulo)

            true
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error eliminando art√≠culo", e)
            false
        }
    }

    /**
     * Obtiene art√≠culo por ID
     */
    suspend fun getArticuloById(id: String): ArticuloEntity? = withContext(Dispatchers.IO) {
        articuloDao.getArticuloById(id)
    }

    // ========== ESTRATEGIA H√çBRIDA INTELIGENTE ==========

    /**
     * Obtiene datos h√≠bridos: combina lo mejor de Room y Firebase
     */
    suspend fun getHybridArticulos(userId: String): List<ArticuloEntity> = withContext(Dispatchers.IO) {
        try {
            // 1. Verificar cambios pendientes en Room
            val articulosNoSincronizados = articuloDao.getArticulosNoSincronizadosByUser(userId)

            if (articulosNoSincronizados.isNotEmpty()) {
                // HAY CAMBIOS PENDIENTES ‚Üí Room es fuente de verdad
                Log.d(TAG, "üì± Usando Room (${articulosNoSincronizados.size} cambios pendientes)")
                return@withContext articuloDao.getArticulosByUser(userId).first()
            } else {
                // NO HAY CAMBIOS PENDIENTES ‚Üí Intentar Firebase
                Log.d(TAG, "‚òÅÔ∏è Intentando Firebase (sin cambios pendientes)")

                if (connectivityObserver.isConnected.first()) {
                    try {
                        val firebaseArticulos = descargarArticulosDesdeFirebase(userId)
                        if (firebaseArticulos.isNotEmpty()) {
                            // Actualizar Room con datos frescos
                            firebaseArticulos.forEach { articulo ->
                                articuloDao.insertOrUpdate(articulo.copy(sincronizadoFirebase = true))
                            }
                            Log.d(TAG, "‚úÖ Datos frescos de Firebase aplicados")
                        }
                    } catch (e: Exception) {
                        Log.w(TAG, "‚ö†Ô∏è Error con Firebase, usando Room como fallback", e)
                    }
                }

                // Devolver datos de Room (actualizados o fallback)
                return@withContext articuloDao.getArticulosByUser(userId).first()
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error en estrategia h√≠brida", e)
            // Fallback total a Room
            return@withContext articuloDao.getArticulosByUser(userId).first()
        }
    }

    // ========== SINCRONIZACI√ìN CON FIREBASE ==========

    /**
     * Sincroniza un art√≠culo espec√≠fico con Firebase
     */
    private suspend fun sincronizarArticuloConFirebase(articulo: ArticuloEntity) {
        try {
            if (!connectivityObserver.isConnected.first()) {
                Log.d(TAG, "‚ö†Ô∏è Sin conexi√≥n, art√≠culo quedar√° pendiente de sincronizaci√≥n")
                return
            }

            val datos = mapOf(
                "idArticulo" to articulo.idArticulo,
                "userId" to articulo.userId,
                "nombre" to articulo.nombre,
                "idCategoria" to articulo.idCategoria,
                "precioVenta" to articulo.precioVenta,
                "precioCoste" to articulo.precioCoste,
                "stock" to articulo.stock,
                "controlarStock" to articulo.controlarStock,
                "controlarCoste" to articulo.controlarCoste,
                "favorito" to articulo.favorito,
                "fotoUri" to articulo.fotoUri,
                "activo" to articulo.activo,
                "version" to articulo.version,
                "lastModified" to articulo.lastModified,
                "fechaSync" to System.currentTimeMillis()
            )

            firestore.collection("articulos")
                .document(articulo.idArticulo)
                .set(datos)
                .await()

            // Marcar como sincronizado en Room
            articuloDao.marcarComoSincronizado(articulo.idArticulo)
            Log.d(TAG, "‚òÅÔ∏è Art√≠culo sincronizado con Firebase: ${articulo.nombre}")

        } catch (e: Exception) {
            Log.w(TAG, "‚ö†Ô∏è Error sincronizando con Firebase: ${articulo.nombre}", e)
            // El art√≠culo queda marcado como no sincronizado para reintento posterior
        }
    }

    /**
     * Elimina art√≠culo de Firebase
     */
    private suspend fun eliminarArticuloDeFirebase(articuloId: String) {
        try {
            if (connectivityObserver.isConnected.first()) {
                firestore.collection("articulos")
                    .document(articuloId)
                    .delete()
                    .await()
                Log.d(TAG, "‚òÅÔ∏è Art√≠culo eliminado de Firebase: $articuloId")
            }
        } catch (e: Exception) {
            Log.w(TAG, "‚ö†Ô∏è Error eliminando de Firebase: $articuloId", e)
        }
    }

    /**
     * Sincroniza art√≠culos no sincronizados cuando hay conexi√≥n
     */
    private suspend fun sincronizarArticulosNoSincronizados(userId: String) {
        try {
            val pendientes = articuloDao.getArticulosNoSincronizadosByUser(userId)
            Log.d(TAG, "üîÑ Sincronizando ${pendientes.size} art√≠culos pendientes")

            pendientes.forEach { articulo ->
                sincronizarArticuloConFirebase(articulo)
                delay(100) // Evitar saturar Firebase
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error sincronizando pendientes", e)
        }
    }

    /**
     * Descarga art√≠culos desde Firebase
     */
    private suspend fun descargarArticulosDesdeFirebase(userId: String): List<ArticuloEntity> {
        return try {
            val snapshot = firestore.collection("articulos")
                .whereEqualTo("userId", userId)
                .whereEqualTo("activo", true)
                .get()
                .await()

            val articulos = snapshot.documents.mapNotNull { doc ->
                try {
                    val data = doc.data ?: return@mapNotNull null
                    ArticuloEntity(
                        idArticulo = data["idArticulo"] as? String ?: "",
                        userId = data["userId"] as? String ?: "",
                        nombre = data["nombre"] as? String ?: "",
                        idCategoria = data["idCategoria"] as? String ?: "",
                        precioVenta = (data["precioVenta"] as? Number)?.toDouble() ?: 0.0,
                        precioCoste = (data["precioCoste"] as? Number)?.toDouble(),
                        stock = (data["stock"] as? Long)?.toInt(),
                        controlarStock = data["controlarStock"] as? Boolean ?: false,
                        controlarCoste = data["controlarCoste"] as? Boolean ?: false,
                        favorito = data["favorito"] as? Boolean ?: false,
                        fotoUri = data["fotoUri"] as? String,
                        activo = data["activo"] as? Boolean ?: true,
                        version = data["version"] as? Long ?: 1L,
                        lastModified = data["lastModified"] as? Long ?: System.currentTimeMillis(),
                        sincronizadoFirebase = true
                    )
                } catch (e: Exception) {
                    Log.w(TAG, "‚ö†Ô∏è Error parseando art√≠culo de Firebase", e)
                    null
                }
            }

            Log.d(TAG, "‚òÅÔ∏è Descargados ${articulos.size} art√≠culos de Firebase")
            articulos

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error descargando de Firebase", e)
            emptyList()
        }
    }

    // ========== UTILIDADES ==========

    /**
     * Verifica si existe un art√≠culo con el mismo nombre
     */
    suspend fun existeArticuloConNombre(nombre: String, excludeId: String = ""): Boolean {
        val userId = ConfigurationManager.getCurrentUserId() ?: return false
        return articuloDao.existeArticuloConNombre(userId, nombre, excludeId)
    }

    /**
     * Busca art√≠culos por nombre
     */
    fun searchArticulos(query: String): Flow<List<ArticuloEntity>> {
        val userId = ConfigurationManager.getCurrentUserId()
        return if (userId != null && query.isNotBlank()) {
            articuloDao.searchArticulosByNombre(userId, query)
        } else {
            flowOf(emptyList())
        }
    }

    /**
     * Fuerza sincronizaci√≥n completa
     */
    suspend fun forzarSincronizacion(): Boolean = withContext(Dispatchers.IO) {
        try {
            val userId = ConfigurationManager.getCurrentUserId() ?: return@withContext false

            sincronizarArticulosNoSincronizados(userId)
            getHybridArticulos(userId) // Esto descargar√° datos frescos de Firebase

            true
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error en sincronizaci√≥n forzada", e)
            false
        }
    }
}

package es.nuskysoftware.marketsales.data.repository

import android.content.Context
import android.util.Log
import androidx.room.withTransaction
import com.google.firebase.Firebase
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.FirebaseUser
import com.google.firebase.auth.GoogleAuthProvider
import com.google.firebase.auth.auth
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.SetOptions
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.data.local.database.AppDatabase
import es.nuskysoftware.marketsales.data.local.entity.*
import es.nuskysoftware.marketsales.data.local.dao.*
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.tasks.await

/**
 * AuthRepository ‚Äî FIX login/menu + restauraci√≥n Premium con indicador de progreso
 *
 * Cambios CLAVE:
 *  1) Se marca isAuthenticated/usuarioLogueado en cuanto hay login OK (antes de la carga h√≠brida).
 *  2) La carga h√≠brida se lanza en repoScope (SupervisorJob) para que no se cancele.
 *  3) Se expone syncState para mostrar ‚ÄúDescargando datos‚Ä¶‚Äù en la UI.
 *  4) Si la carga h√≠brida falla/cancela, se mantiene usuario autenticado y se intenta fallback Room.
 */

sealed class AuthState {
    object Loading : AuthState()
    object Unauthenticated : AuthState()
    data class Authenticated(val user: FirebaseUser) : AuthState()
    data class Error(val message: String) : AuthState()
}

sealed class AuthResult {
    data class Success(val user: FirebaseUser?) : AuthResult()
    data class Error(val message: String) : AuthResult()
}

sealed class SyncState {
    object Idle : SyncState()
    object Checking : SyncState()
    object Downloading : SyncState()
    object Uploading : SyncState()
    object Merging : SyncState()
    object Done : SyncState()
    data class Error(val message: String) : SyncState()
}

class AuthRepository(
    private val context: Context
) {
    private val firebaseAuth = FirebaseAuth.getInstance()
    private val firestore = FirebaseFirestore.getInstance()

    // Estado de ‚Äúrestauraci√≥n permitida‚Äù (Premium)
    private val _restoreAllowed = MutableStateFlow<Boolean?>(null)
    val restoreAllowed: StateFlow<Boolean?> = _restoreAllowed
    private val _restoreBlockMessage = MutableStateFlow<String?>(null)
    val restoreBlockMessage: StateFlow<String?> = _restoreBlockMessage

    // Estado de sincronizaci√≥n/descarga (para la pantallita)
    private val _syncState = MutableStateFlow<SyncState>(SyncState.Idle)
    val syncState: StateFlow<SyncState> = _syncState.asStateFlow()

    private var isLoadingConfiguration = false

    // Repos locales
    private val userRepository = UserRepository(context)
    private val configuracionRepository = ConfiguracionRepository(context)

    // Room
    private val db: AppDatabase by lazy { AppDatabase.getDatabase(context) }
    private val categoriaDao: CategoriaDao by lazy { db.categoriaDao() }
    private val articuloDao: ArticuloDao by lazy { db.articuloDao() }
    private val mercadilloDao: MercadilloDao by lazy { db.mercadilloDao() }
    private val recibosDao: RecibosDao by lazy { db.recibosDao() }
    private val lineasDao: LineasVentaDao by lazy { db.lineasVentaDao() }

    private val _authState = MutableStateFlow<AuthState>(AuthState.Loading)
    val authState: StateFlow<AuthState> = _authState.asStateFlow()

    private val _currentUser = MutableStateFlow<FirebaseUser?>(null)
    val currentUser: StateFlow<FirebaseUser?> = _currentUser.asStateFlow()

    // ‚ú≥Ô∏è √Åmbito propio NO cancelable por la UI
    private val repoScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

    companion object {
        private const val TAG = "AuthRepository"

        private fun colUserRoot(db: FirebaseFirestore, uid: String) =
            db.collection("users").document(uid)
        private fun colCategorias(db: FirebaseFirestore, uid: String) =
            colUserRoot(db, uid).collection("categorias")
        private fun colArticulos(db: FirebaseFirestore, uid: String) =
            colUserRoot(db, uid).collection("articulos")
        private fun colMercadillos(db: FirebaseFirestore, uid: String) =
            colUserRoot(db, uid).collection("mercadillos")
        private fun colRecibos(db: FirebaseFirestore, uid: String) =
            colUserRoot(db, uid).collection("recibos")
        private fun colLineas(db: FirebaseFirestore, uid: String, idRecibo: String) =
            colRecibos(db, uid).document(idRecibo).collection("lineas")
    }

    // ================== init ==================
    init {
        val user = firebaseAuth.currentUser
        _currentUser.value = user
        _authState.value = if (user != null) {
            AuthState.Authenticated(user)
        } else {
            AuthState.Unauthenticated
        }

        if (user != null) {
            Log.d(TAG, "Usuario existente detectado: ${user.email}")
            // Lanzar carga h√≠brida fuera del alcance de la UI
            repoScope.launch {
                try {
                    loadUserConfigurationHybrid(user.uid)
                } catch (e: Exception) {
                    Log.e(TAG, "Error cargando configuraci√≥n h√≠brida en init", e)
                    // Mantener usuario autenticado aunque falle la carga
                    ConfigurationManager.updateUserConfiguration(
                        usuarioId = user.uid,
                        usuarioEmail = user.email,
                        displayName = user.displayName,
                        isAuthenticated = true,
                        planUsuario = "FREE"
                    )
                }
            }
        } else {
            ConfigurationManager.logout()
            Log.d(TAG, "No hay usuario - ConfigurationManager en estado logout")
        }

        firebaseAuth.addAuthStateListener { auth ->
            val current = auth.currentUser
            _currentUser.value = current
            _authState.value = if (current != null) {
                AuthState.Authenticated(current)
            } else {
                AuthState.Unauthenticated
            }
        }

        Log.d(TAG, "AuthRepository inicializado - Usuario actual: ${user?.email ?: "null"}")
    }

    // ========== M√âTODOS DE TESTING ==========
    fun testConnection(): Boolean {
        return try {
            val app = firebaseAuth.app
            Log.d(TAG, "Conexi√≥n Firebase Auth OK - App: ${app.name}")
            true
        } catch (e: Exception) {
            Log.e(TAG, "Error conexi√≥n Firebase Auth", e)
            false
        }
    }

    /**
     * Carga h√≠brida + flags Premium + bootstrap/sync
     * No se cancela por recomposiciones.
     */
    private suspend fun loadUserConfigurationHybrid(usuarioUid: String) {
        if (isLoadingConfiguration) {
            Log.d(TAG, "Ya se est√° cargando configuraci√≥n, omitiendo")
            return
        }

        isLoadingConfiguration = true
        _syncState.value = SyncState.Checking
        try {
            Log.d(TAG, "üîÑ Cargando configuraci√≥n H√çBRIDA para usuario: $usuarioUid")

            val firebaseDisplayName = Firebase.auth.currentUser?.displayName
            // Preferir remoto pero si falla, h√≠brido/repositorios hacen fallback interno
            val userEntity = userRepository.getHybridUserData(usuarioUid)
            val configEntity = configuracionRepository.getHybridConfiguracion()
            configuracionRepository.setUsuarioLogueado(usuarioUid)

            if (configEntity != null && userEntity != null) {
                val finalConfig = if (!userEntity.esPremium) {
                    configEntity.copy(
                        idioma = "es",
                        fuente = "Montserrat",
                        moneda = "‚Ç¨ Euro",
                        pendienteSync = true
                    )
                } else configEntity

                val finalDisplayName =
                    if (!firebaseDisplayName.isNullOrBlank() && firebaseDisplayName != userEntity.displayName) {
                        userRepository.updateUserDisplayName(usuarioUid, firebaseDisplayName)
                        firebaseDisplayName
                    } else userEntity.displayName ?: ""

                ConfigurationManager.updateUserConfiguration(
                    idioma = finalConfig.idioma,
                    fuente = finalConfig.fuente,
                    temaOscuro = finalConfig.temaOscuro,
                    moneda = finalConfig.moneda,
                    usuarioEmail = userEntity.email,
                    usuarioId = usuarioUid,
                    displayName = finalDisplayName,
                    planUsuario = if (userEntity.esPremium) "PREMIUM" else "FREE",
                    isAuthenticated = true
                )

                if (userEntity.esPremium) {
                    _restoreAllowed.value = true
                    _restoreBlockMessage.value = null
                } else {
                    _restoreAllowed.value = false
                    _restoreBlockMessage.value = "Para recuperar tus datos en este dispositivo necesitas el plan Premium."
                }

                // Bootstrap/Sync
                handlePostLoginDataSync(usuarioUid, isPremium = userEntity.esPremium)
            } else {
                // Fallback m√≠nimo: mantener sesi√≥n y permitir que la app funcione
                Log.w(TAG, "Config h√≠brida no disponible, aplicando fallback m√≠nimo")
                ConfigurationManager.updateUserConfiguration(
                    usuarioId = usuarioUid,
                    usuarioEmail = Firebase.auth.currentUser?.email,
                    displayName = Firebase.auth.currentUser?.displayName,
                    isAuthenticated = true,
                    planUsuario = "FREE"
                )
                _restoreAllowed.value = false
                _restoreBlockMessage.value = "No se pudo cargar la configuraci√≥n. Intenta de nuevo."
                _syncState.value = SyncState.Done
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error real cargando configuraci√≥n h√≠brida", e)
            // Mantener usuario autenticado aunque haya error
            ConfigurationManager.updateUserConfiguration(
                usuarioId = usuarioUid,
                usuarioEmail = Firebase.auth.currentUser?.email,
                displayName = Firebase.auth.currentUser?.displayName,
                isAuthenticated = true,
                planUsuario = "FREE"
            )
            _restoreAllowed.value = false
            _restoreBlockMessage.value = "No se pudo cargar la configuraci√≥n. Intenta de nuevo."
            _syncState.value = SyncState.Error(e.message ?: "Error de sincronizaci√≥n")
        } finally {
            isLoadingConfiguration = false
        }
    }

    // ====== N√∫cleo bootstrap/sync ======
    private suspend fun handlePostLoginDataSync(uid: String, isPremium: Boolean) = withContext(Dispatchers.IO) {
        try {
            if (!isPremium) {
                Log.i(TAG, "FREE ‚Üí no se restaura. (Paywall en UI)")
                _syncState.value = SyncState.Done
                return@withContext
            }

            val empty = isRoomEmptyForUser(uid)
            if (empty) {
                Log.i(TAG, "üì¶ Room vac√≠o ‚Üí Bootstrap TOTAL desde Firebase (Premium).")
                _syncState.value = SyncState.Downloading
                bootstrapFromFirebase(uid)
                _syncState.value = SyncState.Done
                return@withContext
            }

            val hasPendingLocal = hasLocalPendings(uid)
            if (hasPendingLocal) {
                Log.i(TAG, "üîÅ Pendientes locales ‚Üí Subir pendientes y despu√©s bajar actualizaciones.")
                _syncState.value = SyncState.Uploading
                pushLocalPendings(uid)
                _syncState.value = SyncState.Merging
                pullAllFromFirebaseMerge(uid) // upsert sin borrar
                _syncState.value = SyncState.Done
            } else {
                Log.i(TAG, "‚¨áÔ∏è Sin pendientes locales ‚Üí Reemplazo TOTAL por datos de Firebase (por usuario).")
                _syncState.value = SyncState.Downloading
                replaceAllFromFirebase(uid)
                _syncState.value = SyncState.Done
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error en handlePostLoginDataSync", e)
            _syncState.value = SyncState.Error(e.message ?: "Error de sincronizaci√≥n")
        }
    }

    // ---- Helpers de estado local ----
    private suspend fun isRoomEmptyForUser(uid: String): Boolean {
        val hasCats = categoriaDao.existeAlgunoDeUsuario(uid)
        val hasArts = articuloDao.existeAlgunoDeUsuario(uid)
        val hasMerc = mercadilloDao.existeAlgunoDeUsuario(uid)
        val hasRec  = recibosDao.existeAlgunoDeUsuario(uid)
        val hasLin  = lineasDao.existeAlgunoDeUsuario(uid)
        return !(hasCats || hasArts || hasMerc || hasRec || hasLin)
    }

    private suspend fun hasLocalPendings(uid: String): Boolean {
        val catsPend = categoriaDao.getCategoriasNoSincronizadasByUser(uid).isNotEmpty()
        val artsPend = articuloDao.getArticulosNoSincronizadosByUser(uid).isNotEmpty()
        val mercPend = mercadilloDao.getMercadillosNoSincronizadosByUser(uid).isNotEmpty()
        return catsPend || artsPend || mercPend
    }

    // ---- Bootstrap TOTAL (Premium + Room vac√≠o) ----
    private suspend fun bootstrapFromFirebase(uid: String) = withContext(Dispatchers.IO) {
        val remote = fetchAllFromFirebase(uid)
        db.withTransaction {
            categoriaDao.upsertAll(remote.categorias)
            articuloDao.upsertAll(remote.articulos)
            mercadilloDao.upsertAll(remote.mercadillos)
            recibosDao.upsertAll(remote.recibos)
            lineasDao.upsertAll(remote.lineas)

            remote.categorias.forEach { categoriaDao.marcarComoSincronizada(it.idCategoria) }
            remote.articulos.forEach  { articuloDao.marcarComoSincronizado(it.idArticulo) }
            remote.mercadillos.forEach{ mercadilloDao.marcarComoSincronizado(it.idMercadillo) }
        }
        Log.i(TAG, "‚úÖ Bootstrap completado para uid=$uid")
    }

    // ---- Reemplazo TOTAL (Room no vac√≠o, sin pendientes) ----
    private suspend fun replaceAllFromFirebase(uid: String) = withContext(Dispatchers.IO) {
        val remote = fetchAllFromFirebase(uid)
        db.withTransaction {
            categoriaDao.borrarPorUsuario(uid)
            articuloDao.borrarPorUsuario(uid)
            mercadilloDao.borrarPorUsuario(uid)
            recibosDao.borrarPorUsuario(uid)
            lineasDao.borrarPorUsuario(uid)

            categoriaDao.upsertAll(remote.categorias)
            articuloDao.upsertAll(remote.articulos)
            mercadilloDao.upsertAll(remote.mercadillos)
            recibosDao.upsertAll(remote.recibos)
            lineasDao.upsertAll(remote.lineas)

            remote.categorias.forEach { categoriaDao.marcarComoSincronizada(it.idCategoria) }
            remote.articulos.forEach  { articuloDao.marcarComoSincronizado(it.idArticulo) }
            remote.mercadillos.forEach{ mercadilloDao.marcarComoSincronizado(it.idMercadillo) }
        }
        Log.i(TAG, "‚úÖ Reemplazo completo desde Firebase para uid=$uid")
    }

    // ---- Merge (subir pendientes y luego bajar actualizaciones) ----
    private suspend fun pullAllFromFirebaseMerge(uid: String) = withContext(Dispatchers.IO) {
        val remote = fetchAllFromFirebase(uid)
        db.withTransaction {
            categoriaDao.upsertAll(remote.categorias)
            articuloDao.upsertAll(remote.articulos)
            mercadilloDao.upsertAll(remote.mercadillos)
            recibosDao.upsertAll(remote.recibos)
            lineasDao.upsertAll(remote.lineas)

            remote.categorias.forEach { categoriaDao.marcarComoSincronizada(it.idCategoria) }
            remote.articulos.forEach  { articuloDao.marcarComoSincronizado(it.idArticulo) }
            remote.mercadillos.forEach{ mercadilloDao.marcarComoSincronizado(it.idMercadillo) }
        }
        Log.i(TAG, "‚úÖ Pull MERGE desde Firebase para uid=$uid")
    }

    private suspend fun pushLocalPendings(uid: String) {
        val cats = categoriaDao.getCategoriasNoSincronizadasByUser(uid)
        cats.forEach { c ->
            colCategorias(firestore, uid).document(c.idCategoria).set(c.toMap(), SetOptions.merge()).await()
            categoriaDao.marcarComoSincronizada(c.idCategoria)
        }
        val arts = articuloDao.getArticulosNoSincronizadosByUser(uid)
        arts.forEach { a ->
            colArticulos(firestore, uid).document(a.idArticulo).set(a.toMap(), SetOptions.merge()).await()
            articuloDao.marcarComoSincronizado(a.idArticulo)
        }
        val mercs = mercadilloDao.getMercadillosNoSincronizadosByUser(uid)
        mercs.forEach { m ->
            colMercadillos(firestore, uid).document(m.idMercadillo).set(m.toMap(), SetOptions.merge()).await()
            mercadilloDao.marcarComoSincronizado(m.idMercadillo)
        }
        Log.i(TAG, "‚¨ÜÔ∏è Pendientes locales subidos a Firebase (uid=$uid)")
    }

    // ---- Fetch remoto (todas las colecciones del usuario) ----
    private suspend fun fetchAllFromFirebase(uid: String): RemoteBundle {
        val cats = colCategorias(firestore, uid).get().await().documents.mapNotNull { it.toCategoria(uid) }
        val arts = colArticulos(firestore, uid).get().await().documents.mapNotNull { it.toArticulo(uid) }
        val mercs = colMercadillos(firestore, uid).get().await().documents.mapNotNull { it.toMercadillo(uid) }
        val recs = colRecibos(firestore, uid).get().await().documents.mapNotNull { it.toRecibo(uid) }

        val lineas = mutableListOf<LineaVentaEntity>()
        for (r in recs) {
            val snap = colLineas(firestore, uid, r.idRecibo).get().await()
            lineas += snap.documents.mapNotNull { it.toLinea(uid, r.idRecibo) }
        }
        return RemoteBundle(cats, arts, mercs, recs, lineas)
    }

    // ====== API p√∫blica ======
    suspend fun refreshUserConfiguration() {
        val currentUser = Firebase.auth.currentUser
        if (currentUser != null) {
            Log.d(TAG, "üîÑ Forzando refresh de configuraci√≥n de usuario")
            repoScope.launch { loadUserConfigurationHybrid(currentUser.uid) }
        }
    }

    fun isUserAuthenticated(): Boolean {
        val authenticated = firebaseAuth.currentUser != null
        Log.d(TAG, "¬øUsuario autenticado? $authenticated")
        return authenticated
    }

    // ====== Registro/Login/Google Auth ======
    suspend fun registerWithEmail(email: String, password: String): AuthResult {
        return try {
            Log.d(TAG, "Iniciando registro para: $email")
            _authState.value = AuthState.Loading
            val authResult = firebaseAuth.createUserWithEmailAndPassword(email, password).await()
            val user = authResult.user
            if (user != null) {
                userRepository.getOrCreateUser(
                    uid = user.uid,
                    email = user.email ?: "",
                    displayName = user.displayName ?: "",
                    photoUrl = user.photoUrl?.toString() ?: "",
                    esPremium = false
                )

                // ‚úÖ Marcar sesi√≥n ACTIVA ya mismo ‚Üí reacciona el men√∫
                ConfigurationManager.updateUserConfiguration(
                    usuarioId = user.uid,
                    usuarioEmail = user.email,
                    displayName = user.displayName,
                    isAuthenticated = true,
                    planUsuario = "FREE"
                )

                // Carga h√≠brida en background
                repoScope.launch { loadUserConfigurationHybrid(user.uid) }

                _authState.value = AuthState.Authenticated(user)
                AuthResult.Success(user)
            } else {
                val error = "Error: Usuario nulo despu√©s del registro"
                Log.e(TAG, error)
                _authState.value = AuthState.Error(error)
                AuthResult.Error(error)
            }
        } catch (e: Exception) {
            val errorMessage = "Error en registro: ${e.message}"
            Log.e(TAG, errorMessage, e)
            _authState.value = AuthState.Error(errorMessage)
            AuthResult.Error(errorMessage)
        }
    }

    suspend fun loginWithEmail(email: String, password: String): AuthResult {
        return try {
            Log.d(TAG, "Iniciando login para: $email")
            _authState.value = AuthState.Loading
            val authResult = firebaseAuth.signInWithEmailAndPassword(email, password).await()
            val user = authResult.user
            if (user != null) {
                userRepository.getOrCreateUser(
                    uid = user.uid,
                    email = user.email ?: "",
                    displayName = user.displayName ?: "",
                    photoUrl = user.photoUrl?.toString() ?: ""
                )

                // ‚úÖ Marcar sesi√≥n ACTIVA ya mismo ‚Üí reacciona el men√∫
                ConfigurationManager.updateUserConfiguration(
                    usuarioId = user.uid,
                    usuarioEmail = user.email,
                    displayName = user.displayName,
                    isAuthenticated = true,
                    planUsuario = "FREE"
                )

                // Carga h√≠brida + bootstrap/sync en background NO cancelable
                repoScope.launch { loadUserConfigurationHybrid(user.uid) }

                _authState.value = AuthState.Authenticated(user)
                AuthResult.Success(user)
            } else {
                val error = "Error: Usuario nulo despu√©s del login"
                Log.e(TAG, error)
                _authState.value = AuthState.Error(error)
                AuthResult.Error(error)
            }
        } catch (e: Exception) {
            val errorMessage = when (e.message) {
                "The email address is badly formatted." -> "Email inv√°lido"
                "The password is invalid or the user does not have a password." -> "Contrase√±a incorrecta"
                "There is no user record corresponding to this identifier. The user may have been deleted." -> "Usuario no encontrado"
                "A network error (such as timeout, interrupted connection or unreachable host) has occurred." -> "Error de conexi√≥n"
                else -> "Error en login: ${e.message}"
            }
            Log.e(TAG, errorMessage, e)
            _authState.value = AuthState.Error(errorMessage)
            AuthResult.Error(errorMessage)
        }
    }

    suspend fun signInWithGoogle(idToken: String): AuthResult {
        return try {
            Log.d(TAG, "Iniciando Google Auth con idToken")
            _authState.value = AuthState.Loading
            val credential = GoogleAuthProvider.getCredential(idToken, null)
            val authResult = firebaseAuth.signInWithCredential(credential).await()
            val user = authResult.user
            if (user != null) {
                userRepository.getOrCreateUser(
                    uid = user.uid,
                    email = user.email ?: "",
                    displayName = user.displayName ?: "",
                    photoUrl = user.photoUrl?.toString() ?: ""
                )

                // ‚úÖ Marcar sesi√≥n ACTIVA ya mismo ‚Üí reacciona el men√∫
                ConfigurationManager.updateUserConfiguration(
                    usuarioId = user.uid,
                    usuarioEmail = user.email,
                    displayName = user.displayName,
                    isAuthenticated = true,
                    planUsuario = "FREE"
                )

                // Carga h√≠brida en background
                repoScope.launch { loadUserConfigurationHybrid(user.uid) }

                _authState.value = AuthState.Authenticated(user)
                AuthResult.Success(user)
            } else {
                val error = "Error: Usuario nulo despu√©s de Google Auth"
                Log.e(TAG, error)
                _authState.value = AuthState.Error(error)
                AuthResult.Error(error)
            }
        } catch (e: Exception) {
            val errorMessage = when (e.message) {
                "An internal error has occurred. [ INVALID_IDP_RESPONSE ]" -> "Error de autenticaci√≥n con Google"
                "A network error (such as timeout, interrupted connection or unreachable host) has occurred." -> "Error de conexi√≥n"
                else -> "Error en Google Auth: ${e.message}"
            }
            Log.e(TAG, errorMessage, e)
            _authState.value = AuthState.Error(errorMessage)
            AuthResult.Error(errorMessage)
        }
    }

    suspend fun logout(): AuthResult {
        return try {
            Log.d(TAG, "Cerrando sesi√≥n...")
            _authState.value = AuthState.Loading
            firebaseAuth.signOut()
            configuracionRepository.setUsuarioLogueado("usuario_default")
            ConfigurationManager.updateUserConfiguration(
                idioma = "es",
                fuente = "Montserrat",
                temaOscuro = false,
                moneda = "‚Ç¨ Euro",
                usuarioEmail = null,
                usuarioId = null,
                displayName = null,
                isAuthenticated = false,
                planUsuario = "FREE"
            )
            _restoreAllowed.value = null
            _restoreBlockMessage.value = null
            _syncState.value = SyncState.Idle
            Log.d(TAG, "‚úÖ Sesi√≥n cerrada y configuraci√≥n reseteada")
            _authState.value = AuthState.Unauthenticated
            AuthResult.Success(null)
        } catch (e: Exception) {
            val errorMessage = "Error al cerrar sesi√≥n: ${e.message}"
            Log.e(TAG, errorMessage, e)
            _authState.value = AuthState.Error(errorMessage)
            AuthResult.Error(errorMessage)
        }
    }

    // ====== (Opcionales/legacy sin cambios grandes) ======
    suspend fun updateUserProfile(userId: String, displayName: String, email: String) {
        try { userRepository.updateUserProfile(userId, displayName, email) } catch (e: Exception) { Log.e(TAG,"‚ùå",e) }
    }
    suspend fun updateUserProfileAndMarkDirty(userId: String, displayName: String, email: String) {
        try { userRepository.updateUserProfileAndMarkDirty(userId, displayName, email) } catch (e: Exception) { Log.e(TAG,"‚ùå",e) }
    }
    suspend fun updateUserInDatabase(userId: String, displayName: String, email: String) {
        try { userRepository.updateUserProfile(userId, displayName, email) } catch (e: Exception) { Log.e(TAG,"‚ùå",e) }
    }
    suspend fun loadUserConfiguration(usuarioUid: String, esPremium: Boolean) {
        try {
            val configEntity = configuracionRepository.getConfiguracion()
            configuracionRepository.setUsuarioLogueado(usuarioUid)
            val userEntity = userRepository.getUserById(usuarioUid)
            if (configEntity != null && userEntity != null) {
                ConfigurationManager.updateUserConfiguration(
                    idioma = configEntity.idioma,
                    fuente = configEntity.fuente,
                    temaOscuro = configEntity.temaOscuro,
                    moneda = configEntity.moneda,
                    usuarioEmail = userEntity.email,
                    usuarioId = usuarioUid,
                    displayName = userEntity.displayName,
                    planUsuario = if (userEntity.esPremium) "PREMIUM" else "FREE",
                    isAuthenticated = true
                )
            } else {
                // Mantener autenticaci√≥n aunque no haya config
                ConfigurationManager.updateUserConfiguration(
                    usuarioId = usuarioUid,
                    usuarioEmail = Firebase.auth.currentUser?.email,
                    displayName = Firebase.auth.currentUser?.displayName,
                    isAuthenticated = true,
                    planUsuario = if (esPremium) "PREMIUM" else "FREE"
                )
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error cargando configuraci√≥n (legacy)", e)
        }
    }
    suspend fun updateConfiguration(
        idioma: String?=null, fuente: String?=null, temaOscuro: Boolean?=null, moneda: String?=null
    ): Boolean {
        return try {
            val canChangeAdvanced = ConfigurationManager.canChangeConfiguration()
            if (idioma != null && canChangeAdvanced) { configuracionRepository.updateIdioma(idioma); ConfigurationManager.setIdioma(idioma) }
            if (fuente != null && canChangeAdvanced) { configuracionRepository.updateFuente(fuente); ConfigurationManager.setFuente(fuente) }
            if (moneda != null && canChangeAdvanced) { configuracionRepository.updateMoneda(moneda); ConfigurationManager.setMoneda(moneda) }
            if (temaOscuro != null) { configuracionRepository.updateTemaOscuro(temaOscuro); ConfigurationManager.setTemaOscuro(temaOscuro) }
            true
        } catch (e: Exception) { Log.e(TAG,"Error actualizando configuraci√≥n",e); false }
    }
    suspend fun updateUserPremium(esPremium: Boolean): Boolean {
        return try {
            val currentUser = firebaseAuth.currentUser ?: return false
            userRepository.updateUserPremium(currentUser.uid, esPremium)
            ConfigurationManager.updateUserPremium(esPremium)
            if (esPremium) { _restoreAllowed.value = true; _restoreBlockMessage.value = null }
            else { _restoreAllowed.value = false; _restoreBlockMessage.value = "Para recuperar tus datos en este dispositivo necesitas el plan Premium." }
            Log.d(TAG, "‚úÖ Estado Premium actualizado: $esPremium"); true
        } catch (e: Exception) { Log.e(TAG, "Error actualizando estado Premium", e); false }
    }

    fun getCurrentUserInfo(): Map<String, Any>? {
        val user = firebaseAuth.currentUser
        return if (user != null) {
            mapOf(
                "uid" to user.uid,
                "email" to (user.email ?: ""),
                "displayName" to (user.displayName ?: ""),
                "photoUrl" to (user.photoUrl?.toString() ?: ""),
                "isEmailVerified" to user.isEmailVerified,
                "creationTimestamp" to (user.metadata?.creationTimestamp ?: 0L),
                "provider" to if (user.providerData.any { it.providerId == "google.com" }) "google" else "email"
            )
        } else null
    }
}

// ====== Soportes internos ======
private data class RemoteBundle(
    val categorias: List<CategoriaEntity>,
    val articulos: List<ArticuloEntity>,
    val mercadillos: List<MercadilloEntity>,
    val recibos: List<ReciboEntity>,
    val lineas: List<LineaVentaEntity>
)

private fun CategoriaEntity.toMap(): Map<String, Any?> = mapOf(
    "idCategoria" to idCategoria,
    "userId" to userId,
    "nombre" to nombre,
    "colorHex" to colorHex,
    "orden" to orden,
    "activa" to activa,
    "version" to version,
    "lastModified" to lastModified,
    "sincronizadoFirebase" to true
)

private fun ArticuloEntity.toMap(): Map<String, Any?> = mapOf(
    "idArticulo" to idArticulo,
    "userId" to userId,
    "nombre" to nombre,
    "idCategoria" to idCategoria,
    "precioVenta" to precioVenta,
    "precioCoste" to precioCoste,
    "stock" to stock,
    "controlarStock" to controlarStock,
    "controlarCoste" to controlarCoste,
    "favorito" to favorito,
    "fotoUri" to fotoUri,
    "activo" to activo,
    "version" to version,
    "lastModified" to lastModified,
    "sincronizadoFirebase" to true
)

private fun MercadilloEntity.toMap(): Map<String, Any?> = mapOf(
    "idMercadillo" to idMercadillo,
    "userId" to userId,
    "fecha" to fecha,
    "lugar" to lugar,
    "organizador" to organizador,
    "esGratis" to esGratis,
    "importeSuscripcion" to importeSuscripcion,
    "requiereMesa" to requiereMesa,
    "requiereCarpa" to requiereCarpa,
    "hayPuntoLuz" to hayPuntoLuz,
    "horaInicio" to horaInicio,
    "horaFin" to horaFin,
    "estado" to estado,
    "pendienteArqueo" to pendienteArqueo,
    "pendienteAsignarSaldo" to pendienteAsignarSaldo,
    "saldoInicial" to saldoInicial,
    "saldoFinal" to saldoFinal,
    "arqueoCaja" to arqueoCaja,
    "totalVentas" to totalVentas,
    "totalGastos" to totalGastos,
    "arqueoMercadillo" to arqueoMercadillo,
    "activo" to activo,
    "version" to version,
    "lastModified" to lastModified,
    "sincronizadoFirebase" to true
)

private fun Map<String, Any?>.getString(key: String, def: String = ""): String =
    (this[key] as? String) ?: def
private fun Map<String, Any?>.getDouble(key: String, def: Double = 0.0): Double =
    when (val v = this[key]) { is Number -> v.toDouble(); is String -> v.toDoubleOrNull() ?: def; else -> def }
private fun Map<String, Any?>.getInt(key: String, def: Int = 0): Int =
    when (val v = this[key]) { is Number -> v.toInt(); is String -> v.toIntOrNull() ?: def; else -> def }
private fun Map<String, Any?>.getBool(key: String, def: Boolean = false): Boolean =
    when (val v = this[key]) { is Boolean -> v; is Number -> v.toInt()!=0; is String -> v=="true"; else -> def }
private fun Map<String, Any?>.getLong(key: String, def: Long = System.currentTimeMillis()): Long =
    when (val v = this[key]) { is Number -> v.toLong(); is String -> v.toLongOrNull() ?: def; else -> def }

private fun com.google.firebase.firestore.DocumentSnapshot.toCategoria(uid: String): CategoriaEntity? {
    val m = this.data ?: return null
    return CategoriaEntity(
        idCategoria = m.getString("idCategoria", this.id),
        userId = uid,
        nombre = m.getString("nombre"),
        colorHex = m.getString("colorHex", "#FFFFFF"),
        orden = m.getInt("orden", 0),
        activa = m.getBool("activa", true),
        version = m.getLong("version", 1),
        lastModified = m.getLong("lastModified", System.currentTimeMillis()),
        sincronizadoFirebase = true
    )
}
private fun com.google.firebase.firestore.DocumentSnapshot.toArticulo(uid: String): ArticuloEntity? {
    val m = this.data ?: return null
    return ArticuloEntity(
        idArticulo = m.getString("idArticulo", this.id),
        userId = uid,
        nombre = m.getString("nombre"),
        idCategoria = m.getString("idCategoria"),
        precioVenta = m.getDouble("precioVenta", 0.0),
        precioCoste = (m["precioCoste"] as? Number)?.toDouble(),
        stock = (m["stock"] as? Number)?.toInt(),
        controlarStock = m.getBool("controlarStock", false),
        controlarCoste = m.getBool("controlarCoste", false),
        favorito = m.getBool("favorito", false),
        fotoUri = m["fotoUri"] as? String,
        activo = m.getBool("activo", true),
        version = m.getLong("version", 1),
        lastModified = m.getLong("lastModified", System.currentTimeMillis()),
        sincronizadoFirebase = true
    )
}
private fun com.google.firebase.firestore.DocumentSnapshot.toMercadillo(uid: String): MercadilloEntity? {
    val m = this.data ?: return null
    return MercadilloEntity(
        idMercadillo = m.getString("idMercadillo", this.id),
        userId = uid,
        fecha = m.getString("fecha"),
        lugar = m.getString("lugar"),
        organizador = m.getString("organizador"),
        esGratis = m.getBool("esGratis", true),
        importeSuscripcion = m.getDouble("importeSuscripcion", 0.0),
        requiereMesa = m.getBool("requiereMesa", true),
        requiereCarpa = m.getBool("requiereCarpa", true),
        hayPuntoLuz = m.getBool("hayPuntoLuz", false),
        horaInicio = m.getString("horaInicio", "09:00"),
        horaFin = m.getString("horaFin", "14:00"),
        estado = m.getInt("estado", 1),
        pendienteArqueo = m.getBool("pendienteArqueo", false),
        pendienteAsignarSaldo = m.getBool("pendienteAsignarSaldo", false),
        saldoInicial = (m["saldoInicial"] as? Number)?.toDouble(),
        saldoFinal = (m["saldoFinal"] as? Number)?.toDouble(),
        arqueoCaja = (m["arqueoCaja"] as? Number)?.toDouble(),
        totalVentas = m.getDouble("totalVentas", 0.0),
        totalGastos = m.getDouble("totalGastos", 0.0),
        arqueoMercadillo = (m["arqueoMercadillo"] as? Number)?.toDouble(),
        activo = m.getBool("activo", true),
        version = m.getLong("version", 1),
        lastModified = m.getLong("lastModified", System.currentTimeMillis()),
        sincronizadoFirebase = true
    )
}
private fun com.google.firebase.firestore.DocumentSnapshot.toRecibo(uid: String): ReciboEntity? {
    val m = this.data ?: return null
    return ReciboEntity(
        idRecibo = m.getString("idRecibo", this.id),
        idMercadillo = m.getString("idMercadillo"),
        idUsuario = uid,
        fechaHora = m.getLong("fechaHora", System.currentTimeMillis()),
        metodoPago = m.getString("metodoPago", "efectivo"),
        totalTicket = m.getDouble("totalTicket", 0.0),
        estado = m.getString("estado", "COMPLETADO")
    )
}
private fun com.google.firebase.firestore.DocumentSnapshot.toLinea(uid: String, idRecibo: String): LineaVentaEntity? {
    val m = this.data ?: return null
    return LineaVentaEntity(
        idLinea = m.getString("idLinea", this.id),
        idRecibo = idRecibo,
        idMercadillo = m.getString("idMercadillo"),
        idUsuario = uid,
        numeroLinea = m.getInt("numeroLinea", 1),
        tipoLinea = m.getString("tipoLinea", "producto"),
        descripcion = m.getString("descripcion"),
        idProducto = m["idProducto"] as? String,
        cantidad = m.getInt("cantidad", 1),
        precioUnitario = m.getDouble("precioUnitario", 0.0),
        subtotal = m.getDouble("subtotal", 0.0),
        idLineaOriginalAbonada = m["idLineaOriginalAbonada"] as? String
    )
}


// app/src/main/java/es/nuskysoftware/marketsales/data/repository/CategoriaRepository.kt
package es.nuskysoftware.marketsales.data.repository

import android.content.Context
import android.util.Log
import com.google.firebase.firestore.FirebaseFirestore
import es.nuskysoftware.marketsales.data.local.dao.CategoriaDao
import es.nuskysoftware.marketsales.data.local.database.AppDatabase
import es.nuskysoftware.marketsales.data.local.entity.CategoriaEntity
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.ConnectivityObserver
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.tasks.await

/**
 * CategoriaRepository V11 - Market Sales
 *
 * ARQUITECTURA H√çBRIDA "RELOJ SUIZO":
 * - Local First: Toda operaci√≥n se ejecuta primero en Room
 * - Sync When Possible: Sincronizaci√≥n autom√°tica cuando hay conexi√≥n
 * - Never Block UI: La interfaz nunca espera operaciones de red
 * - Graceful Degradation: Funcionamiento completo offline
 * - Filtrado por usuario: Cada usuario solo ve sus datos
 */
class CategoriaRepository(
    context: Context
) {
    private val categoriaDao: CategoriaDao = AppDatabase.getDatabase(context).categoriaDao()
    private val firestore = FirebaseFirestore.getInstance()
    private val connectivityObserver = ConnectivityObserver(context)
    private val repositoryScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

    companion object {
        private const val TAG = "CategoriaRepository"
    }

    init {
        // Sincronizaci√≥n autom√°tica cuando volvemos online
        repositoryScope.launch {
            connectivityObserver.isConnected.collect { online ->
                if (online) {
                    val userId = ConfigurationManager.getCurrentUserId()
                    if (userId != null) {
                        sincronizarCategoriasNoSincronizadas(userId)
                    }
                }
            }
        }
    }

    // ========== OPERACIONES PRINCIPALES ==========

    /**
     * Obtiene todas las categor√≠as del usuario actual
     */
    fun getCategoriasUsuarioActual(): Flow<List<CategoriaEntity>> {
        val userId = ConfigurationManager.getCurrentUserId()
        return if (userId != null) {
            categoriaDao.getCategoriasByUser(userId)
        } else {
            flowOf(emptyList())
        }
    }

    /**
     * Crea una nueva categor√≠a - PATR√ìN H√çBRIDO
     */
    suspend fun crearCategoria(
        nombre: String,
        colorHex: String,
        orden: Int = 0
    ): String = withContext(Dispatchers.IO) {
        val userId = ConfigurationManager.getCurrentUserId()
            ?: throw IllegalStateException("No se puede crear categor√≠a sin usuario")

        Log.d(TAG, "üîÑ Creando categor√≠a para usuario: $userId")

        val nuevaCategoria = CategoriaEntity(
            userId = userId,
            nombre = nombre,
            colorHex = colorHex,
            orden = orden,
            sincronizadoFirebase = false
        )

        try {
            // 1. GUARDAR EN ROOM PRIMERO (respuesta inmediata)
            categoriaDao.insertCategoria(nuevaCategoria)
            Log.d(TAG, "‚úÖ Categor√≠a guardada en Room: ${nuevaCategoria.nombre}")

            // 2. INTENTAR SINCRONIZAR CON FIREBASE
            sincronizarCategoriaConFirebase(nuevaCategoria)

            return@withContext nuevaCategoria.idCategoria

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error creando categor√≠a", e)
            throw e
        }
    }

    /**
     * Actualiza una categor√≠a existente - PATR√ìN H√çBRIDO
     */
    suspend fun actualizarCategoria(categoria: CategoriaEntity): Boolean = withContext(Dispatchers.IO) {
        try {
            val categoriaActualizada = categoria.copy(
                version = categoria.version + 1,
                lastModified = System.currentTimeMillis(),
                sincronizadoFirebase = false
            )

            // 1. ACTUALIZAR EN ROOM PRIMERO
            categoriaDao.updateCategoria(categoriaActualizada)
            Log.d(TAG, "‚úÖ Categor√≠a actualizada en Room: ${categoriaActualizada.nombre}")

            // 2. INTENTAR SINCRONIZAR CON FIREBASE
            sincronizarCategoriaConFirebase(categoriaActualizada)

            true
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error actualizando categor√≠a", e)
            false
        }
    }

    /**
     * Elimina una categor√≠a - PATR√ìN H√çBRIDO
     */
    suspend fun eliminarCategoria(categoria: CategoriaEntity): Boolean = withContext(Dispatchers.IO) {
        try {
            // 1. ELIMINAR DE ROOM PRIMERO
            categoriaDao.deleteCategoria(categoria)
            Log.d(TAG, "‚úÖ Categor√≠a eliminada de Room: ${categoria.nombre}")

            // 2. INTENTAR ELIMINAR DE FIREBASE
            eliminarCategoriaDeFirebase(categoria.idCategoria)

            true
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error eliminando categor√≠a", e)
            false
        }
    }

    /**
     * Obtiene categor√≠a por ID
     */
    suspend fun getCategoriaById(id: String): CategoriaEntity? = withContext(Dispatchers.IO) {
        categoriaDao.getCategoriaById(id)
    }

    // ========== ESTRATEGIA H√çBRIDA INTELIGENTE ==========

    /**
     * Obtiene datos h√≠bridos: combina lo mejor de Room y Firebase
     */
    suspend fun getHybridCategorias(userId: String): List<CategoriaEntity> = withContext(Dispatchers.IO) {
        try {
            // 1. Verificar cambios pendientes en Room
            val categoriasNoSincronizadas = categoriaDao.getCategoriasNoSincronizadasByUser(userId)

            if (categoriasNoSincronizadas.isNotEmpty()) {
                // HAY CAMBIOS PENDIENTES ‚Üí Room es fuente de verdad
                Log.d(TAG, "üì± Usando Room (${categoriasNoSincronizadas.size} cambios pendientes)")
                return@withContext categoriaDao.getCategoriasByUser(userId).first()
            } else {
                // NO HAY CAMBIOS PENDIENTES ‚Üí Intentar Firebase
                Log.d(TAG, "‚òÅÔ∏è Intentando Firebase (sin cambios pendientes)")

                if (connectivityObserver.isConnected.first()) {
                    try {
                        val firebaseCategorias = descargarCategoriasDesdeFirebase(userId)
                        if (firebaseCategorias.isNotEmpty()) {
                            // Actualizar Room con datos frescos
                            firebaseCategorias.forEach { categoria ->
                                categoriaDao.insertOrUpdate(categoria.copy(sincronizadoFirebase = true))
                            }
                            Log.d(TAG, "‚úÖ Datos frescos de Firebase aplicados")
                        }
                    } catch (e: Exception) {
                        Log.w(TAG, "‚ö†Ô∏è Error con Firebase, usando Room como fallback", e)
                    }
                }

                // Devolver datos de Room (actualizados o fallback)
                return@withContext categoriaDao.getCategoriasByUser(userId).first()
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error en estrategia h√≠brida", e)
            // Fallback total a Room
            return@withContext categoriaDao.getCategoriasByUser(userId).first()
        }
    }

    // ========== SINCRONIZACI√ìN CON FIREBASE ==========

    /**
     * Sincroniza una categor√≠a espec√≠fica con Firebase
     */
    private suspend fun sincronizarCategoriaConFirebase(categoria: CategoriaEntity) {
        try {
            if (!connectivityObserver.isConnected.first()) {
                Log.d(TAG, "‚ö†Ô∏è Sin conexi√≥n, categr√≠a quedar√° pendiente de sincronizaci√≥n")
                return
            }

            val datos = mapOf(
                "idCategoria" to categoria.idCategoria,
                "userId" to categoria.userId,
                "nombre" to categoria.nombre,
                "colorHex" to categoria.colorHex,
                "orden" to categoria.orden,
                "activa" to categoria.activa,
                "version" to categoria.version,
                "lastModified" to categoria.lastModified,
                "fechaSync" to System.currentTimeMillis()
            )

            firestore.collection("categorias")
                .document(categoria.idCategoria)
                .set(datos)
                .await()

            // Marcar como sincronizada en Room
            categoriaDao.marcarComoSincronizada(categoria.idCategoria)
            Log.d(TAG, "‚òÅÔ∏è Categor√≠a sincronizada con Firebase: ${categoria.nombre}")

        } catch (e: Exception) {
            Log.w(TAG, "‚ö†Ô∏è Error sincronizando con Firebase: ${categoria.nombre}", e)
            // La categor√≠a queda marcada como no sincronizada para reintento posterior
        }
    }

    /**
     * Elimina categor√≠a de Firebase
     */
    private suspend fun eliminarCategoriaDeFirebase(categoriaId: String) {
        try {
            if (connectivityObserver.isConnected.first()) {
                firestore.collection("categorias")
                    .document(categoriaId)
                    .delete()
                    .await()
                Log.d(TAG, "‚òÅÔ∏è Categor√≠a eliminada de Firebase: $categoriaId")
            }
        } catch (e: Exception) {
            Log.w(TAG, "‚ö†Ô∏è Error eliminando de Firebase: $categoriaId", e)
        }
    }

    /**
     * Sincroniza categor√≠as no sincronizadas cuando hay conexi√≥n
     */
    private suspend fun sincronizarCategoriasNoSincronizadas(userId: String) {
        try {
            val pendientes = categoriaDao.getCategoriasNoSincronizadasByUser(userId)
            Log.d(TAG, "üîÑ Sincronizando ${pendientes.size} categor√≠as pendientes")

            pendientes.forEach { categoria ->
                sincronizarCategoriaConFirebase(categoria)
                delay(100) // Evitar saturar Firebase
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error sincronizando pendientes", e)
        }
    }

    /**
     * Descarga categor√≠as desde Firebase
     */
    private suspend fun descargarCategoriasDesdeFirebase(userId: String): List<CategoriaEntity> {
        return try {
            val snapshot = firestore.collection("categorias")
                .whereEqualTo("userId", userId)
                .whereEqualTo("activa", true)
                .get()
                .await()

            val categorias = snapshot.documents.mapNotNull { doc ->
                try {
                    val data = doc.data ?: return@mapNotNull null
                    CategoriaEntity(
                        idCategoria = data["idCategoria"] as? String ?: "",
                        userId = data["userId"] as? String ?: "",
                        nombre = data["nombre"] as? String ?: "",
                        colorHex = data["colorHex"] as? String ?: "#FFFFFF",
                        orden = (data["orden"] as? Long)?.toInt() ?: 0,
                        activa = data["activa"] as? Boolean ?: true,
                        version = data["version"] as? Long ?: 1L,
                        lastModified = data["lastModified"] as? Long ?: System.currentTimeMillis(),
                        sincronizadoFirebase = true
                    )
                } catch (e: Exception) {
                    Log.w(TAG, "‚ö†Ô∏è Error parseando categor√≠a de Firebase", e)
                    null
                }
            }

            Log.d(TAG, "‚òÅÔ∏è Descargadas ${categorias.size} categor√≠as de Firebase")
            categorias

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error descargando de Firebase", e)
            emptyList()
        }
    }

    // ========== UTILIDADES ==========

    /**
     * Verifica si existe una categor√≠a con el mismo nombre
     */
    suspend fun existeCategoriaConNombre(nombre: String, excludeId: String = ""): Boolean {
        val userId = ConfigurationManager.getCurrentUserId() ?: return false
        return categoriaDao.existeCategoriaConNombre(userId, nombre, excludeId)
    }

    /**
     * Fuerza sincronizaci√≥n completa
     */
    suspend fun forzarSincronizacion(): Boolean = withContext(Dispatchers.IO) {
        try {
            val userId = ConfigurationManager.getCurrentUserId() ?: return@withContext false

            sincronizarCategoriasNoSincronizadas(userId)
            getHybridCategorias(userId) // Esto descargar√° datos frescos de Firebase

            true
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error en sincronizaci√≥n forzada", e)
            false
        }
    }
}

// app/src/main/java/es/nuskysoftware/marketsales/data/repository/ConfiguracionRepository.kt
package es.nuskysoftware.marketsales.data.repository

import android.content.Context
import android.util.Log
import com.google.firebase.firestore.FirebaseFirestore
import es.nuskysoftware.marketsales.data.local.dao.ConfiguracionDao
import es.nuskysoftware.marketsales.data.local.database.AppDatabase
import es.nuskysoftware.marketsales.data.local.entity.ConfiguracionEntity
import es.nuskysoftware.marketsales.utils.ConnectivityObserver
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.tasks.await
import java.text.SimpleDateFormat
import java.util.*

/**
 * ConfiguracionRepository V10 - SIMPLIFICADO PARA SISTEMA MONOUSUARIO
 *
 * CAMBIOS V10:
 * - M√©todos actualizados para nueva estructura ConfiguracionEntity
 * - Agregados m√©todos para usuarioLogueado
 * - Sincronizaci√≥n con nuevos campos version/lastModified
 * - Eliminados m√©todos obsoletos (usuarioPassword, versionApp, etc.)
 */
class ConfiguracionRepository(
    context: Context
) {
    private val configuracionDao: ConfiguracionDao = AppDatabase.getDatabase(context).configuracionDao()
    private val firestore = FirebaseFirestore.getInstance()
    private val dateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())
    private val repositoryScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

    // Observador de red
    private val connectivityObserver = ConnectivityObserver(context)

    // Exponer configuraci√≥n como StateFlow
    val configuracion = configuracionDao.getConfiguracionFlow()
        .stateIn(repositoryScope, SharingStarted.WhileSubscribed(5_000), null)

    init {
        // Cuando volvemos a estar online, reintentamos enviar pendientes
        repositoryScope.launch {
            connectivityObserver.isConnected.collect { online ->
                if (online) {
                    val cfg = configuracionDao.getConfiguracionSync()
                    if (cfg?.pendienteSync == true) {
                        sincronizarConFirebase(cfg)
                    }
                }
            }
        }
    }

    // ========== M√âTODOS PRINCIPALES V10 ==========

    /**
     * Obtiene la configuraci√≥n actual
     */
    suspend fun getConfiguracion(): ConfiguracionEntity? = withContext(Dispatchers.IO) {
        configuracionDao.getConfiguracionSync()
    }

    /**
     * Crea configuraci√≥n por defecto si no existe
     */
    suspend fun crearConfiguracionPorDefecto() = withContext(Dispatchers.IO) {
        val existente = configuracionDao.getConfiguracion()
        if (existente == null) {
            val porDefecto = ConfiguracionEntity(
                usuarioLogueado = "usuario_default",
                ultimoDispositivo = android.os.Build.MODEL,
                fechaUltimaSync = dateFormat.format(Date())
            )
            configuracionDao.insertOrUpdate(porDefecto)
            sincronizarConFirebase(porDefecto)
        } else {
            if (existente.fechaUltimaSync == null || existente.pendienteSync) {
                sincronizarConFirebase(existente)
            }
        }
    }

    // ========== CONFIGURACI√ìN GLOBAL V10 ==========

    /**
     * Actualiza el idioma (com√∫n a todos los usuarios)
     */
    suspend fun updateIdioma(idioma: String) = withContext(Dispatchers.IO) {
        configuracionDao.updateIdioma(idioma)
        sincronizarCampoEspecifico("idioma", idioma)
    }

    /**
     * Actualiza el tema oscuro (com√∫n a todos los usuarios)
     */
    suspend fun updateTemaOscuro(esTemaOscuro: Boolean) = withContext(Dispatchers.IO) {
        configuracionDao.updateTemaOscuro(esTemaOscuro)
        sincronizarCampoEspecifico("temaOscuro", esTemaOscuro)
    }

    /**
     * Actualiza la fuente (com√∫n a todos los usuarios)
     */
    suspend fun updateFuente(fuente: String) = withContext(Dispatchers.IO) {
        configuracionDao.updateFuente(fuente)
        sincronizarCampoEspecifico("fuente", fuente)
    }

    /**
     * Actualiza la moneda (com√∫n a todos los usuarios)
     */
    suspend fun updateMoneda(moneda: String) = withContext(Dispatchers.IO) {
        configuracionDao.updateMoneda(moneda)
        sincronizarCampoEspecifico("moneda", moneda)
    }

    // ========== USUARIO LOGUEADO V10 ==========

    /**
     * Establece el usuario actualmente logueado
     */
    suspend fun setUsuarioLogueado(usuarioUid: String) = withContext(Dispatchers.IO) {
        configuracionDao.setUsuarioLogueado(usuarioUid)
        // No sincronizar este campo con Firebase (es solo local)
    }

    /**
     * Obtiene el usuario actualmente logueado
     */
    suspend fun getUsuarioLogueado(): String? = withContext(Dispatchers.IO) {
        configuracionDao.getUsuarioLogueado()
    }

    /**
     * Verifica si es usuario por defecto
     */
    suspend fun isUsuarioDefault(): Boolean = withContext(Dispatchers.IO) {
        configuracionDao.isUsuarioDefault()
    }

    // ========== SINCRONIZACI√ìN V10 ==========

    /**
     * Sincroniza la configuraci√≥n completa
     */
    suspend fun sincronizar() = withContext(Dispatchers.IO) {
        val cfg = configuracionDao.getConfiguracionSync() ?: return@withContext
        sincronizarConFirebase(cfg)
    }

    /**
     * Sincroniza la configuraci√≥n completa con Firebase
     */
    private fun sincronizarConFirebase(config: ConfiguracionEntity) {
        try {
            val datos = mapOf(
                "idioma" to config.idioma,
                "temaOscuro" to config.temaOscuro,
                "fuente" to config.fuente,
                "moneda" to config.moneda,
                "numeroVersion" to config.numeroVersion,
                "ultimoDispositivo" to config.ultimoDispositivo,
                "fechaUltimaSync" to dateFormat.format(Date()),
                "version" to config.version,
                "lastModified" to System.currentTimeMillis(),
                "dispositivo" to android.os.Build.MODEL
            )

            // Usar "usuario_default" como documento para configuraci√≥n global
            val docRef = firestore.collection("configuraciones")
                .document("configuracion_global")

            docRef.set(datos)
                .addOnSuccessListener {
                    repositoryScope.launch {
                        configuracionDao.updateFechaUltimaSync(dateFormat.format(Date()))
                        configuracionDao.updatePendienteSync(false)
                    }
                }
                .addOnFailureListener {
                    repositoryScope.launch {
                        configuracionDao.updatePendienteSync(true)
                    }
                }
        } catch (e: Exception) {
            repositoryScope.launch {
                configuracionDao.updatePendienteSync(true)
            }
        }
    }

    /**
     * Sincroniza un campo espec√≠fico con Firebase
     */
    private suspend fun sincronizarCampoEspecifico(campo: String, valor: Any) {
        try {
            val datos = mapOf(
                campo to valor,
                "fechaUltimaSync" to dateFormat.format(Date()),
                "lastModified" to System.currentTimeMillis()
            )

            firestore.collection("configuraciones")
                .document("configuracion_global")
                .update(datos)
                .addOnSuccessListener {
                    repositoryScope.launch {
                        configuracionDao.updateFechaUltimaSync(dateFormat.format(Date()))
                        configuracionDao.updatePendienteSync(false)
                    }
                }
                .addOnFailureListener {
                    repositoryScope.launch {
                        configuracionDao.updatePendienteSync(true)
                    }
                }
        } catch (e: Exception) {
            repositoryScope.launch {
                configuracionDao.updatePendienteSync(true)
            }
        }
    }
    suspend fun getHybridConfiguracion(): ConfiguracionEntity? = withContext(Dispatchers.IO) {
        try {
            // 1. Verificar si hay cambios pendientes en Room
            val roomConfig = configuracionDao.getConfiguracionSync()
            val hasPendingChanges = roomConfig?.pendienteSync == true

            if (hasPendingChanges) {
                // ‚úÖ HAY CAMBIOS PENDIENTES ‚Üí Leer de Room (fuente de verdad)
                Log.d("ConfiguracionRepository", "üì± Leyendo configuraci√≥n de ROOM (cambios pendientes)")
                return@withContext roomConfig
            } else {
                // ‚úÖ NO HAY CAMBIOS PENDIENTES ‚Üí Leer de Firebase (m√°s actualizado)
                Log.d("ConfiguracionRepository", "‚òÅÔ∏è Leyendo configuraci√≥n de FIREBASE (sin cambios pendientes)")

                if (connectivityObserver.isConnected.first()) {
                    try {
                        val firebaseDoc = firestore.collection("configuraciones")
                            .document("configuracion_global")
                            .get()
                            .await()

                        if (firebaseDoc.exists()) {
                            val firebaseData = firebaseDoc.data!!

                            // Crear entidad h√≠brida: Firebase + datos locales importantes
                            val hybridConfig = roomConfig?.copy(
                                // Datos de Firebase (comunes)
                                moneda = firebaseData["moneda"] as? String ?: roomConfig.moneda,
                                idioma = firebaseData["idioma"] as? String ?: roomConfig.idioma,
                                fuente = firebaseData["fuente"] as? String ?: roomConfig.fuente,
                                temaOscuro = firebaseData["temaOscuro"] as? Boolean ?: roomConfig.temaOscuro,

                                // Datos locales (espec√≠ficos del dispositivo)
                                usuarioLogueado = roomConfig.usuarioLogueado, // Mantener local
                                pendienteSync = false // Marcar como sincronizado
                            ) ?: ConfiguracionEntity(
                                moneda = firebaseData["moneda"] as? String ?: "‚Ç¨ Euro",
                                idioma = firebaseData["idioma"] as? String ?: "es",
                                fuente = firebaseData["fuente"] as? String ?: "Montserrat",
                                temaOscuro = firebaseData["temaOscuro"] as? Boolean ?: false
                            )

                            // Actualizar Room con datos frescos
                            configuracionDao.insertOrUpdate(hybridConfig)

                            Log.d("ConfiguracionRepository", "‚úÖ Configuraci√≥n fresca de Firebase aplicada")
                            return@withContext hybridConfig
                        }
                    } catch (e: Exception) {
                        Log.w("ConfiguracionRepository", "‚ùå Error leyendo Firebase, usando Room", e)
                    }
                }

                // Fallback: usar Room
                return@withContext roomConfig ?: ConfiguracionEntity()
            }

        } catch (e: Exception) {
            Log.e("ConfiguracionRepository", "Error en estrategia h√≠brida", e)
            // En caso de error, devolver lo que tengamos en Room o crear configuraci√≥n por defecto
            val fallbackConfig = configuracionDao.getConfiguracionSync()
            return@withContext fallbackConfig ?: ConfiguracionEntity()
        }
    }
    // ========== M√âTODOS OBSOLETOS V10 (compatibilidad) ==========

    @Deprecated("Usar updateIdioma()", ReplaceWith("updateIdioma(idioma)"))
    suspend fun actualizarIdioma(idioma: String) = updateIdioma(idioma)

    @Deprecated("Usar updateTemaOscuro()", ReplaceWith("updateTemaOscuro(esTemaOscuro)"))
    suspend fun actualizarTema(esTemaOscuro: Boolean) = updateTemaOscuro(esTemaOscuro)

    @Deprecated("Usar updateFuente()", ReplaceWith("updateFuente(fuente)"))
    suspend fun actualizarFuente(fuente: String) = updateFuente(fuente)

    @Deprecated("Usar updateMoneda()", ReplaceWith("updateMoneda(moneda)"))
    suspend fun actualizarMoneda(moneda: String) = updateMoneda(moneda)

    @Deprecated("Campo eliminado en V10 - usar UserRepository", ReplaceWith("UserRepository.updateUserPassword()"))
    suspend fun actualizarPassword(password: String) {
        // No-op en V10
    }

    @Deprecated("Campo eliminado en V10 - usar UserRepository", ReplaceWith("UserRepository.updateUserPremium()"))
    suspend fun actualizarVersionApp(version: Int) {
        // No-op en V10
    }

    @Deprecated("Campo eliminado en V10 - usar UserRepository", ReplaceWith("UserRepository.updateUserEmail()"))
    suspend fun actualizarUsuarioEmail(email: String) {
        // No-op en V10
    }
}

// app/src/main/java/es/nuskysoftware/marketsales/data/repository/MercadilloRepository.kt
package es.nuskysoftware.marketsales.data.repository

import android.content.Context
import android.util.Log
import com.google.firebase.firestore.FirebaseFirestore
import es.nuskysoftware.marketsales.data.local.dao.MercadilloDao
import es.nuskysoftware.marketsales.data.local.dao.EstadisticaEstado
import es.nuskysoftware.marketsales.data.local.database.AppDatabase
import es.nuskysoftware.marketsales.data.local.entity.MercadilloEntity
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.ConnectivityObserver
import es.nuskysoftware.marketsales.utils.EstadosMercadillo
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.flatMapLatest
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.tasks.await
import java.text.SimpleDateFormat
import java.util.*

/**
 * MercadilloRepository V11 - Market Sales
 *
 * ARQUITECTURA H√çBRIDA "RELOJ SUIZO":
 * - Local First: Toda operaci√≥n se ejecuta primero en Room
 * - Sync When Possible: Sincronizaci√≥n autom√°tica cuando hay conexi√≥n
 * - Never Block UI: La interfaz nunca espera operaciones de red
 * - Graceful Degradation: Funcionamiento completo offline
 * - Estados autom√°ticos: Actualizaci√≥n autom√°tica de estados seg√∫n l√≥gica de negocio
 * - Filtrado por usuario: Cada usuario solo ve sus datos
 */
class MercadilloRepository(
    context: Context
) {
    private val mercadilloDao: MercadilloDao = AppDatabase.getDatabase(context).mercadilloDao()
    private val firestore = FirebaseFirestore.getInstance()
    private val connectivityObserver = ConnectivityObserver(context)
    private val repositoryScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

    // Formateadores de fecha
    private val dateFormat = SimpleDateFormat("dd-MM-yyyy", Locale.getDefault())
    private val timeFormat = SimpleDateFormat("HH:mm", Locale.getDefault())

    companion object {
        private const val TAG = "MercadilloRepository"
    }

    init {
        // Sincronizaci√≥n autom√°tica cuando volvemos online
        repositoryScope.launch {
            connectivityObserver.isConnected.collect { online ->
                if (online) {
                    val userId = ConfigurationManager.getCurrentUserId()
                    if (userId != null) {
                        sincronizarMercadillosNoSincronizados(userId)
                        actualizarEstadosAutomaticos(userId)
                    }
                }
            }
        }

        // Actualizaci√≥n peri√≥dica de estados (cada 5 minutos)
        repositoryScope.launch {
            while (true) {
                delay(5 * 60 * 1000) // 5 minutos
                val userId = ConfigurationManager.getCurrentUserId()
                if (userId != null) {
                    actualizarEstadosAutomaticos(userId)
                }
            }
        }
    }

    /**
     * Obtiene el pr√≥ximo mercadillo para un usuario espec√≠fico
     */
    suspend fun getProximoMercadilloPorUsuario(userId: String, fechaActual: String): MercadilloEntity? = withContext(Dispatchers.IO) {
        Log.d(TAG, "üîç Buscando pr√≥ximo mercadillo para usuario: $userId en fecha: $fechaActual")
        return@withContext mercadilloDao.getProximoMercadillo(userId, fechaActual)
    }

    /**
     * Obtiene todos los mercadillos del usuario actual - VERSION REACTIVA
     */
    fun getMercadillosUsuarioActual(): Flow<List<MercadilloEntity>> {
        return ConfigurationManager.usuarioLogueado.flatMapLatest { userId ->
            val effectiveUserId = when {
                userId == null || userId == "usuario_default" -> "usuario_default"
                else -> userId
            }
            Log.d(TAG, "üîÑ Usuario cambi√≥ a: $effectiveUserId - Recargando mercadillos")
            mercadilloDao.getMercadillosByUser(effectiveUserId)
        }
    }

    /**
     * Obtiene mercadillos de un mes espec√≠fico - VERSION REACTIVA
     */
    fun getMercadillosPorMes(ano: Int, mes: Int): Flow<List<MercadilloEntity>> {
        return ConfigurationManager.usuarioLogueado.flatMapLatest { userId ->
            val effectiveUserId = when {
                userId == null || userId == "usuario_default" -> "usuario_default"
                else -> userId
            }
            Log.d(TAG, "üîÑ Mercadillos mes $mes/$ano para usuario: $effectiveUserId")
            val mesPattern = "${String.format("%02d", mes)}-$ano"
            mercadilloDao.getMercadillosByUserAndMes(effectiveUserId, "%$mesPattern")
        }
    }

    /**
     * Crea un nuevo mercadillo - PATR√ìN H√çBRIDO
     */
    suspend fun crearMercadillo(
        fecha: String,
        lugar: String,
        organizador: String,
        esGratis: Boolean = true,
        importeSuscripcion: Double = 0.0,
        requiereMesa: Boolean = true,
        requiereCarpa: Boolean = true,
        hayPuntoLuz: Boolean = false,
        horaInicio: String = "09:00",
        horaFin: String = "14:00",
        saldoInicial: Double? = null // ‚úÖ NUEVO PAR√ÅMETRO OPCIONAL
    ): String = withContext(Dispatchers.IO) {
        val userId = ConfigurationManager.getCurrentUserId()
            ?: throw IllegalStateException("No se puede crear mercadillo sin usuario")

        Log.d(TAG, "üîÑ Creando mercadillo para usuario: $userId")

        // Validar conflictos de fecha/hora
        if (mercadilloDao.existeMercadilloEnFechaHora(userId, fecha, horaInicio)) {
            throw IllegalArgumentException("Ya existe un mercadillo en esa fecha y hora")
        }

        val nuevoMercadillo = MercadilloEntity(
            userId = userId,
            fecha = fecha,
            lugar = lugar,
            organizador = organizador,
            esGratis = esGratis,
            importeSuscripcion = if (!esGratis) importeSuscripcion else 0.0,
            requiereMesa = requiereMesa,
            requiereCarpa = requiereCarpa,
            hayPuntoLuz = hayPuntoLuz,
            horaInicio = horaInicio,
            horaFin = horaFin,
            saldoInicial = saldoInicial, // ‚úÖ ASIGNAR SALDO INICIAL
            estado = if (saldoInicial != null) {
                EstadosMercadillo.Estado.PROGRAMADO_TOTAL.codigo // Con saldo = TOTAL
            } else {
                EstadosMercadillo.Estado.PROGRAMADO_PARCIAL.codigo // Sin saldo = PARCIAL
            },
            sincronizadoFirebase = false
        )

        try {
            // 1. GUARDAR EN ROOM PRIMERO (respuesta inmediata)
            mercadilloDao.insertMercadillo(nuevoMercadillo)
            Log.d(TAG, "‚úÖ Mercadillo guardado en Room: $lugar - $fecha${if (saldoInicial != null) " (Saldo: ‚Ç¨$saldoInicial)" else ""}")

            // 2. INTENTAR SINCRONIZAR CON FIREBASE
            sincronizarMercadilloConFirebase(nuevoMercadillo)

            return@withContext nuevoMercadillo.idMercadillo

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error creando mercadillo", e)
            throw e
        }
    }

    /**
     * Actualiza un mercadillo existente - PATR√ìN H√çBRIDO
     */
    suspend fun actualizarMercadillo(mercadillo: MercadilloEntity): Boolean = withContext(Dispatchers.IO) {
        try {
            val mercadilloActualizado = mercadillo.copy(
                version = mercadillo.version + 1,
                lastModified = System.currentTimeMillis(),
                sincronizadoFirebase = false
            )

            // 1. ACTUALIZAR EN ROOM PRIMERO
            mercadilloDao.updateMercadillo(mercadilloActualizado)
            Log.d(TAG, "‚úÖ Mercadillo actualizado en Room: ${mercadilloActualizado.lugar}")

            // 2. INTENTAR SINCRONIZAR CON FIREBASE
            sincronizarMercadilloConFirebase(mercadilloActualizado)

            true
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error actualizando mercadillo", e)
            false
        }
    }

    /**
     * Elimina un mercadillo - PATR√ìN H√çBRIDO
     */
    suspend fun eliminarMercadillo(mercadillo: MercadilloEntity): Boolean = withContext(Dispatchers.IO) {
        try {
            // 1. ELIMINAR DE ROOM PRIMERO
            mercadilloDao.deleteMercadillo(mercadillo)
            Log.d(TAG, "‚úÖ Mercadillo eliminado de Room: ${mercadillo.lugar}")

            // 2. INTENTAR ELIMINAR DE FIREBASE
            eliminarMercadilloDeFirebase(mercadillo.idMercadillo)

            true
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error eliminando mercadillo", e)
            false
        }
    }

    /**
     * Obtiene mercadillo por ID
     */
    suspend fun getMercadilloById(id: String): MercadilloEntity? = withContext(Dispatchers.IO) {
        mercadilloDao.getMercadilloById(id)
    }

    // ========== GESTI√ìN DE SALDOS ==========

    /**
     * Asigna saldo inicial a un mercadillo (manual o autom√°tico)
     */
    suspend fun asignarSaldoInicial(
        mercadilloId: String,
        saldoInicial: Double,
        esAsignacionAutomatica: Boolean = false
    ): Boolean = withContext(Dispatchers.IO) {
        try {
            mercadilloDao.asignarSaldoInicial(mercadilloId, saldoInicial)

            if (esAsignacionAutomatica) {
                Log.d(TAG, "‚úÖ Saldo inicial asignado autom√°ticamente: ‚Ç¨$saldoInicial")
            } else {
                Log.d(TAG, "‚úÖ Saldo inicial asignado manualmente: ‚Ç¨$saldoInicial")
            }

            // Sincronizar cambio
            val mercadilloActualizado = mercadilloDao.getMercadilloById(mercadilloId)
            mercadilloActualizado?.let { sincronizarMercadilloConFirebase(it) }

            true
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error asignando saldo inicial", e)
            false
        }
    }

    /**
     * Asigna autom√°ticamente saldo inicial desde el √∫ltimo mercadillo cerrado
     */
    suspend fun asignarSaldoInicialAutomatico(mercadilloId: String): Boolean = withContext(Dispatchers.IO) {
        try {
            val userId = ConfigurationManager.getCurrentUserId() ?: return@withContext false

            val ultimoMercadilloConSaldo = mercadilloDao.getUltimoMercadilloConSaldoFinal(userId)

            if (ultimoMercadilloConSaldo?.saldoFinal != null) {
                val exito = asignarSaldoInicial(
                    mercadilloId = mercadilloId,
                    saldoInicial = ultimoMercadilloConSaldo.saldoFinal,
                    esAsignacionAutomatica = true
                )

                if (exito) {
                    // Marcar el saldo del mercadillo anterior como asignado
                    mercadilloDao.marcarSaldoAsignado(ultimoMercadilloConSaldo.idMercadillo)
                }

                return@withContext exito
            } else {
                Log.d(TAG, "No hay mercadillos anteriores con saldo final para asignar")
                return@withContext false
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error en asignaci√≥n autom√°tica de saldo", e)
            false
        }
    }

    /**
     * Realiza el arqueo de caja de un mercadillo
     */
    suspend fun realizarArqueoCaja(
        mercadilloId: String,
        saldoFinal: Double,
        ventasEfectivo: Double,
        gastosEfectivo: Double
    ): Boolean = withContext(Dispatchers.IO) {
        try {
            val mercadillo = mercadilloDao.getMercadilloById(mercadilloId) ?: return@withContext false
            val saldoInicial = mercadillo.saldoInicial ?: return@withContext false

            val arqueoCaja = saldoInicial + ventasEfectivo - gastosEfectivo

            mercadilloDao.realizarArqueoCaja(mercadilloId, arqueoCaja, saldoFinal)

            Log.d(TAG, "‚úÖ Arqueo de caja realizado: ‚Ç¨$arqueoCaja")

            // Sincronizar cambio
            val mercadilloActualizado = mercadilloDao.getMercadilloById(mercadilloId)
            mercadilloActualizado?.let { sincronizarMercadilloConFirebase(it) }

            true
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error realizando arqueo de caja", e)
            false
        }
    }

    // ========== GESTI√ìN DE ESTADOS AUTOM√ÅTICA ==========

    /**
     * Actualiza autom√°ticamente los estados de todos los mercadillos del usuario
     */
    suspend fun actualizarEstadosAutomaticos(userId: String) {
        try {
            val mercadillos = mercadilloDao.getMercadillosByUser(userId).first()
            val fechaActual = dateFormat.format(Date())
            val horaActual = timeFormat.format(Date())

            Log.d(TAG, "üîÑ Actualizando estados autom√°ticos para ${mercadillos.size} mercadillos")

            mercadillos.forEach { mercadillo ->
                if (mercadillo.estado != EstadosMercadillo.Estado.CANCELADO.codigo) {
                    val estadoCalculado = EstadosMercadillo.calcularEstadoAutomatico(
                        saldoInicial = mercadillo.saldoInicial,
                        fecha = mercadillo.fecha,
                        horaFin = mercadillo.horaFin,
                        arqueoCaja = mercadillo.arqueoCaja,
                        pendienteAsignarSaldo = mercadillo.pendienteAsignarSaldo,
                        fechaActual = fechaActual,
                        horaActual = horaActual
                    )

                    if (estadoCalculado.codigo != mercadillo.estado) {
                        mercadilloDao.actualizarEstado(mercadillo.idMercadillo, estadoCalculado.codigo)
                        Log.d(TAG, "Estado actualizado: ${mercadillo.lugar} -> ${estadoCalculado.descripcion}")

                        // Marcar para sincronizaci√≥n
                        val mercadilloActualizado = mercadilloDao.getMercadilloById(mercadillo.idMercadillo)
                        mercadilloActualizado?.let { sincronizarMercadilloConFirebase(it) }
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error actualizando estados autom√°ticos", e)
        }
    }

    /**
     * Cancela un mercadillo (solo si no tiene ventas)
     */
    suspend fun cancelarMercadillo(
        mercadilloId: String,
        tieneVentas: Boolean = false
    ): Boolean = withContext(Dispatchers.IO) {
        try {
            val mercadillo = mercadilloDao.getMercadilloById(mercadilloId) ?: return@withContext false
            val estado = EstadosMercadillo.Estado.fromCodigo(mercadillo.estado) ?: return@withContext false

            if (!EstadosMercadillo.puedeSerCancelado(estado, tieneVentas)) {
                Log.w(TAG, "No se puede cancelar el mercadillo: tiene ventas o estado no v√°lido")
                return@withContext false
            }

            // Si tiene saldo inicial, se deber√≠a reasignar a otro mercadillo
            // (esta l√≥gica se implementar√≠a en el ViewModel/UI)

            mercadilloDao.cancelarMercadillo(mercadilloId)
            Log.d(TAG, "‚úÖ Mercadillo cancelado: ${mercadillo.lugar}")

            // Sincronizar cambio
            val mercadilloActualizado = mercadilloDao.getMercadilloById(mercadilloId)
            mercadilloActualizado?.let { sincronizarMercadilloConFirebase(it) }

            true
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error cancelando mercadillo", e)
            false
        }
    }

    // ========== CONSULTAS ESPEC√çFICAS ==========

    /**
     * Obtiene el pr√≥ximo mercadillo - VERSION REACTIVA
     */
    suspend fun getProximoMercadillo(): MercadilloEntity? = withContext(Dispatchers.IO) {
        val userId = ConfigurationManager.getCurrentUserId() ?: "usuario_default"
        Log.d(TAG, "üîÑ Obteniendo pr√≥ximo mercadillo para usuario: $userId")
        val fechaActual = dateFormat.format(Date())
        mercadilloDao.getProximoMercadillo(userId, fechaActual)
    }

    /**
     * Obtiene mercadillos que requieren atenci√≥n - VERSION REACTIVA
     */
    fun getMercadillosRequierenAtencion(): Flow<List<MercadilloEntity>> {
        return ConfigurationManager.usuarioLogueado.flatMapLatest { userId ->
            Log.d(TAG, "üîÑ Usuario cambi√≥: $userId - Recargando mercadillos que requieren atenci√≥n")
            if (userId != null && userId != "usuario_default") {
                mercadilloDao.getMercadillosPendientesArqueo(userId)
            } else {
                flowOf(emptyList())
            }
        }
    }

    /**
     * Obtiene todos los mercadillos desde hoy en adelante para un usuario
     */
    suspend fun getMercadillosDesdeHoy(userId: String): List<MercadilloEntity> = withContext(Dispatchers.IO) {
        try {
            // Obtener fecha actual en formato dd-MM-yyyy
            val fechaActual = dateFormat.format(Date())

            // Usar la nueva consulta del DAO
            val mercadillos = mercadilloDao.getMercadillosDesdeHoy(userId, fechaActual)

            Log.d(TAG, "üìÖ Encontrados ${mercadillos.size} mercadillos desde $fechaActual para usuario $userId")

            return@withContext mercadillos

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error obteniendo mercadillos desde hoy", e)
            return@withContext emptyList()
        }
    }

    /**
     * Obtiene estad√≠sticas de mercadillos por estado
     */
    suspend fun getEstadisticasPorEstado(): Map<EstadosMercadillo.Estado, Int> = withContext(Dispatchers.IO) {
        val userId = ConfigurationManager.getCurrentUserId() ?: return@withContext emptyMap()

        try {
            val estadisticas = mercadilloDao.getEstadisticasPorEstado(userId)
            return@withContext estadisticas.associate { estadisticaEstado ->
                val estado = EstadosMercadillo.Estado.fromCodigo(estadisticaEstado.estado)
                    ?: EstadosMercadillo.Estado.PROGRAMADO_PARCIAL
                estado to estadisticaEstado.cantidad
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error obteniendo estad√≠sticas", e)
            return@withContext emptyMap()
        }
    }


    // ========== ESTRATEGIA H√çBRIDA INTELIGENTE ==========

    /**
     * Obtiene datos h√≠bridos: combina lo mejor de Room y Firebase
     */
    suspend fun getHybridMercadillos(userId: String): List<MercadilloEntity> = withContext(Dispatchers.IO) {
        try {
            // 1. Verificar cambios pendientes en Room
            val mercadillosNoSincronizados = mercadilloDao.getMercadillosNoSincronizadosByUser(userId)

            if (mercadillosNoSincronizados.isNotEmpty()) {
                // HAY CAMBIOS PENDIENTES ‚Üí Room es fuente de verdad
                Log.d(TAG, "üì± Usando Room (${mercadillosNoSincronizados.size} cambios pendientes)")
                return@withContext mercadilloDao.getMercadillosByUser(userId).first()
            } else {
                // NO HAY CAMBIOS PENDIENTES ‚Üí Intentar Firebase
                Log.d(TAG, "‚òÅÔ∏è Intentando Firebase (sin cambios pendientes)")

                if (connectivityObserver.isConnected.first()) {
                    try {
                        val firebaseMercadillos = descargarMercadillosDesdeFirebase(userId)
                        if (firebaseMercadillos.isNotEmpty()) {
                            // Actualizar Room con datos frescos
                            firebaseMercadillos.forEach { mercadillo ->
                                mercadilloDao.insertOrUpdate(mercadillo.copy(sincronizadoFirebase = true))
                            }
                            Log.d(TAG, "‚úÖ Datos frescos de Firebase aplicados")
                        }
                    } catch (e: Exception) {
                        Log.w(TAG, "‚ö†Ô∏è Error con Firebase, usando Room como fallback", e)
                    }
                }

                // Devolver datos de Room (actualizados o fallback)
                return@withContext mercadilloDao.getMercadillosByUser(userId).first()
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error en estrategia h√≠brida", e)
            // Fallback total a Room
            return@withContext mercadilloDao.getMercadillosByUser(userId).first()
        }
    }

    // ========== SINCRONIZACI√ìN CON FIREBASE ==========

    /**
     * Sincroniza un mercadillo espec√≠fico con Firebase
     */
    private suspend fun sincronizarMercadilloConFirebase(mercadillo: MercadilloEntity) {
        try {
            if (!connectivityObserver.isConnected.first()) {
                Log.d(TAG, "‚ö†Ô∏è Sin conexi√≥n, mercadillo quedar√° pendiente de sincronizaci√≥n")
                return
            }

            val datos = mapOf(
                "idMercadillo" to mercadillo.idMercadillo,
                "userId" to mercadillo.userId,
                "fecha" to mercadillo.fecha,
                "lugar" to mercadillo.lugar,
                "organizador" to mercadillo.organizador,
                "esGratis" to mercadillo.esGratis,
                "importeSuscripcion" to mercadillo.importeSuscripcion,
                "requiereMesa" to mercadillo.requiereMesa,
                "requiereCarpa" to mercadillo.requiereCarpa,
                "hayPuntoLuz" to mercadillo.hayPuntoLuz,
                "horaInicio" to mercadillo.horaInicio,
                "horaFin" to mercadillo.horaFin,
                "estado" to mercadillo.estado,
                "pendienteArqueo" to mercadillo.pendienteArqueo,
                "pendienteAsignarSaldo" to mercadillo.pendienteAsignarSaldo,
                "saldoInicial" to mercadillo.saldoInicial,
                "saldoFinal" to mercadillo.saldoFinal,
                "arqueoCaja" to mercadillo.arqueoCaja,
                "totalVentas" to mercadillo.totalVentas,
                "totalGastos" to mercadillo.totalGastos,
                "arqueoMercadillo" to mercadillo.arqueoMercadillo,
                "activo" to mercadillo.activo,
                "version" to mercadillo.version,
                "lastModified" to mercadillo.lastModified,
                "fechaSync" to System.currentTimeMillis()
            )

            firestore.collection("mercadillos")
                .document(mercadillo.idMercadillo)
                .set(datos)
                .await()

            // Marcar como sincronizado en Room
            mercadilloDao.marcarComoSincronizado(mercadillo.idMercadillo)
            Log.d(TAG, "‚òÅÔ∏è Mercadillo sincronizado con Firebase: ${mercadillo.lugar}")

        } catch (e: Exception) {
            Log.w(TAG, "‚ö†Ô∏è Error sincronizando con Firebase: ${mercadillo.lugar}", e)
            // El mercadillo queda marcado como no sincronizado para reintento posterior
        }
    }

    /**
     * Elimina mercadillo de Firebase
     */
    private suspend fun eliminarMercadilloDeFirebase(mercadilloId: String) {
        try {
            if (connectivityObserver.isConnected.first()) {
                firestore.collection("mercadillos")
                    .document(mercadilloId)
                    .delete()
                    .await()
                Log.d(TAG, "‚òÅÔ∏è Mercadillo eliminado de Firebase: $mercadilloId")
            }
        } catch (e: Exception) {
            Log.w(TAG, "‚ö†Ô∏è Error eliminando de Firebase: $mercadilloId", e)
        }
    }

    /**
     * Sincroniza mercadillos no sincronizados cuando hay conexi√≥n
     */
    private suspend fun sincronizarMercadillosNoSincronizados(userId: String) {
        try {
            val pendientes = mercadilloDao.getMercadillosNoSincronizadosByUser(userId)
            Log.d(TAG, "üîÑ Sincronizando ${pendientes.size} mercadillos pendientes")

            pendientes.forEach { mercadillo ->
                sincronizarMercadilloConFirebase(mercadillo)
                delay(100) // Evitar saturar Firebase
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error sincronizando pendientes", e)
        }
    }

    /**
     * Descarga mercadillos desde Firebase
     */
    private suspend fun descargarMercadillosDesdeFirebase(userId: String): List<MercadilloEntity> {
        return try {
            val snapshot = firestore.collection("mercadillos")
                .whereEqualTo("userId", userId)
                .whereEqualTo("activo", true)
                .get()
                .await()

            val mercadillos = snapshot.documents.mapNotNull { doc ->
                try {
                    val data = doc.data ?: return@mapNotNull null
                    MercadilloEntity(
                        idMercadillo = data["idMercadillo"] as? String ?: "",
                        userId = data["userId"] as? String ?: "",
                        fecha = data["fecha"] as? String ?: "",
                        lugar = data["lugar"] as? String ?: "",
                        organizador = data["organizador"] as? String ?: "",
                        esGratis = data["esGratis"] as? Boolean ?: true,
                        importeSuscripcion = (data["importeSuscripcion"] as? Number)?.toDouble() ?: 0.0,
                        requiereMesa = data["requiereMesa"] as? Boolean ?: true,
                        requiereCarpa = data["requiereCarpa"] as? Boolean ?: true,
                        hayPuntoLuz = data["hayPuntoLuz"] as? Boolean ?: false,
                        horaInicio = data["horaInicio"] as? String ?: "09:00",
                        horaFin = data["horaFin"] as? String ?: "14:00",
                        estado = (data["estado"] as? Long)?.toInt() ?: 1,
                        pendienteArqueo = data["pendienteArqueo"] as? Boolean ?: false,
                        pendienteAsignarSaldo = data["pendienteAsignarSaldo"] as? Boolean ?: false,
                        saldoInicial = (data["saldoInicial"] as? Number)?.toDouble(),
                        saldoFinal = (data["saldoFinal"] as? Number)?.toDouble(),
                        arqueoCaja = (data["arqueoCaja"] as? Number)?.toDouble(),
                        totalVentas = (data["totalVentas"] as? Number)?.toDouble() ?: 0.0,
                        totalGastos = (data["totalGastos"] as? Number)?.toDouble() ?: 0.0,
                        arqueoMercadillo = (data["arqueoMercadillo"] as? Number)?.toDouble(),
                        activo = data["activo"] as? Boolean ?: true,
                        version = data["version"] as? Long ?: 1L,
                        lastModified = data["lastModified"] as? Long ?: System.currentTimeMillis(),
                        sincronizadoFirebase = true
                    )
                } catch (e: Exception) {
                    Log.w(TAG, "‚ö†Ô∏è Error parseando mercadillo de Firebase", e)
                    null
                }
            }

            Log.d(TAG, "‚òÅÔ∏è Descargados ${mercadillos.size} mercadillos de Firebase")
            mercadillos

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error descargando de Firebase", e)
            emptyList()
        }
    }

    // ========== SINCRONIZACI√ìN SIN ESTADOS AUTOM√ÅTICOS ==========

    /**
     * Sincroniza SIN recalcular estados autom√°ticos
     */
    suspend fun sincronizarSinEstadosAutomaticos(): Boolean = withContext(Dispatchers.IO) {
        try {
            val userId = ConfigurationManager.getCurrentUserId() ?: return@withContext false

            // 1. Sincronizar pendientes
            sincronizarMercadillosNoSincronizados(userId)

            // 2. Descargar datos frescos de Firebase
            getHybridMercadillos(userId)

            // 3. NO llamar a actualizarEstadosAutomaticos(userId)

            Log.d(TAG, "‚úÖ Sincronizaci√≥n completada SIN estados autom√°ticos")
            true
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error en sincronizaci√≥n sin estados autom√°ticos", e)
            false
        }
    }

    // ========== UTILIDADES ==========

    /**
     * Fuerza sincronizaci√≥n completa
     */
    suspend fun forzarSincronizacion(): Boolean = withContext(Dispatchers.IO) {
        try {
            val userId = ConfigurationManager.getCurrentUserId() ?: return@withContext false

            sincronizarMercadillosNoSincronizados(userId)
            getHybridMercadillos(userId) // Esto descargar√° datos frescos de Firebase
            actualizarEstadosAutomaticos(userId) // Actualizar estados tras sincronizaci√≥n

            true
        } catch (e: Exception) {
            false
        }
    }

    // Agregar en MercadilloRepository.kt:

    /**
     * Obtiene mercadillos de una fecha espec√≠fica para validaciones
     */
    suspend fun getMercadillosPorFecha(userId: String, fecha: String): List<MercadilloEntity> = withContext(Dispatchers.IO) {
        return@withContext mercadilloDao.getMercadillosByUserAndFecha(userId, fecha)
    }
}

// app/src/main/java/es/nuskysoftware/marketsales/data/repository/UserRepository.kt
package es.nuskysoftware.marketsales.data.repository

import android.content.ContentValues.TAG
import android.content.Context
import android.util.Log
import com.google.firebase.firestore.FirebaseFirestore
import es.nuskysoftware.marketsales.data.local.dao.UserDao
import es.nuskysoftware.marketsales.data.local.database.AppDatabase
import es.nuskysoftware.marketsales.data.local.entity.UserEntity
import es.nuskysoftware.marketsales.utils.ConnectivityObserver
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.tasks.await
import java.text.SimpleDateFormat
import java.util.*

/**
 * UserRepository V10 - SIMPLIFICADO PARA SISTEMA MONOUSUARIO
 *
 * CAMBIOS V10:
 * - Eliminado sistema multiusuario (empresas, invitaciones, roles)
 * - Eliminado configuraci√≥n personal (ahora es global)
 * - Solo gestiona: datos b√°sicos + esPremium + sincronizaci√≥n
 * - Agregado getOrCreateUser() para AuthRepository
 */
class UserRepository(
    context: Context
) {
    private val userDao: UserDao = AppDatabase.getDatabase(context).userDao()
    private val firestore = FirebaseFirestore.getInstance()
    private val dateFormat = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())
    private val repositoryScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

    // Observador de red
    private val connectivityObserver = ConnectivityObserver(context)

    // Exponer usuario actual como StateFlow
    val currentUser = userDao.getCurrentUserFlow()
        .stateIn(repositoryScope, SharingStarted.WhileSubscribed(5_000), null)

    init {
        // Cuando volvemos online, sincronizamos usuarios pendientes
        repositoryScope.launch {
            connectivityObserver.isConnected.collect { online ->
                if (online) {
                    val pendingUsers = userDao.getUsersPendingSync()
                    pendingUsers.forEach { user ->
                        sincronizarUsuarioConFirebase(user)
                    }
                }
            }
        }
    }

    // ========== M√âTODOS PRINCIPALES V10 ==========

    /**
     * ‚úÖ NUEVO: Busca usuario existente o crea uno nuevo (para AuthRepository)
     */
    suspend fun getOrCreateUser(
        uid: String,
        email: String,
        displayName: String = "",
        photoUrl: String = "",
        esPremium: Boolean = false
    ): UserEntity = withContext(Dispatchers.IO) {
        try {
            // 1. Buscar usuario existente en Room
            val existingUser = userDao.getUserByIdSync(uid)
            if (existingUser != null) {
                // Actualizar datos b√°sicos si han cambiado
                if (existingUser.email != email ||
                    existingUser.displayName != displayName ||
                    existingUser.photoUrl != photoUrl
                ) {

                    val updatedUser = existingUser.copy(
                        email = email,
                        displayName = displayName,
                        photoUrl = photoUrl
                    )
                    userDao.insertOrUpdate(updatedUser)
                    sincronizarUsuarioConFirebase(updatedUser)
                    return@withContext updatedUser
                }
                return@withContext existingUser
            }

            // 2. Si no existe, buscar en Firebase
            if (connectivityObserver.isConnected.first()) {
                try {
                    val document = firestore.collection("usuarios")
                        .document(uid)
                        .get()
                        .await()

                    if (document.exists()) {
                        val firebaseUser = mapFirebaseToUserEntity(uid, document.data!!)
                        userDao.insertOrUpdate(firebaseUser)
                        return@withContext firebaseUser
                    }
                } catch (e: Exception) {
                    // Si falla Firebase, crear usuario local
                }
            }

            // 3. Crear usuario nuevo
            val newUser = UserEntity(
                uid = uid,
                email = email,
                displayName = displayName,
                photoUrl = photoUrl,
                esPremium = esPremium
            )

            userDao.insertOrUpdate(newUser)
            sincronizarUsuarioConFirebase(newUser)

            return@withContext newUser

        } catch (e: Exception) {
            // En caso de error, crear usuario m√≠nimo
            val fallbackUser = UserEntity(
                uid = uid,
                email = email,
                displayName = displayName,
                photoUrl = photoUrl,
                esPremium = esPremium
            )
            userDao.insertOrUpdate(fallbackUser)
            return@withContext fallbackUser
        }
    }

    /**
     * Obtiene un usuario por ID
     */
    suspend fun getUserById(uid: String): UserEntity? = withContext(Dispatchers.IO) {
        userDao.getUserByIdSync(uid)
    }

    /**
     * Actualiza el estado Premium del usuario
     */
    suspend fun updateUserPremium(uid: String, esPremium: Boolean) = withContext(Dispatchers.IO) {
        userDao.updateUserPremium(uid, esPremium)
        sincronizarCampoEspecifico(uid, "esPremium", esPremium)
    }

    /**
     * Actualiza el email del usuario
     */
    suspend fun updateUserEmail(uid: String, email: String) = withContext(Dispatchers.IO) {
        userDao.updateUserEmail(uid, email)
        sincronizarCampoEspecifico(uid, "email", email)
    }

    /**
     * Actualiza el nombre del usuario
     */
    suspend fun updateUserDisplayName(uid: String, displayName: String) =
        withContext(Dispatchers.IO) {
            userDao.updateUserDisplayName(uid, displayName)
            sincronizarCampoEspecifico(uid, "displayName", displayName)
        }

    /**
     * Actualiza la foto del usuario
     */
    suspend fun updateUserPhotoUrl(uid: String, photoUrl: String) = withContext(Dispatchers.IO) {
        userDao.updateUserPhotoUrl(uid, photoUrl)
        sincronizarCampoEspecifico(uid, "photoUrl", photoUrl)
    }

    /**
     * Busca usuario por email
     */
    suspend fun getUserByEmail(email: String): UserEntity? = withContext(Dispatchers.IO) {
        userDao.getUserByEmail(email)
    }

    /**
     * Obtiene todos los usuarios Premium
     */
    suspend fun getAllPremiumUsers(): List<UserEntity> = withContext(Dispatchers.IO) {
        userDao.getAllPremiumUsers()
    }

    /**
     * Obtiene todos los usuarios Free
     */
    suspend fun getAllFreeUsers(): List<UserEntity> = withContext(Dispatchers.IO) {
        userDao.getAllFreeUsers()
    }

    /**
     * Sincroniza un usuario espec√≠fico
     */
    suspend fun sincronizar(userId: String) = withContext(Dispatchers.IO) {
        val user = userDao.getUserByIdSync(userId) ?: return@withContext
        sincronizarUsuarioConFirebase(user)
    }

    // ========== M√âTODOS DE SINCRONIZACI√ìN V10 ==========

    /**
     * Sincroniza usuario completo con Firebase
     */
    private fun sincronizarUsuarioConFirebase(user: UserEntity) {
        try {
            val datos = mapOf(
                "uid" to user.uid,
                "email" to user.email,
                "displayName" to user.displayName,
                "photoUrl" to user.photoUrl,
                "esPremium" to user.esPremium,
                "version" to user.version,
                "lastModified" to user.lastModified,
                "fechaCreacion" to user.fechaCreacion,
                "fechaUltimaSync" to dateFormat.format(Date()),
                "activo" to user.activo
            )

            val docRef = firestore.collection("usuarios")
                .document(user.uid)

            docRef.set(datos)
                .addOnSuccessListener {
                    repositoryScope.launch {
                        userDao.markUserSyncSuccessful(user.uid, user.version + 1)
                        userDao.updateFechaUltimaSync(user.uid, dateFormat.format(Date()))
                    }
                }
                .addOnFailureListener {
                    repositoryScope.launch {
                        // El usuario queda marcado como no sincronizado hasta pr√≥ximo intento
                    }
                }

        } catch (e: Exception) {
            // Error en sincronizaci√≥n, se reintentar√° cuando haya conexi√≥n
        }
    }

    /**
     * Sincroniza un campo espec√≠fico del usuario
     */
    private suspend fun sincronizarCampoEspecifico(userId: String, campo: String, valor: Any) {
        try {
            val datos = mapOf(
                campo to valor,
                "lastModified" to System.currentTimeMillis(),
                "fechaUltimaSync" to dateFormat.format(Date())
            )

            firestore.collection("usuarios")
                .document(userId)
                .update(datos)
                .await()

            // Marcar como sincronizado
            userDao.markUserSyncSuccessful(userId, userDao.getUserVersion(userId) ?: 1L + 1)

        } catch (e: Exception) {
            // El campo queda marcado como no sincronizado
        }
    }

    // ========== M√âTODOS AUXILIARES ==========

    /**
     * Convierte datos de Firebase a UserEntity V10
     */
    private fun mapFirebaseToUserEntity(userId: String, data: Map<String, Any>): UserEntity {
        return UserEntity(
            uid = userId,
            email = data["email"] as? String ?: "",
            displayName = data["displayName"] as? String ?: "",
            photoUrl = data["photoUrl"] as? String ?: "",
            esPremium = data["esPremium"] as? Boolean ?: false,
            version = data["version"] as? Long ?: 1L,
            lastModified = data["lastModified"] as? Long ?: System.currentTimeMillis(),
            sincronizadoFirebase = true, // Viene de Firebase, est√° sincronizado
            fechaCreacion = data["fechaCreacion"] as? Long ?: System.currentTimeMillis(),
            fechaUltimaSync = dateFormat.format(Date()),
            activo = data["activo"] as? Boolean ?: true
        )
    }

    // ========== M√âTODOS OBSOLETOS V10 (compatibilidad) ==========

    @Deprecated(
        "Usar getOrCreateUser()",
        ReplaceWith("getOrCreateUser(userId, \"\", \"\", \"\", false)")
    )
    suspend fun loadUserData(userId: String): UserEntity? {
        return getOrCreateUser(userId, "", "", "", false)
    }

    @Deprecated(
        "Sistema multiusuario eliminado en V10",
        ReplaceWith("updateUserPremium(userId, premium)")
    )
    suspend fun updateUserPlan(userId: String, planUsuario: String, empresaId: String? = null) {
        updateUserPremium(userId, planUsuario == "PREMIUM")
    }

    @Deprecated(
        "Sistema multiusuario eliminado en V10",
        ReplaceWith("updateUserPremium(userId, true)")
    )
    suspend fun createCompany(userId: String, companyName: String, companyEmail: String): String {
        updateUserPremium(userId, true)
        return "empresa_${System.currentTimeMillis()}" // ID dummy para compatibilidad
    }

    @Deprecated(
        "Sistema multiusuario eliminado en V10",
        ReplaceWith("updateUserPremium(userId, true)")
    )
    suspend fun updateUserType(userId: String, tipoUsuario: String) {
        // En V10, solo distinguimos Premium/Free
        updateUserPremium(userId, tipoUsuario != "FREE")
    }

    @Deprecated("Sistema multiusuario eliminado en V10", ReplaceWith("false"))
    suspend fun inviteUserToCompany(
        email: String,
        empresaId: String,
        tipoUsuario: String
    ): Boolean {
        return false // No soportado en V10
    }

    @Deprecated(
        "Configuraci√≥n personal eliminada en V10 - ahora global",
        ReplaceWith("ConfiguracionRepository.updateIdioma()")
    )
    suspend fun updateUserIdioma(userId: String, idioma: String) {
        // No-op en V10
    }

    @Deprecated(
        "Configuraci√≥n personal eliminada en V10 - ahora global",
        ReplaceWith("ConfiguracionRepository.updateFuente()")
    )
    suspend fun updateUserFuente(userId: String, fuente: String) {
        // No-op en V10
    }

    @Deprecated(
        "Configuraci√≥n personal eliminada en V10 - ahora global",
        ReplaceWith("ConfiguracionRepository.updateTemaOscuro()")
    )
    suspend fun updateUserModoOscuro(userId: String, modoOscuro: Boolean) {
        // No-op en V10
    }

    @Deprecated(
        "Configuraci√≥n personal eliminada en V10 - ahora global",
        ReplaceWith("ConfiguracionRepository m√©todos individuales")
    )
    suspend fun updateUserConfiguration(
        userId: String,
        idioma: String,
        fuente: String,
        modoOscuro: Boolean
    ) {
        // No-op en V10 - La configuraci√≥n ahora es global
    }
    // ========== REEMPLAZA el m√©todo getHybridUserData() en UserRepository.kt ==========

    suspend fun getHybridUserData(uid: String): UserEntity? = withContext(Dispatchers.IO) {
        try {
            // 1. Verificar si hay datos pendientes de sincronizar en Room
            val roomUser = userDao.getUserByIdSync(uid)
            val hasPendingChanges = roomUser?.sincronizadoFirebase == false

            if (hasPendingChanges) {
                // ‚úÖ HAY CAMBIOS PENDIENTES ‚Üí Leer de Room (fuente de verdad)
                Log.d("UserRepository", "üì± Leyendo de ROOM (cambios pendientes): $uid")
                return@withContext roomUser
            } else {
                // ‚úÖ NO HAY CAMBIOS PENDIENTES ‚Üí Leer de Firebase (m√°s actualizado)
                Log.d("UserRepository", "‚òÅÔ∏è Leyendo de FIREBASE (sin cambios pendientes): $uid")

                if (connectivityObserver.isConnected.first()) {
                    try {
                        val firebaseDoc = firestore.collection("usuarios")
                            .document(uid)
                            .get()
                            .await()

                        if (firebaseDoc.exists()) {
                            val firebaseUser = mapFirebaseToUserEntity(uid, firebaseDoc.data!!)

                            // Actualizar Room con datos frescos de Firebase
                            userDao.insertOrUpdate(firebaseUser.copy(sincronizadoFirebase = true))

                            Log.d("UserRepository", "‚úÖ Datos frescos de Firebase aplicados a Room")
                            return@withContext firebaseUser
                        }
                    } catch (e: Exception) {
                        Log.w(
                            "UserRepository",
                            "‚ùå Error leyendo Firebase, usando Room como fallback",
                            e
                        )
                    }
                }

                // Fallback: usar Room si Firebase falla o no hay conexi√≥n
                return@withContext roomUser ?: getOrCreateUser(uid, "", "", "", false)
            }

        } catch (e: Exception) {
            Log.e("UserRepository", "Error en estrategia h√≠brida", e)
            // En caso de error, devolver lo que tengamos en Room o crear usuario b√°sico
            val fallbackUser = userDao.getUserByIdSync(uid)
            return@withContext fallbackUser ?: getOrCreateUser(uid, "", "", "", false)
        }
    }
    // En UserRepository.kt
    suspend fun updateUserProfile(userId: String, displayName: String, email: String) {
        try {
            userDao.updateUserProfile(userId, displayName, email)
            Log.d(TAG, "‚úÖ Perfil actualizado en Room: $displayName, $email")
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error actualizando perfil en Room", e)
        }
    }
    suspend fun updateUserProfileAndMarkDirty(userId: String, displayName: String, email: String) = withContext(Dispatchers.IO) {
        try {
            // 1. Actualizar los datos en Room
            userDao.updateUserProfile(userId, displayName, email)

            // 2. ‚úÖ CLAVE: Marcar como NO SINCRONIZADO para que getHybridUserData use Room
            userDao.markUserNotSynced(userId)

            Log.d("UserRepository", "‚úÖ Perfil actualizado y marcado como no sincronizado")
            Log.d("UserRepository", "   - displayName: $displayName")
            Log.d("UserRepository", "   - sincronizadoFirebase: false")

        } catch (e: Exception) {
            Log.e("UserRepository", "‚ùå Error actualizando perfil", e)
        }
    }
    suspend fun refreshUserData(uid: String) = withContext(Dispatchers.IO) {
        try {
            // Forzar lectura de Firebase y actualizar Room
            if (connectivityObserver.isConnected.first()) {
                val firebaseDoc = firestore.collection("usuarios")
                    .document(uid)
                    .get()
                    .await()

                if (firebaseDoc.exists()) {
                    val firebaseUser = mapFirebaseToUserEntity(uid, firebaseDoc.data!!)
                    userDao.insertOrUpdate(firebaseUser.copy(sincronizadoFirebase = true))
                    Log.d("UserRepository", "‚úÖ Datos de usuario refrescados desde Firebase")
                }
            }
        } catch (e: Exception) {
            Log.w("UserRepository", "‚ùå Error refrescando datos de usuario", e)
        }
    }

    // M√©todo auxiliar para obtener usuario actual (si no existe)
    suspend fun getCurrentUser(): UserEntity? = withContext(Dispatchers.IO) {
        currentUser.value
    }
}

// app/src/main/java/es/nuskysoftware/marketsales/data/repository/VentasRepository.kt
package es.nuskysoftware.marketsales.data.repository

import android.content.Context
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import es.nuskysoftware.marketsales.data.local.dao.LineasVentaDao
import es.nuskysoftware.marketsales.data.local.dao.RecibosDao
import es.nuskysoftware.marketsales.data.local.database.AppDatabase
import es.nuskysoftware.marketsales.data.local.entity.LineaVentaEntity
import es.nuskysoftware.marketsales.data.local.entity.ReciboEntity
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.tasks.await
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import java.util.UUID

class VentasRepository(context: Context) {

    private val database: AppDatabase = AppDatabase.getDatabase(context)
    private val recibosDao: RecibosDao = database.recibosDao()
    private val lineasVentaDao: LineasVentaDao = database.lineasVentaDao()
    private val configuracionDao = database.configuracionDao()

    private val firestore = FirebaseFirestore.getInstance()
    private val auth = FirebaseAuth.getInstance()

    /**
     * Guarda una venta completa (recibo + l√≠neas) en Room (offline-first) y
     * hace un best-effort de subida a Firestore.
     *
     * Reglas:
     * - idRecibo = "RC" + HHmmss + "-" + <IDIOMA_APP_MAYUS>  (idioma tomado de ConfiguracionEntity)
     * - idLinea  = contador "0001", "0002", ... que SE REINICIA por mercadillo.
     *             Se calcula como max(idLinea) del mercadillo + 1 (zero-padded 4 d√≠gitos).
     */
    suspend fun guardarVenta(
        idMercadillo: String,
        lineas: List<LineaVentaUI>,
        metodoPago: String,
        total: Double
    ): Result<String> {
        return try {
            val userId = auth.currentUser?.uid ?: throw Exception("Usuario no autenticado")
            val now = System.currentTimeMillis()

            // === IDIOMA desde la configuraci√≥n de la APP (no del dispositivo) ===
            // Intento 1: DAO (persistido). Si por cualquier motivo es null, uso el flujo en memoria del ConfigurationManager.
            val idiomaCfgPersistido = configuracionDao.getConfiguracionSync()?.idioma
            val idioma2Letras = (idiomaCfgPersistido ?: ConfigurationManager.idioma.value)
                .trim()
                .split('-', '_')
                .firstOrNull()
                ?.take(2)
                ?.uppercase(Locale.ROOT)
                ?: "ES"

            // === idRecibo en formato RChhmmss-ES ===
            val hora = SimpleDateFormat("HHmmss", Locale.getDefault()).format(Date(now))
            val idRecibo = "RC$hora-$idioma2Letras"

            // === Siguiente idLinea por mercadillo: MAX(idLinea) + 1 ===
            // Nota: funciona porque idLinea est√° zero-padded a 4 d√≠gitos.
            val maxId = lineasVentaDao.obtenerMaxIdLineaPorMercadillo(idMercadillo) // p.ej. "0007" o null
            val base = maxId?.toIntOrNull() ?: 0
            fun nextSeq(n: Int) = String.format("%04d", n)

            // --- Construir entidades ---
            val recibo = ReciboEntity(
                idRecibo = idRecibo,
                idMercadillo = idMercadillo,
                idUsuario = userId,
                fechaHora = now,
                metodoPago = metodoPago,
                totalTicket = total,
                estado = "COMPLETADO"
            )

            val lineasEntity = lineas.mapIndexed { index, l ->
                val numeroLineaRecibo = index + 1                      // orden dentro de este recibo
                val idLineaSecuencial = nextSeq(base + numeroLineaRecibo) // 0001, 0002, ...
                LineaVentaEntity(
                    idLinea = idLineaSecuencial,
                    idRecibo = idRecibo,
                    idMercadillo = idMercadillo,
                    idUsuario = userId,
                    numeroLinea = numeroLineaRecibo,
                    tipoLinea = l.tipoLinea.name,
                    descripcion = l.descripcion,
                    idProducto = l.idProducto,
                    cantidad = l.cantidad,
                    precioUnitario = l.precioUnitario,
                    subtotal = l.subtotal,
                    idLineaOriginalAbonada = l.idLineaOriginalAbonada
                )
            }

            // --- Persistencia local (offline-first) ---
            recibosDao.insertarRecibo(recibo)
            lineasVentaDao.insertarLineas(lineasEntity)

            // --- Best-effort Firestore (sin romper si falla) ---
            try {
                firestore.collection("recibos")
                    .document(idRecibo)
                    .set(recibo)
                    .await()

                lineasEntity.forEach { linea ->
                    val docId = "${linea.idMercadillo}_${linea.idLinea}" // √∫nico por mercadillo+l√≠nea
                    firestore.collection("lineas_venta")
                        .document(docId)
                        .set(linea)
                        .await()
                }
            } catch (e: Exception) {
                // Silencioso: ya qued√≥ persistido en Room
                println("Error subiendo a Firestore: ${e.message}")
            }

            Result.success(idRecibo)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    fun obtenerVentasMercadillo(idMercadillo: String): Flow<List<ReciboEntity>> =
        recibosDao.obtenerRecibosPorMercadillo(idMercadillo)

    fun obtenerLineasVenta(idRecibo: String): Flow<List<LineaVentaEntity>> =
        lineasVentaDao.obtenerLineasPorRecibo(idRecibo)

    /**
     * Crea un abono por la l√≠nea original indicada.
     * Aplica las mismas reglas de idRecibo e idLinea que una venta normal.
     */
    suspend fun crearAbono(
        lineaOriginal: LineaVentaEntity,
        cantidadAbonar: Int,
        idMercadillo: String
    ): Result<String> {
        return try {
            val userId = auth.currentUser?.uid ?: throw Exception("Usuario no autenticado")
            val now = System.currentTimeMillis()

            val idiomaCfgPersistido = configuracionDao.getConfiguracionSync()?.idioma
            val idioma2Letras = (idiomaCfgPersistido ?: ConfigurationManager.idioma.value)
                .trim()
                .split('-', '_')
                .firstOrNull()
                ?.take(2)
                ?.uppercase(Locale.ROOT)
                ?: "ES"

            val hora = SimpleDateFormat("HHmmss", Locale.getDefault()).format(Date(now))
            val idRecibo = "RC$hora-$idioma2Letras"

            val maxId = lineasVentaDao.obtenerMaxIdLineaPorMercadillo(idMercadillo)
            val base = maxId?.toIntOrNull() ?: 0
            fun nextSeq(n: Int) = String.format("%04d", n)

            val reciboAbono = ReciboEntity(
                idRecibo = idRecibo,
                idMercadillo = idMercadillo,
                idUsuario = userId,
                fechaHora = now,
                metodoPago = "ABONO",
                totalTicket = -(lineaOriginal.precioUnitario * cantidadAbonar),
                estado = "COMPLETADO"
            )

            val lineaAbono = LineaVentaEntity(
                idLinea = nextSeq(base + 1),
                idRecibo = idRecibo,
                idMercadillo = idMercadillo,
                idUsuario = userId,
                numeroLinea = 1,
                tipoLinea = lineaOriginal.tipoLinea,
                descripcion = "ABONO: ${lineaOriginal.descripcion}",
                idProducto = lineaOriginal.idProducto,
                cantidad = -cantidadAbonar,
                precioUnitario = lineaOriginal.precioUnitario,
                subtotal = -(lineaOriginal.precioUnitario * cantidadAbonar),
                idLineaOriginalAbonada = lineaOriginal.idLinea
            )

            recibosDao.insertarRecibo(reciboAbono)
            lineasVentaDao.insertarLinea(lineaAbono)

            try {
                firestore.collection("recibos")
                    .document(idRecibo)
                    .set(reciboAbono)
                    .await()

                val docId = "${lineaAbono.idMercadillo}_${lineaAbono.idLinea}"
                firestore.collection("lineas_venta")
                    .document(docId)
                    .set(lineaAbono)
                    .await()
            } catch (e: Exception) {
                println("Error subiendo abono a Firestore: ${e.message}")
            }

            Result.success(idRecibo)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

// =====================
// Modelos de UI (igual que ten√≠as)
// =====================
data class LineaVentaUI(
    val id: String = UUID.randomUUID().toString(),
    val tipoLinea: TipoLinea,
    val descripcion: String,
    val idProducto: String? = null,
    val cantidad: Int,
    val precioUnitario: Double,
    val subtotal: Double,
    val idLineaOriginalAbonada: String? = null
)

enum class TipoLinea { MANUAL, PRODUCTO }
enum class MetodoPago { EFECTIVO, BIZUM, TARJETA }
enum class PestanaVenta { MANUAL, PRODUCTOS }


// app/src/main/java/es/nuskysoftware/marketsales/ui/composables/BotonCarritoVentas.kt
package es.nuskysoftware.marketsales.ui.composables

import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.shadow
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import es.nuskysoftware.marketsales.R
import es.nuskysoftware.marketsales.ui.viewmodel.VentasViewModel

/**
 * Bot√≥n de carrito (solo dise√±o):
 * - Icono grande 40.dp
 * - Badge grande 22.dp, borde blanco 2.dp y texto 12.sp en bold
 * - Sin cambios de l√≥gica
 */
@Composable

fun BotonCarritoVentas(
    ventasViewModel: VentasViewModel,
    onClick: () -> Unit
) {
    val uiState by ventasViewModel.uiState.collectAsState()
    val numLineas = uiState.lineasTicket.size

    Box(
        modifier = Modifier
            .size(90.dp) // Espacio para el FAB + badge
    ) {
        // FAB de carrito
        FloatingActionButton(
            onClick = onClick,
            containerColor = MaterialTheme.colorScheme.secondaryContainer,
            modifier = Modifier
                .align(Alignment.BottomEnd)
                .size(70.dp),
            shape = CircleShape
        ) {
            Icon(
                painter = painterResource(id = R.drawable.ic_shopping_cart_24),
                contentDescription = "Carrito",
                tint = MaterialTheme.colorScheme.onSecondaryContainer,
                modifier = Modifier.size(34.dp) // Icono m√°s grande
            )
        }

        // Badge fuera del FAB, no se recorta
        if (numLineas > 0) {
            Box(
                modifier = Modifier
                    .align(Alignment.TopEnd)
                    .offset(x = 6.dp, y = (-6).dp) // Posici√≥n del badge
                    .size(24.dp)
                    .background(
                        color = MaterialTheme.colorScheme.error,
                        shape = CircleShape
                    )
                    .border(
                        width = 2.dp,
                        color = MaterialTheme.colorScheme.surface,
                        shape = CircleShape
                    ),
                contentAlignment = Alignment.Center
            ) {
                Text(
                    text = numLineas.toString(),
                    color = MaterialTheme.colorScheme.onError,
                    fontSize = 13.sp,
                    fontWeight = FontWeight.Bold
                )
            }
        }
    }
}

// app/src/main/java/es/nuskysoftware/marketsales/ui/components/BottomBarMercadillo.kt
package es.nuskysoftware.marketsales.ui.components

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import es.nuskysoftware.marketsales.R
import es.nuskysoftware.marketsales.data.local.entity.MercadilloEntity
import es.nuskysoftware.marketsales.utils.StringResourceManager

/**
 * BottomBar para operaciones con mercadillos activos
 * Solo se muestra cuando hay mercadillos en estado EN_CURSO
 */
@Composable
fun BottomBarMercadillo(
    mercadilloActivo: MercadilloEntity?,
    onVentasClick: () -> Unit,
    onGastosClick: () -> Unit,
    onResumenClick: () -> Unit,
    onCambiarMercadillo: () -> Unit,
    currentLanguage: String,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .padding(8.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 8.dp),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surface
        ),
        shape = RoundedCornerShape(16.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(12.dp)
        ) {
            // Header con informaci√≥n del mercadillo activo
            mercadilloActivo?.let { mercadillo ->
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Column(modifier = Modifier.weight(1f)) {
                        Text(
                            text = "Mercadillo Activo:",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                        )
                        Text(
                            text = mercadillo.lugar,
                            style = MaterialTheme.typography.bodyMedium,
                            fontWeight = FontWeight.Bold,
                            color = MaterialTheme.colorScheme.primary
                        )
                    }

                    // Bot√≥n para cambiar mercadillo
                    TextButton(
                        onClick = onCambiarMercadillo,
                        modifier = Modifier.padding(start = 8.dp)
                    ) {
                        Text(
                            text = "Cambiar",
                            fontSize = 12.sp,
                            color = MaterialTheme.colorScheme.primary
                        )
                    }
                }

                Spacer(modifier = Modifier.height(12.dp))
            }

            // Botones de acciones
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                // Bot√≥n Ventas
                BottomBarButton(
                    icon = R.drawable.ic_ventas, // Nombre temporal del icono
                    text = "Ventas",
                    onClick = onVentasClick,
                    color = Color(0xFF4CAF50), // Verde
                    modifier = Modifier.weight(1f)
                )

                Spacer(modifier = Modifier.width(8.dp))

                // Bot√≥n Gastos
                BottomBarButton(
                    icon = R.drawable.ic_gastos, // Nombre temporal del icono
                    text = "Gastos",
                    onClick = onGastosClick,
                    color = Color(0xFFF44336), // Rojo
                    modifier = Modifier.weight(1f)
                )

                Spacer(modifier = Modifier.width(8.dp))

                // Bot√≥n Resumen
                BottomBarButton(
                    icon = R.drawable.ic_resumen, // Nombre temporal del icono
                    text = "Resumen",
                    onClick = onResumenClick,
                    color = Color(0xFF2196F3), // Azul
                    modifier = Modifier.weight(1f)
                )
            }
        }
    }
}

/**
 * Bot√≥n individual del BottomBar
 */
@Composable
private fun BottomBarButton(
    icon: Int,
    text: String,
    onClick: () -> Unit,
    color: Color,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .height(60.dp),
        onClick = onClick,
        colors = CardDefaults.cardColors(
            containerColor = color.copy(alpha = 0.1f)
        ),
        border = androidx.compose.foundation.BorderStroke(
            1.dp,
            color.copy(alpha = 0.3f)
        ),
        shape = RoundedCornerShape(12.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(8.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            Icon(
                painter = painterResource(id = icon),
                contentDescription = text,
                tint = color,
                modifier = Modifier.size(20.dp)
            )

            Spacer(modifier = Modifier.height(4.dp))

            Text(
                text = text,
                style = MaterialTheme.typography.bodySmall,
                color = color,
                fontWeight = FontWeight.Medium,
                textAlign = TextAlign.Center,
                fontSize = 10.sp
            )
        }
    }
}

/**
 * Di√°logo para seleccionar mercadillo activo cuando hay m√∫ltiples en curso
 */
@Composable
fun DialogoSeleccionMercadilloActivo(
    mercadillosEnCurso: List<MercadilloEntity>,
    onMercadilloSeleccionado: (MercadilloEntity) -> Unit,
    onDismiss: () -> Unit,
    currentLanguage: String
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = {
            Text(
                text = "Seleccionar Mercadillo Activo",
                style = MaterialTheme.typography.titleLarge,
                fontWeight = FontWeight.Bold
            )
        },
        text = {
            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Text(
                    text = "Hay m√∫ltiples mercadillos en curso. Selecciona uno para realizar operaciones:",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                )

                Spacer(modifier = Modifier.height(8.dp))

                mercadillosEnCurso.forEach { mercadillo ->
                    Card(
                        modifier = Modifier
                            .fillMaxWidth(),
                        onClick = { onMercadilloSeleccionado(mercadillo) },
                        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp),
                        colors = CardDefaults.cardColors(
                            containerColor = MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.3f)
                        )
                    ) {
                        Column(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(12.dp)
                        ) {
                            Text(
                                text = mercadillo.lugar,
                                style = MaterialTheme.typography.titleMedium,
                                fontWeight = FontWeight.Bold,
                                color = MaterialTheme.colorScheme.onSurface
                            )

                            Spacer(modifier = Modifier.height(4.dp))

                            Text(
                                text = "${mercadillo.organizador} ‚Ä¢ ${mercadillo.horaInicio} - ${mercadillo.horaFin}",
                                style = MaterialTheme.typography.bodyMedium,
                                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                            )

                            if (mercadillo.saldoInicial != null) {
                                Spacer(modifier = Modifier.height(4.dp))
                                Text(
                                    text = "üí∞ Saldo inicial: ‚Ç¨${String.format("%.2f", mercadillo.saldoInicial)}",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = Color(0xFF4CAF50),
                                    fontWeight = FontWeight.Medium
                                )
                            }
                        }
                    }
                }
            }
        },
        confirmButton = { },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancelar")
            }
        }
    )
}

package es.nuskysoftware.cajamercadillos.ui.components

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import com.github.skydoves.colorpicker.compose.AlphaSlider
import com.github.skydoves.colorpicker.compose.BrightnessSlider
import com.github.skydoves.colorpicker.compose.HsvColorPicker
import com.github.skydoves.colorpicker.compose.rememberColorPickerController

/**
 * DialogSelectorColor:
 * Di√°logo reutilizable con selector de color basado en Skydoves.
 * Incluye:
 *  - HsvColorPicker (selector principal)
 *  - Sliders de brillo y opacidad
 *  - Botones Aceptar / Cancelar
 */
@Composable
fun DialogSelectorColor(
    onColorElegido: (Color) -> Unit,
    onCancelar: () -> Unit
) {
    val controller = rememberColorPickerController()

    AlertDialog(
        onDismissRequest = { onCancelar() },
        confirmButton = {
            TextButton(onClick = {
                onColorElegido(controller.selectedColor.value)
            }) {
                Text("Aceptar", color = Color.Black)
            }
        },
        dismissButton = {
            TextButton(onClick = onCancelar) {
                Text("Cancelar", color = Color.Black)
            }
        },
        title = { Text("Selecciona un color") },
        text = {
            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                // Selector principal
                HsvColorPicker(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(200.dp)
                        .padding(8.dp),
                    controller = controller,
                    onColorChanged = {}
                )
                // Control de transparencia
                AlphaSlider(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(8.dp),
                    controller = controller
                )
                // Control de brillo
                BrightnessSlider(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(8.dp),
                    controller = controller
                )
            }
        }
    )
}

package es.nuskysoftware.marketsales.ui.composables

import androidx.compose.foundation.layout.size
import androidx.compose.material3.Icon
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.PathFillType
import androidx.compose.ui.graphics.SolidColor
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.StrokeJoin
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.graphics.vector.path
import androidx.compose.ui.unit.dp

// üõí ICONO CARRITO PERSONALIZADO (m√°s grande y visible)
val IconoCarritoCustom: ImageVector
    get() {
        return ImageVector.Builder(
            name = "shopping_cart_custom",
            defaultWidth = 24.dp,
            defaultHeight = 24.dp,
            viewportWidth = 24f,
            viewportHeight = 24f
        ).apply {
            path(
                fill = SolidColor(Color.Black),
                fillAlpha = 1.0f,
                stroke = null,
                strokeAlpha = 1.0f,
                strokeLineWidth = 1.0f,
                strokeLineCap = StrokeCap.Butt,
                strokeLineJoin = StrokeJoin.Miter,
                strokeLineMiter = 1.0f,
                pathFillType = PathFillType.NonZero
            ) {
                // Carrito m√°s grueso y visible
                moveTo(7f, 18f)
                curveTo(5.9f, 18f, 5f, 18.9f, 5f, 20f)
                curveTo(5f, 21.1f, 5.9f, 22f, 7f, 22f)
                curveTo(8.1f, 22f, 9f, 21.1f, 9f, 20f)
                curveTo(9f, 18.9f, 8.1f, 18f, 7f, 18f)
                close()

                moveTo(1f, 2f)
                verticalLineTo(4f)
                horizontalLineTo(3f)
                lineTo(6.6f, 11.59f)
                lineTo(5.25f, 14.04f)
                curveTo(5.09f, 14.32f, 5f, 14.65f, 5f, 15f)
                curveTo(5f, 16.1f, 5.9f, 17f, 7f, 17f)
                horizontalLineTo(19f)
                verticalLineTo(15f)
                horizontalLineTo(7.42f)
                curveTo(7.28f, 15f, 7.17f, 14.89f, 7.17f, 14.75f)
                lineTo(7.2f, 14.63f)
                lineTo(8.1f, 13f)
                horizontalLineTo(15.55f)
                curveTo(16.3f, 13f, 16.96f, 12.59f, 17.3f, 11.97f)
                lineTo(20.88f, 5f)
                horizontalLineTo(5.21f)
                lineTo(4.27f, 2f)
                horizontalLineTo(1f)
                close()

                moveTo(17f, 18f)
                curveTo(15.9f, 18f, 15f, 18.9f, 15f, 20f)
                curveTo(15f, 21.1f, 15.9f, 22f, 17f, 22f)
                curveTo(18.1f, 22f, 19f, 21.1f, 19f, 20f)
                curveTo(19f, 18.9f, 18.1f, 18f, 17f, 18f)
                close()
            }
        }.build()
    }

@Composable
fun IconoCarritoGrande(
    modifier: Modifier = Modifier,
    tint: Color = Color.Black
) {
    Icon(
        imageVector = IconoCarritoCustom,
        contentDescription = "Carrito de compras",
        modifier = modifier,
        tint = tint
    )
}

// MenuHamburguesa.kt V10 - SIMPLIFICADO PARA SISTEMA MONOUSUARIO
package es.nuskysoftware.marketsales.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import es.nuskysoftware.marketsales.R
import es.nuskysoftware.marketsales.ui.viewmodel.AuthViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.AuthViewModelFactory
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.StringResourceManager
import kotlinx.coroutines.launch

@Composable
fun MenuHamburguesa(
    navController: NavController,
    drawerState: DrawerState
) {
    val scope = rememberCoroutineScope()
    val context = LocalContext.current

    // AuthViewModel para detectar estado de usuario
    val authViewModel: AuthViewModel = viewModel(factory = AuthViewModelFactory(context))
    val currentUser by authViewModel.currentUser.collectAsState()

    // Estados V10 simplificados
    val currentLanguage by ConfigurationManager.idioma.collectAsState()
    val esPremium by ConfigurationManager.esPremium.collectAsState()
    val isAuthenticated by ConfigurationManager.isAuthenticated.collectAsState()
    val estaAutenticado by ConfigurationManager.isAuthenticated.collectAsState()
    val usuarioEmail by ConfigurationManager.usuarioEmail.collectAsState()
    val displayName by ConfigurationManager.displayName.collectAsState()

    // Versi√≥n V10
    val versionText = if (esPremium) "Premium V10.0" else "Free V10.0"

    ModalDrawerSheet(
        modifier = Modifier.width(280.dp),
        drawerContainerColor = MaterialTheme.colorScheme.surface
    ) {
        // Header del men√∫ V10
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .height(120.dp)
                .background(MaterialTheme.colorScheme.primary),
            contentAlignment = Alignment.CenterStart
        ) {
            Column(
                modifier = Modifier.padding(16.dp)
            ) {
                Text(
                    text = StringResourceManager.getString("app_name", currentLanguage),
                    fontSize = 24.sp,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.onPrimary
                )

                Text(
                    text = versionText,
                    fontSize = 14.sp,
                    color = MaterialTheme.colorScheme.onPrimary.copy(alpha = 0.8f)
                )

                // Informaci√≥n del usuario V10
                if (isAuthenticated && currentUser != null) {
                    Text(
                        text = "üë§ ${usuarioEmail ?: displayName ?: "Usuario"}",
                        fontSize = 12.sp,
                        color = MaterialTheme.colorScheme.onPrimary.copy(alpha = 0.7f)
                    )
                } else {
                    Text(
                        text = "üë§ Usuario Invitado",
                        fontSize = 12.sp,
                        color = MaterialTheme.colorScheme.onPrimary.copy(alpha = 0.7f)
                    )
                }
            }
        }

        Spacer(modifier = Modifier.height(8.dp))

        // Opciones del men√∫
        LazyColumn {
            // Opciones principales
            item {
                MenuOption(
                    iconRes = R.drawable.ic_store,
                    title = StringResourceManager.getString("mercadillos", currentLanguage),
                    onClick = {
                        scope.launch { drawerState.close() }
                        navController.navigate("mercadillos") {
                            popUpTo("mercadillos") { inclusive = true }
                        }
                    }
                )
            }

            item {
                MenuOption(
                    iconRes = R.drawable.ic_list,
                    title = StringResourceManager.getString("articulos", currentLanguage),
                    onClick = {
                        scope.launch { drawerState.close() }
                        navController.navigate("articulos")
                    }
                )
            }

            item {
                MenuOption(
                    iconRes = R.drawable.ic_category,
                    title = StringResourceManager.getString("categorias", currentLanguage),
                    onClick = {
                        scope.launch { drawerState.close() }
                        navController.navigate("categorias")
                    }
                )
            }

            item {
                MenuOption(
                    iconRes = R.drawable.ic_inventory,
                    title = StringResourceManager.getString("inventario", currentLanguage),
                    onClick = {
                        scope.launch { drawerState.close() }
                        navController.navigate("inventario")
                    }
                )
            }

            item {
                MenuOption(
                    iconRes = R.drawable.ic_list,
                    title = StringResourceManager.getString("listados", currentLanguage),
                    onClick = {
                        scope.launch { drawerState.close() }
                        navController.navigate("listados")
                    }
                )
            }

            item {
                HorizontalDivider(
                    modifier = Modifier.padding(vertical = 8.dp),
                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f)
                )
            }

            // Perfil (solo para usuarios autenticados)
           // if (isAuthenticated && currentUser != null) {
            if (estaAutenticado ) {
                item {
                    MenuOption(
                        iconRes = R.drawable.ic_account,
                        title = StringResourceManager.getString("perfil", currentLanguage),
                        onClick = {
                            scope.launch { drawerState.close() }
                            navController.navigate("perfil")
                        }
                    )
                }
            }

            // Configuraci√≥n
            item {
                MenuOption(
                    iconRes = R.drawable.ic_settings,
                    title = StringResourceManager.getString("configuracion", currentLanguage),
                    onClick = {
                        scope.launch { drawerState.close() }
                        navController.navigate("configuracion")
                    }
                )
            }

            // Login/Logout condicional V10
            item {
                //if (isAuthenticated && currentUser != null) {
                if (estaAutenticado ) {
                    // Usuario autenticado - mostrar LOGOUT
                    MenuOption(
                        iconRes = R.drawable.ic_logout,
                        title = StringResourceManager.getString("cerrar_sesion", currentLanguage),
                        onClick = {
                            scope.launch {
                                drawerState.close()
                                authViewModel.logout()
                            }
                        }
                    )
                } else {
                    // Usuario NO autenticado - mostrar LOGIN
                    MenuOption(
                        iconRes = R.drawable.ic_login,
                        title = StringResourceManager.getString("iniciar_sesion", currentLanguage),
                        onClick = {
                            scope.launch { drawerState.close() }
                            navController.navigate("login")
                        }
                    )
                }
            }

            // Salir app
            item {
                MenuOption(
                    iconRes = R.drawable.ic_exit,
                    title = StringResourceManager.getString("salir", currentLanguage),
                    onClick = {
                        scope.launch { drawerState.close() }
                        (context as? androidx.activity.ComponentActivity)?.finishAffinity()
                    }
                )
            }
        }
    }
}

@Composable
private fun MenuOption(
    iconRes: Int,
    title: String,
    onClick: () -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onClick() }
            .padding(horizontal = 16.dp, vertical = 12.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Icon(
            painter = painterResource(id = iconRes),
            contentDescription = title,
            tint = MaterialTheme.colorScheme.onSurface,
            modifier = Modifier.size(24.dp)
        )

        Spacer(modifier = Modifier.width(16.dp))

        Text(
            text = title,
            fontSize = 16.sp,
            color = MaterialTheme.colorScheme.onSurface,
            fontWeight = FontWeight.Medium
        )
    }
}


package es.nuskysoftware.marketsales.ui.composables

import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier

@Composable
fun CampoDescripcion(
    descripcion: String,
    onDescripcionChange: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    OutlinedTextField(
        value = descripcion,
        onValueChange = onDescripcionChange,
        label = { Text("Descripci√≥n *") },
        placeholder = { Text("Ej: Llavero Delf√≠n Madera") },
        modifier = modifier.fillMaxWidth(),
        singleLine = true,
        isError = descripcion.isBlank(),
        supportingText = {
            if (descripcion.isBlank()) {
                Text(
                    text = "La descripci√≥n es obligatoria",
                    color = MaterialTheme.colorScheme.error
                )
            }
        }
    )
}

package es.nuskysoftware.marketsales.ui.composables

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp

@Composable
fun CampoImporte(
    importe: String,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.background
        )
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth(),
                //.padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(
                text = "Importe",
                style = MaterialTheme.typography.bodyLarge,
                color = MaterialTheme.colorScheme.onPrimaryContainer
            )

            Spacer(modifier = Modifier.height(8.dp))

            Text(
                text = "${importe.replace('.', ',')} ‚Ç¨",
                style = MaterialTheme.typography.displayLarge,
                fontWeight = FontWeight.Bold,
                color = MaterialTheme.colorScheme.onPrimaryContainer,
                textAlign = TextAlign.Center
            )
        }
    }
}

// app/src/main/java/es/nuskysoftware/marketsales/ui/composables/PestanaVentaManual.kt
package es.nuskysoftware.marketsales.ui.composables

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import es.nuskysoftware.marketsales.data.local.entity.MercadilloEntity
import es.nuskysoftware.marketsales.ui.viewmodel.VentasViewModel
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.MonedaUtils

@Composable
fun PestanaVentaManual(
    ventasViewModel: VentasViewModel,
    navController: NavController,
    mercadilloActivo: MercadilloEntity,
    onRealizarCargo: (totalFormateado: String) -> Unit
) {
    val uiState by ventasViewModel.uiState.collectAsState()
    val moneda by ConfigurationManager.moneda.collectAsState()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(6.dp)
    ) {
        // Importe grande
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .padding(2.dp),
            contentAlignment = Alignment.Center
        ) {
            CampoImporte(
                importe = uiState.importeActual,
                modifier = Modifier.fillMaxWidth()
            )
        }

        Spacer(Modifier.height(6.dp))

        // Descripci√≥n
        CampoDescripcion(
            descripcion = uiState.descripcionActual,
            onDescripcionChange = ventasViewModel::actualizarDescripcion,
            modifier = Modifier.fillMaxWidth()
        )

        Spacer(Modifier.height(6.dp))

        // Teclado num√©rico
        TecladoNumerico(
            onDigitClick = ventasViewModel::onDigitoPresionado,
            onClearClick = ventasViewModel::onBorrarDigito,
            onDoubleZeroClick = ventasViewModel::onDobleDecimalPresionado
        )

        Spacer(Modifier.height(24.dp))

        // A√±adir l√≠nea manual
        Button(
            onClick = {
                if (uiState.descripcionActual.isNotBlank() &&
                    ventasViewModel.obtenerImporteComoDouble() > 0
                ) {
                    ventasViewModel.a√±adirLineaManual()
                }
            },
            modifier = Modifier
                .fillMaxWidth()
                .height(56.dp),
            enabled = uiState.descripcionActual.isNotBlank() &&
                    ventasViewModel.obtenerImporteComoDouble() > 0,
            shape = RoundedCornerShape(12.dp),
            colors = ButtonDefaults.buttonColors(
                containerColor = MaterialTheme.colorScheme.primary
            )
        ) {
            Icon(imageVector = Icons.Default.Add, contentDescription = "A√±adir")
            Spacer(Modifier.width(8.dp))
            Text("A√±adir m√°s ventas", fontSize = 16.sp, fontWeight = FontWeight.Medium)
        }

        Spacer(Modifier.height(32.dp))

        // Botones inferiores: Realizar cargo + Carrito
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp),
            horizontalArrangement = Arrangement.spacedBy(12.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            val totalFmt = MonedaUtils.formatearImporte(uiState.totalTicket, moneda)

            Button(
                onClick = { if (uiState.totalTicket > 0) onRealizarCargo(totalFmt) },
                modifier = Modifier
                    .weight(1f)
                    .height(56.dp),
                enabled = uiState.lineasTicket.isNotEmpty() && uiState.totalTicket > 0,
                shape = RoundedCornerShape(12.dp),
                colors = ButtonDefaults.buttonColors(
                    containerColor = MaterialTheme.colorScheme.onBackground,
                    disabledContainerColor = MaterialTheme.colorScheme.surfaceVariant
                )
            ) {
                Text(
                    text = "Realizar cargo  $totalFmt",
                    fontSize = 18.sp,
                    fontWeight = FontWeight.Medium,
                    color = MaterialTheme.colorScheme.background,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis,
                    style = LocalTextStyle.current.copy(fontFeatureSettings = "tnum")
                )
            }

            BotonCarritoVentas(
                ventasViewModel = ventasViewModel,
                onClick = { navController.navigate("carrito/${mercadilloActivo.idMercadillo}") }
            )
        }

        Spacer(Modifier.height(16.dp))
    }
}


// app/src/main/java/es/nuskysoftware/marketsales/ui/composables/PestanaVentaProductos.kt
package es.nuskysoftware.marketsales.ui.composables

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.material3.Badge
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.LocalTextStyle
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import es.nuskysoftware.marketsales.data.local.database.AppDatabase
import es.nuskysoftware.marketsales.data.local.entity.ArticuloEntity
import es.nuskysoftware.marketsales.data.local.entity.CategoriaEntity
import es.nuskysoftware.marketsales.data.local.entity.MercadilloEntity
import es.nuskysoftware.marketsales.data.repository.TipoLinea
import es.nuskysoftware.marketsales.ui.viewmodel.VentasViewModel
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.MonedaUtils
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flowOf

@Composable
fun PestanaVentaProductos(
    ventasViewModel: VentasViewModel,
    navController: NavController,
    mercadilloActivo: MercadilloEntity,
    onRealizarCargo: (totalFormateado: String) -> Unit
) {
    val context = androidx.compose.ui.platform.LocalContext.current
    val db = remember { AppDatabase.getDatabase(context) }
    val articuloDao = remember { db.articuloDao() }
    val categoriaDao = remember { db.categoriaDao() }

    val userId by ConfigurationManager.usuarioLogueado.collectAsState()
    val moneda by ConfigurationManager.moneda.collectAsState()

    var categoriaSeleccionadaId by remember { mutableStateOf<String?>(null) }

    // Categor√≠as
    val categoriasFlow: Flow<List<CategoriaEntity>> = remember(userId) {
        if (userId.isNullOrBlank()) flowOf(emptyList())
        else categoriaDao.getCategoriasByUser(userId!!)
    }
    val categorias by categoriasFlow.collectAsState(initial = emptyList())

    val colorPorCategoria = remember(categorias) {
        categorias.associate { it.idCategoria to parseHexColor(it.colorHex) }
    }

    // Art√≠culos
    val articulosFlow: Flow<List<ArticuloEntity>> = remember(userId, categoriaSeleccionadaId) {
        if (userId.isNullOrBlank()) flowOf(emptyList())
        else if (categoriaSeleccionadaId == null)
            articuloDao.getArticulosByUser(userId!!)
        else
            articuloDao.getArticulosByUserAndCategoria(userId!!, categoriaSeleccionadaId!!)
    }
    val articulos by articulosFlow.collectAsState(initial = emptyList())

    val articulosOrdenados = remember(articulos) {
        articulos.sortedWith(
            compareByDescending<ArticuloEntity> { it.favorito }.thenBy { it.nombre.lowercase() }
        )
    }

    val uiState by ventasViewModel.uiState.collectAsState()
    val totalFmt = MonedaUtils.formatearImporte(uiState.totalTicket, moneda)

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(bottom = 8.dp)
    ) {
        // Chips categor√≠as
        if (categorias.isNotEmpty()) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 12.dp, vertical = 8.dp),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                CategoriaChip(
                    label = "Todas",
                    selected = categoriaSeleccionadaId == null,
                    color = MaterialTheme.colorScheme.primary,
                    onClick = { categoriaSeleccionadaId = null }
                )
                categorias.forEach { cat ->
                    CategoriaChip(
                        label = cat.nombre,
                        selected = categoriaSeleccionadaId == cat.idCategoria,
                        color = colorPorCategoria[cat.idCategoria] ?: MaterialTheme.colorScheme.primary,
                        onClick = { categoriaSeleccionadaId = cat.idCategoria }
                    )
                }
            }
            HorizontalDivider()
        }

        // Grid
        if (articulosOrdenados.isEmpty()) {
            Box(Modifier.weight(1f).fillMaxWidth(), contentAlignment = Alignment.Center) {
                Text(
                    text = if (userId.isNullOrBlank()) "Inicia sesi√≥n para ver productos" else "No hay productos",
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        } else {
            LazyVerticalGrid(
                columns = GridCells.Fixed(3),
                modifier = Modifier
                    .weight(1f)
                    .fillMaxWidth()
                    .padding(8.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                items(articulosOrdenados, key = { it.idArticulo }) { art ->
                    val cantidadEnCarrito = remember(uiState.lineasTicket) {
                        uiState.lineasTicket
                            .filter { it.tipoLinea == TipoLinea.PRODUCTO && it.idProducto == art.idArticulo }
                            .sumOf { it.cantidad }
                    }

                    ProductoCardCuadrada(
                        articulo = art,
                        colorCategoria = colorPorCategoria[art.idCategoria] ?: MaterialTheme.colorScheme.primary,
                        precioFormateado = MonedaUtils.formatearImporte(art.precioVenta, moneda),
                        cantidadCarrito = cantidadEnCarrito,
                        onClick = {
                            ventasViewModel.a√±adirProducto(
                                idProducto = art.idArticulo,
                                descripcion = art.nombre,
                                precio = art.precioVenta
                            )
                        }
                    )
                }
            }
        }

        // Franja inferior
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp),
            horizontalArrangement = Arrangement.spacedBy(12.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Button(
                onClick = { if (uiState.totalTicket > 0) onRealizarCargo(totalFmt) },
                modifier = Modifier
                    .weight(1f)
                    .height(56.dp),
                enabled = uiState.lineasTicket.isNotEmpty() && uiState.totalTicket > 0,
                shape = androidx.compose.foundation.shape.RoundedCornerShape(12.dp),
                colors = ButtonDefaults.buttonColors(
                    containerColor = MaterialTheme.colorScheme.onBackground,
                    disabledContainerColor = MaterialTheme.colorScheme.surfaceVariant
                )
            ) {
                Text(
                    text = "Realizar cargo  $totalFmt",
                    fontSize = 18.sp,
                    fontWeight = FontWeight.Medium,
                    color = MaterialTheme.colorScheme.background,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis,
                    style = LocalTextStyle.current.copy(fontFeatureSettings = "tnum")
                )
            }

            BotonCarritoVentas(
                ventasViewModel = ventasViewModel,
                onClick = { navController.navigate("carrito/${mercadilloActivo.idMercadillo}") }
            )
        }

        Spacer(Modifier.height(8.dp))
    }
}

@Composable
private fun CategoriaChip(
    label: String,
    selected: Boolean,
    color: Color,
    onClick: () -> Unit
) {
    val bg = if (selected) color.copy(alpha = 0.15f) else MaterialTheme.colorScheme.surface
    val fg = if (selected) color else MaterialTheme.colorScheme.onSurfaceVariant
    Box(
        modifier = Modifier
            .background(bg, MaterialTheme.shapes.small)
            .clickable { onClick() }
            .padding(horizontal = 12.dp, vertical = 8.dp)
    ) {
        Text(
            text = label,
            color = fg,
            fontSize = 13.sp,
            fontWeight = if (selected) FontWeight.Bold else FontWeight.Normal
        )
    }
}

@Composable
private fun ProductoCardCuadrada(
    articulo: ArticuloEntity,
    colorCategoria: Color,
    precioFormateado: String,
    cantidadCarrito: Int,
    onClick: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .aspectRatio(1f)
            .clickable { onClick() },
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surface
        ),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Box(Modifier.fillMaxSize()) {
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(8.dp)
            ) {
                Text(
                    text = articulo.nombre,
                    style = MaterialTheme.typography.bodyMedium,
                    maxLines = 2,
                    overflow = TextOverflow.Ellipsis,
                    modifier = Modifier.weight(1f)
                )
                Spacer(Modifier.height(4.dp))
                Text(
                    text = precioFormateado,
                    fontSize = 14.sp,
                    fontWeight = FontWeight.SemiBold,
                    color = MaterialTheme.colorScheme.primary
                )
                Spacer(modifier = Modifier.height(6.dp))
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(3.dp)
                        .background(colorCategoria)
                )
            }

            if (cantidadCarrito > 0) {
                Box(
                    modifier = Modifier
                        .align(Alignment.TopEnd)
                        .padding(6.dp)
                ) {
                    Badge { Text(cantidadCarrito.toString(), fontSize = 10.sp) }
                }
            }
        }
    }
}

private fun parseHexColor(hex: String?): Color =
    try {
        if (hex.isNullOrBlank()) Color(0xFFCCCCCC.toInt())
        else Color(android.graphics.Color.parseColor(hex))
    } catch (_: Exception) {
        Color(0xFFCCCCCC.toInt())
    }



// app/src/main/java/es/nuskysoftware/marketsales/ui/composables/TecladoNumerico.kt
package es.nuskysoftware.marketsales.ui.composables

import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Backspace
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.SolidColor
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp

/**
 * Teclado num√©rico con estilo:
 * - Texto negro (onSurface), fondo blanco (surface)
 * - Borde circular 2dp verde (primary)
 * - Bot√≥n borrar con borde rojo (error)
 */
@Composable
fun TecladoNumerico(
    onDigitClick: (String) -> Unit,
    onClearClick: () -> Unit,
    onDoubleZeroClick: () -> Unit
) {
    val size = 64.dp
    val textSize = 22.sp

    @Composable
    fun Numero(texto: String, isBorrar: Boolean = false, onClick: () -> Unit) {
        val borderColor = if (isBorrar) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.primary
        Button(
            onClick = onClick,
            modifier = Modifier
                .size(size)
                .clip(CircleShape),
            shape = CircleShape,
            border = BorderStroke(2.dp, SolidColor(borderColor)),
            colors = ButtonDefaults.buttonColors(
                containerColor = MaterialTheme.colorScheme.surface,
                contentColor = MaterialTheme.colorScheme.onSurface
            ),
            contentPadding = PaddingValues(0.dp)
        ) {
            if (isBorrar) {
                Icon(
                    imageVector = Icons.Default.Backspace,
                    contentDescription = "Borrar"
                )
            } else {
                Text(text = texto, fontSize = textSize, fontWeight = FontWeight.Medium)
            }
        }
    }

    Column(
        modifier = Modifier.fillMaxWidth(),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
            Numero("1") { onDigitClick("1") }
            Spacer(Modifier.width(12.dp))
            Numero("2") { onDigitClick("2") }
            Spacer(Modifier.width(12.dp))
            Numero("3") { onDigitClick("3") }
        }
        Spacer(Modifier.height(12.dp))
        Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
            Numero("4") { onDigitClick("4") }
            Spacer(Modifier.width(12.dp))
            Numero("5") { onDigitClick("5") }
            Spacer(Modifier.width(12.dp))
            Numero("6") { onDigitClick("6") }
        }
        Spacer(Modifier.height(12.dp))
        Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
            Numero("7") { onDigitClick("7") }
            Spacer(Modifier.width(12.dp))
            Numero("8") { onDigitClick("8") }
            Spacer(Modifier.width(12.dp))
            Numero("9") { onDigitClick("9") }
        }
        Spacer(Modifier.height(12.dp))
        Row(horizontalArrangement = Arrangement.spacedBy(12.dp), verticalAlignment = Alignment.CenterVertically) {
            Numero("00") { onDoubleZeroClick() }
            Spacer(Modifier.width(12.dp))
            Numero("0") { onDigitClick("0") }
            Spacer(Modifier.width(12.dp))
            Numero("‚å´", isBorrar = true) { onClearClick() }
        }
    }
}

/**
 * Variante para PantallaCambio (mismo estilo).
 */
@Composable
fun TecladoNumericoPago(
    onDigitClick: (String) -> Unit,
    onClearClick: () -> Unit
) {
    TecladoNumerico(
        onDigitClick = onDigitClick,
        onClearClick = onClearClick,
        onDoubleZeroClick = { onDigitClick("0"); onDigitClick("0") }
    )
}


// app/src/main/java/es/nuskysoftware/marketsales/ui/pantallas/PantallaAltaMercadillo.kt
// VERSI√ìN COMPLETA CON DATEPICKER, TIMEPICKER Y DEBUG ESTADOS

package es.nuskysoftware.marketsales.ui.pantallas

import es.nuskysoftware.marketsales.data.repository.SyncState
import es.nuskysoftware.marketsales.ui.viewmodel.AuthViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.AuthViewModelFactory


import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import es.nuskysoftware.marketsales.data.local.entity.MercadilloEntity
import es.nuskysoftware.marketsales.ui.viewmodel.MercadilloViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.MercadilloViewModelFactory
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.EstadosMercadillo
import es.nuskysoftware.marketsales.utils.StringResourceManager
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable


fun PantallaAltaMercadillo(
    navController: NavController,
    mercadilloId: String? = null, // null = crear, no-null = editar
    fechaPreseleccionada: String? = null // ‚úÖ NUEVO PAR√ÅMETRO PARA FECHA DEL CALENDARIO
) {
    val context = LocalContext.current
    val mercadilloViewModel: MercadilloViewModel = viewModel(
        factory = MercadilloViewModelFactory(context)
    )

    // Estados del ViewModel
    val uiState by mercadilloViewModel.uiState.collectAsState()
    val currentLanguage by ConfigurationManager.idioma.collectAsState()

    val esEdicion = mercadilloId != null
    val mercadilloParaEditar by mercadilloViewModel.mercadilloParaEditar.collectAsState()

    // Estados del formulario
    var fecha by remember { mutableStateOf(fechaPreseleccionada ?: "") }
    var lugar by remember { mutableStateOf("") }
    var organizador by remember { mutableStateOf("") }
    var esGratis by remember { mutableStateOf(true) }
    var importeSuscripcion by remember { mutableStateOf("") }
    var requiereMesa by remember { mutableStateOf(true) }
    var requiereCarpa by remember { mutableStateOf(true) }
    var hayPuntoLuz by remember { mutableStateOf(false) }
    var horaInicio by remember { mutableStateOf("09:00") }
    var horaFin by remember { mutableStateOf("14:00") }
    var saldoInicial by remember { mutableStateOf("") }

    // ‚úÖ ESTADO PARA DEBUG DE ESTADOS (SOLO EN EDICI√ìN)
    var estadoDebugSeleccionado by remember { mutableStateOf<EstadosMercadillo.Estado?>(null) }

    // ‚úÖ ESTADOS PARA DI√ÅLOGOS DE FECHA Y HORA
    var mostrarDatePicker by remember { mutableStateOf(false) }
    var mostrarTimePickerInicio by remember { mutableStateOf(false) }
    var mostrarTimePickerFin by remember { mutableStateOf(false) }

    val snackbarHostState = remember { SnackbarHostState() }
    val scope = rememberCoroutineScope()

    // Cargar mercadillo para edici√≥n
    LaunchedEffect(mercadilloId) {
        if (mercadilloId != null) {
            mercadilloViewModel.cargarMercadillo(mercadilloId)
        }
    }

    // Actualizar campos cuando se carga el mercadillo para edici√≥n
    LaunchedEffect(mercadilloParaEditar) {
        mercadilloParaEditar?.let { mercadillo ->
            fecha = mercadillo.fecha
            lugar = mercadillo.lugar
            organizador = mercadillo.organizador
            esGratis = mercadillo.esGratis
            importeSuscripcion = if (mercadillo.importeSuscripcion > 0) mercadillo.importeSuscripcion.toString() else ""
            requiereMesa = mercadillo.requiereMesa
            requiereCarpa = mercadillo.requiereCarpa
            hayPuntoLuz = mercadillo.hayPuntoLuz
            horaInicio = mercadillo.horaInicio
            horaFin = mercadillo.horaFin
            saldoInicial = mercadillo.saldoInicial?.toString() ?: ""

            // ‚úÖ CARGAR ESTADO ACTUAL PARA DEBUG
            estadoDebugSeleccionado = EstadosMercadillo.Estado.fromCodigo(mercadillo.estado)
        }
    }

    // Validar fecha preseleccionada
    LaunchedEffect(fechaPreseleccionada) {
        if (fechaPreseleccionada != null && fechaPreseleccionada.isNotBlank()) {
            val validacionFecha = mercadilloViewModel.validarFecha(fechaPreseleccionada)
            if (validacionFecha == null) {
                fecha = fechaPreseleccionada
            }
        }
    }

    // ‚úÖ NUEVA VARIABLE PARA CONTROLAR EL CIERRE
    var deberiaNavegar by remember { mutableStateOf(false) }

    // Manejar mensajes del ViewModel
    LaunchedEffect(uiState.message) {
        uiState.message?.let { message ->
            snackbarHostState.showSnackbar(message)
            mercadilloViewModel.limpiarMensaje()

            // ‚úÖ AMPLIAR LAS CONDICIONES PARA CERRAR LA PANTALLA
            if (message.contains("exitosamente") ||
                message.contains("creado") ||
                message.contains("actualizado") ||
                message.contains("Estado") ||
                message.contains("cambiado") ||
                message.contains("guardado") ||
                message.contains("saved") ||
                message.contains("success")) {

                // ‚úÖ MARCAR QUE DEBE NAVEGAR
                deberiaNavegar = true
            }
        }
    }

    // ‚úÖ EFECTO SEPARADO PARA LA NAVEGACI√ìN
    LaunchedEffect(deberiaNavegar) {
        if (deberiaNavegar) {
            // ‚úÖ PEQUE√ëO DELAY para que se vea el mensaje
            kotlinx.coroutines.delay(800)
            navController.popBackStack()
        }
    }

    LaunchedEffect(uiState.error) {
        uiState.error?.let { error ->
            snackbarHostState.showSnackbar(error)
            mercadilloViewModel.limpiarError()
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        text = if (esEdicion) "Editar Mercadillo" else "Nuevo Mercadillo",
                        fontWeight = FontWeight.Bold
                    )
                },
                // ‚úÖ SIN navigationIcon - NO HAY FLECHA ATR√ÅS
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary
                )
            )
        },
        snackbarHost = { SnackbarHost(snackbarHostState) }
    ) { paddingValues ->

        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {

            // ‚úÖ FORMULARIO CON SCROLL
            LazyColumn(
                modifier = Modifier
                    .weight(1f)
                    .padding(horizontal = 16.dp),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {

                item { Spacer(modifier = Modifier.height(8.dp)) }

                // ‚úÖ Campo fecha CON DATEPICKER
                item {
                    CampoFecha(
                        fecha = fecha,
                        onFechaChange = { fecha = it },
                        onMostrarDatePicker = { mostrarDatePicker = true },
                        esEdicion = esEdicion,
                        mercadilloParaEditar = mercadilloParaEditar
                    )
                }

                // Campo lugar
                item {
                    CampoTexto(
                        valor = lugar,
                        onValueChange = { lugar = it },
                        label = "Lugar",
                        placeholder = "Ej: Plaza Mayor"
                    )
                }

                // Campo organizador
                item {
                    CampoTexto(
                        valor = organizador,
                        onValueChange = { organizador = it },
                        label = "Organizador",
                        placeholder = "Ej: Ayuntamiento"
                    )
                }

                // Configuraci√≥n econ√≥mica
                item {
                    ConfiguracionEconomica(
                        esGratis = esGratis,
                        onEsGratisChange = { esGratis = it },
                        importeSuscripcion = importeSuscripcion,
                        onImporteSuscripcionChange = { importeSuscripcion = it }
                    )
                }

                // Configuraci√≥n log√≠stica
                item {
                    ConfiguracionLogistica(
                        requiereMesa = requiereMesa,
                        onRequiereMesaChange = { requiereMesa = it },
                        requiereCarpa = requiereCarpa,
                        onRequiereCarpaChange = { requiereCarpa = it },
                        hayPuntoLuz = hayPuntoLuz,
                        onHayPuntoLuzChange = { hayPuntoLuz = it }
                    )
                }

                // ‚úÖ Configuraci√≥n horarios CON TIMEPICKERS
                item {
                    ConfiguracionHorarios(
                        horaInicio = horaInicio,
                        onHoraInicioChange = { horaInicio = it },
                        horaFin = horaFin,
                        onHoraFinChange = { horaFin = it },
                        onMostrarTimePickerInicio = { mostrarTimePickerInicio = true },
                        onMostrarTimePickerFin = { mostrarTimePickerFin = true }
                    )
                }

                // Campo saldo inicial
                item {
                    CampoSaldoInicial(
                        saldoInicial = saldoInicial,
                        onSaldoInicialChange = { saldoInicial = it }
                    )
                }

                // ‚úÖ CAMPO DEBUG DE ESTADOS (SOLO EN EDICI√ìN)
                if (esEdicion && mercadilloParaEditar != null) {
                    item {
                        Spacer(modifier = Modifier.height(8.dp))

                        HorizontalDivider(
                            color = Color.Red.copy(alpha = 0.3f),
                            thickness = 2.dp
                        )

                        Spacer(modifier = Modifier.height(16.dp))

                        CampoEstadoDebug(
                            estadoActual = mercadilloParaEditar!!.estado,
                            onEstadoChange = { nuevoEstado ->
                                estadoDebugSeleccionado = nuevoEstado
                            },
                            modifier = Modifier.fillMaxWidth()
                        )
                    }
                }

                item { Spacer(modifier = Modifier.height(24.dp)) }
            }

            // ‚úÖ BOTONES FIJOS EN LA PARTE INFERIOR
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                horizontalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                // Bot√≥n Cancelar
                OutlinedButton(
                    onClick = {
                        // Limpiar el mercadillo para edici√≥n si existe
                        if (esEdicion) {
                            mercadilloViewModel.limpiarMercadilloParaEditar()
                        }
                        navController.popBackStack()
                    },
                    modifier = Modifier.weight(1f),
                    colors = ButtonDefaults.outlinedButtonColors(
                        contentColor = MaterialTheme.colorScheme.error
                    ),
                    border = BorderStroke(1.dp, MaterialTheme.colorScheme.error)
                ) {
                    Text("Cancelar")
                }

                // Bot√≥n Aceptar/Crear
                Button(
                    onClick = {
                        val saldoInicialDouble = saldoInicial.toDoubleOrNull()
                        val importeSuscripcionDouble = if (esGratis) 0.0 else importeSuscripcion.toDoubleOrNull() ?: 0.0

                        scope.launch {
                            try {
                                if (esEdicion && mercadilloId != null) {
                                    // ‚úÖ NUEVA L√ìGICA: Solo cambiar estado si realmente cambi√≥
                                    val estadoOriginal = mercadilloParaEditar?.estado
                                    val estadoNuevo = estadoDebugSeleccionado?.codigo

                                    if (estadoNuevo != null && estadoOriginal != null && estadoNuevo != estadoOriginal) {
                                        // El estado cambi√≥, actualizarlo primero
                                        mercadilloViewModel.cambiarEstadoMercadillo(
                                            mercadilloId = mercadilloId,
                                            nuevoEstado = estadoDebugSeleccionado!!
                                        )
                                    }

                                    // Actualizar el resto de campos
                                    mercadilloViewModel.actualizarMercadillo(
                                        mercadilloId = mercadilloId,
                                        fecha = fecha,
                                        lugar = lugar,
                                        organizador = organizador,
                                        esGratis = esGratis,
                                        importeSuscripcion = importeSuscripcionDouble,
                                        requiereMesa = requiereMesa,
                                        requiereCarpa = requiereCarpa,
                                        hayPuntoLuz = hayPuntoLuz,
                                        horaInicio = horaInicio,
                                        horaFin = horaFin,
                                        saldoInicial = saldoInicialDouble
                                    )
                                } else {
                                    mercadilloViewModel.crearMercadillo(
                                        fecha = fecha,
                                        lugar = lugar,
                                        organizador = organizador,
                                        esGratis = esGratis,
                                        importeSuscripcion = importeSuscripcionDouble,
                                        requiereMesa = requiereMesa,
                                        requiereCarpa = requiereCarpa,
                                        hayPuntoLuz = hayPuntoLuz,
                                        horaInicio = horaInicio,
                                        horaFin = horaFin,
                                        saldoInicial = saldoInicialDouble
                                    )
                                }

                                // ‚úÖ ESPERAR UN MOMENTO Y LUEGO NAVEGAR DE VUELTA
                                kotlinx.coroutines.delay(1000)

                                // ‚úÖ FORZAR LA NAVEGACI√ìN SI NO SE HA CERRADO AUTOM√ÅTICAMENTE
                                if (!deberiaNavegar) {
                                    deberiaNavegar = true
                                }

                            } catch (e: Exception) {
                                // En caso de error, no navegar
                                println("Error al guardar: ${e.message}")
                            }
                        }
                    },
                    enabled = !uiState.loading && fecha.isNotBlank() && lugar.isNotBlank() && organizador.isNotBlank(),
                    modifier = Modifier.weight(1f)
                ) {
                    if (uiState.loading) {
                        CircularProgressIndicator(
                            modifier = Modifier.size(16.dp),
                            color = MaterialTheme.colorScheme.onPrimary
                        )
                    } else {
                        Text(if (esEdicion) "Actualizar" else "Crear")
                    }
                }
            }
        }

        // ‚úÖ DI√ÅLOGOS DE FECHA Y HORA
        if (mostrarDatePicker) {
            DatePickerDialog(
                onDateSelected = { fechaSeleccionada ->
                    fecha = fechaSeleccionada
                    mostrarDatePicker = false
                },
                onDismiss = { mostrarDatePicker = false },
                currentLanguage = currentLanguage
            )
        }

        if (mostrarTimePickerInicio) {
            TimePickerDialog(
                onTimeSelected = { horaSeleccionada ->
                    horaInicio = horaSeleccionada
                    mostrarTimePickerInicio = false
                },
                onDismiss = { mostrarTimePickerInicio = false },
                initialTime = horaInicio,
                currentLanguage = currentLanguage
            )
        }

        if (mostrarTimePickerFin) {
            TimePickerDialog(
                onTimeSelected = { horaSeleccionada ->
                    horaFin = horaSeleccionada
                    mostrarTimePickerFin = false
                },
                onDismiss = { mostrarTimePickerFin = false },
                initialTime = horaFin,
                currentLanguage = currentLanguage
            )
        }
    }
}

// ‚úÖ CAMPO DE SELECCI√ìN DE ESTADO PARA DEBUG
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CampoEstadoDebug(
    estadoActual: Int,
    onEstadoChange: (EstadosMercadillo.Estado) -> Unit,
    modifier: Modifier = Modifier
) {
    var expanded by remember { mutableStateOf(false) }

    // ‚úÖ ESTADO LOCAL que S√ç se actualiza visualmente
    var estadoSeleccionado by remember(estadoActual) {
        mutableStateOf(
            EstadosMercadillo.Estado.fromCodigo(estadoActual)
                ?: EstadosMercadillo.Estado.PROGRAMADO_PARCIAL
        )
    }

    Column(modifier = modifier) {
        Text(
            text = "üîß Estado (DEBUG)",
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Medium,
            color = Color.Red
        )

        Spacer(modifier = Modifier.height(4.dp))

        ExposedDropdownMenuBox(
            expanded = expanded,
            onExpandedChange = { expanded = !expanded }
        ) {
            OutlinedTextField(
                // ‚úÖ USAR EL ESTADO LOCAL en lugar de estadoActual
                value = "${estadoSeleccionado.codigo} - ${estadoSeleccionado.descripcion}",
                onValueChange = { },
                readOnly = true,
                trailingIcon = {
                    ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded)
                },
                colors = OutlinedTextFieldDefaults.colors(
                    focusedBorderColor = Color.Red,
                    unfocusedBorderColor = Color.Red.copy(alpha = 0.5f)
                ),
                modifier = Modifier
                    .menuAnchor()
                    .fillMaxWidth()
            )

            ExposedDropdownMenu(
                expanded = expanded,
                onDismissRequest = { expanded = false }
            ) {
                EstadosMercadillo.obtenerTodosLosEstados().forEach { estado ->
                    DropdownMenuItem(
                        text = {
                            Row(
                                verticalAlignment = Alignment.CenterVertically,
                                modifier = Modifier.fillMaxWidth()
                            ) {
                                // C√≠rculo de color
                                Box(
                                    modifier = Modifier
                                        .size(12.dp)
                                        .background(
                                            EstadosMercadillo.obtenerColor(estado),
                                            CircleShape
                                        )
                                )

                                Spacer(modifier = Modifier.width(8.dp))

                                // Icono
                                Text(
                                    text = EstadosMercadillo.obtenerIcono(estado),
                                    fontSize = 14.sp
                                )

                                Spacer(modifier = Modifier.width(8.dp))

                                // C√≥digo y descripci√≥n
                                Text(
                                    text = "${estado.codigo} - ${estado.descripcion}",
                                    style = MaterialTheme.typography.bodyMedium
                                )
                            }
                        },
                        onClick = {
                            // ‚úÖ ACTUALIZAR AMBOS: local y notificar cambio
                            estadoSeleccionado = estado
                            onEstadoChange(estado)
                            expanded = false
                        }
                    )
                }
            }
        }

        // Advertencia
        Text(
            text = "‚ö†Ô∏è Solo para debugging - Se eliminar√° en producci√≥n",
            style = MaterialTheme.typography.bodySmall,
            color = Color.Red.copy(alpha = 0.7f),
            fontSize = 10.sp
        )
    }
}

// ‚úÖ COMPONENTES AUXILIARES PARA EL FORMULARIO

@Composable
fun CampoFecha(
    fecha: String,
    onFechaChange: (String) -> Unit,
    onMostrarDatePicker: () -> Unit,
    esEdicion: Boolean,
    mercadilloParaEditar: MercadilloEntity?
) {
    Column {
        Text(
            text = "Fecha",
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Medium
        )
        Spacer(modifier = Modifier.height(4.dp))
        OutlinedTextField(
            value = fecha,
            onValueChange = onFechaChange,
            placeholder = { Text("dd-MM-yyyy") },
            modifier = Modifier
                .fillMaxWidth()
                .clickable { onMostrarDatePicker() },
            readOnly = true,
            trailingIcon = {
                IconButton(onClick = onMostrarDatePicker) {
                    Text("üìÖ", fontSize = 18.sp)
                }
            }
        )
    }
}

@Composable
fun CampoTexto(
    valor: String,
    onValueChange: (String) -> Unit,
    label: String,
    placeholder: String
) {
    Column {
        Text(
            text = label,
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Medium
        )
        Spacer(modifier = Modifier.height(4.dp))
        OutlinedTextField(
            value = valor,
            onValueChange = onValueChange,
            placeholder = { Text(placeholder) },
            modifier = Modifier.fillMaxWidth()
        )
    }
}

@Composable
fun ConfiguracionEconomica(
    esGratis: Boolean,
    onEsGratisChange: (Boolean) -> Unit,
    importeSuscripcion: String,
    onImporteSuscripcionChange: (String) -> Unit
) {
    Column {
        Text(
            text = "Configuraci√≥n Econ√≥mica",
            style = MaterialTheme.typography.titleMedium,
            fontWeight = FontWeight.Bold
        )
        Spacer(modifier = Modifier.height(8.dp))

        Row(verticalAlignment = Alignment.CenterVertically) {
            Switch(
                checked = esGratis,
                onCheckedChange = onEsGratisChange
            )
            Spacer(modifier = Modifier.width(8.dp))
            Text("Mercadillo gratuito")
        }

        if (!esGratis) {
            Spacer(modifier = Modifier.height(8.dp))
            OutlinedTextField(
                value = importeSuscripcion,
                onValueChange = onImporteSuscripcionChange,
                label = { Text("Importe suscripci√≥n (‚Ç¨)") },
                placeholder = { Text("0.00") },
                modifier = Modifier.fillMaxWidth()
            )
        }
    }
}

@Composable
fun ConfiguracionLogistica(
    requiereMesa: Boolean,
    onRequiereMesaChange: (Boolean) -> Unit,
    requiereCarpa: Boolean,
    onRequiereCarpaChange: (Boolean) -> Unit,
    hayPuntoLuz: Boolean,
    onHayPuntoLuzChange: (Boolean) -> Unit
) {
    Column {
        Text(
            text = "Configuraci√≥n Log√≠stica",
            style = MaterialTheme.typography.titleMedium,
            fontWeight = FontWeight.Bold
        )
        Spacer(modifier = Modifier.height(8.dp))

        Row(verticalAlignment = Alignment.CenterVertically) {
            Checkbox(checked = requiereMesa, onCheckedChange = onRequiereMesaChange)
            Text("Requiere mesa")
        }

        Row(verticalAlignment = Alignment.CenterVertically) {
            Checkbox(checked = requiereCarpa, onCheckedChange = onRequiereCarpaChange)
            Text("Requiere carpa")
        }

        Row(verticalAlignment = Alignment.CenterVertically) {
            Checkbox(checked = hayPuntoLuz, onCheckedChange = onHayPuntoLuzChange)
            Text("Hay punto de luz")
        }
    }
}

@Composable
fun ConfiguracionHorarios(
    horaInicio: String,
    onHoraInicioChange: (String) -> Unit,
    horaFin: String,
    onHoraFinChange: (String) -> Unit,
    onMostrarTimePickerInicio: () -> Unit,
    onMostrarTimePickerFin: () -> Unit
) {
    Column {
        Text(
            text = "Horarios",
            style = MaterialTheme.typography.titleMedium,
            fontWeight = FontWeight.Bold
        )
        Spacer(modifier = Modifier.height(8.dp))

        Row(modifier = Modifier.fillMaxWidth()) {
            // ‚úÖ Hora inicio CON TIMEPICKER
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = "Hora inicio",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                )
                OutlinedTextField(
                    value = horaInicio,
                    onValueChange = onHoraInicioChange,
                    placeholder = { Text("HH:mm") },
                    modifier = Modifier
                        .fillMaxWidth()
                        .clickable { onMostrarTimePickerInicio() },
                    readOnly = true,
                    trailingIcon = {
                        IconButton(onClick = onMostrarTimePickerInicio) {
                            Text("üïê", fontSize = 18.sp)
                        }
                    }
                )
            }

            Spacer(modifier = Modifier.width(8.dp))

            // ‚úÖ Hora fin CON TIMEPICKER
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = "Hora fin",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                )
                OutlinedTextField(
                    value = horaFin,
                    onValueChange = onHoraFinChange,
                    placeholder = { Text("HH:mm") },
                    modifier = Modifier
                        .fillMaxWidth()
                        .clickable { onMostrarTimePickerFin() },
                    readOnly = true,
                    trailingIcon = {
                        IconButton(onClick = onMostrarTimePickerFin) {
                            Text("üïê", fontSize = 18.sp)
                        }
                    }
                )
            }
        }
    }
}

@Composable
fun CampoSaldoInicial(
    saldoInicial: String,
    onSaldoInicialChange: (String) -> Unit
) {
    Column {
        Text(
            text = "Saldo Inicial (Opcional)",
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Medium
        )
        Spacer(modifier = Modifier.height(4.dp))
        OutlinedTextField(
            value = saldoInicial,
            onValueChange = onSaldoInicialChange,
            placeholder = { Text("0.00") },
            modifier = Modifier.fillMaxWidth(),
            suffix = { Text("‚Ç¨") }
        )
    }
}

// ‚úÖ IMPLEMENTACI√ìN COMPLETA DE DATEPICKER Y TIMEPICKER

@Composable
private fun DatePickerDialog(
    onDateSelected: (String) -> Unit,
    onDismiss: () -> Unit,
    currentLanguage: String
) {
    val calendar = remember {
        Calendar.getInstance().apply {
            firstDayOfWeek = Calendar.MONDAY
            time = Date()
        }
    }

    var selectedDate by remember {
        mutableStateOf(calendar.clone() as Calendar)
    }

    var currentViewDate by remember {
        mutableStateOf(calendar.clone() as Calendar)
    }

    val dateFormat = SimpleDateFormat("dd-MM-yyyy", if (currentLanguage == "es") Locale("es", "ES") else Locale.ENGLISH)

    AlertDialog(
        onDismissRequest = onDismiss,
        title = {
            Text(
                text = StringResourceManager.getString("seleccionar_fecha", currentLanguage),
                style = MaterialTheme.typography.titleLarge,
                fontWeight = FontWeight.Bold
            )
        },
        text = {
            Column(
                horizontalAlignment = Alignment.CenterHorizontally,
                modifier = Modifier.width(320.dp)
            ) {
                SelectedDateDisplay(selectedDate, currentLanguage)

                Spacer(modifier = Modifier.height(16.dp))

                MonthYearNavigation(
                    currentViewDate = currentViewDate,
                    onMonthChange = { newDate ->
                        currentViewDate = newDate
                    },
                    currentLanguage = currentLanguage
                )

                Spacer(modifier = Modifier.height(16.dp))

                CalendarGrid(
                    currentViewDate = currentViewDate,
                    selectedDate = selectedDate,
                    onDateSelected = { newDate ->
                        selectedDate = newDate
                    },
                    currentLanguage = currentLanguage
                )
            }
        },
        confirmButton = {
            Button(
                onClick = {
                    val formattedDate = dateFormat.format(selectedDate.time)
                    onDateSelected(formattedDate)
                }
            ) {
                Text(StringResourceManager.getString("aceptar", currentLanguage))
            }
        },
        dismissButton = {
            OutlinedButton(onClick = onDismiss) {
                Text(StringResourceManager.getString("cancelar", currentLanguage))
            }
        }
    )
}

@Composable
private fun SelectedDateDisplay(
    selectedDate: Calendar,
    currentLanguage: String
) {
    val dayFormat = SimpleDateFormat("EEEE", if (currentLanguage == "es") Locale("es", "ES") else Locale.ENGLISH)
    val displayFormat = if (currentLanguage == "es") {
        SimpleDateFormat("d 'de' MMMM 'de' yyyy", Locale("es", "ES"))
    } else {
        SimpleDateFormat("MMMM d, yyyy", Locale.ENGLISH)
    }

    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.primaryContainer
        )
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(
                text = dayFormat.format(selectedDate.time).replaceFirstChar {
                    if (it.isLowerCase()) it.titlecase() else it.toString()
                },
                style = MaterialTheme.typography.bodyLarge,
                color = MaterialTheme.colorScheme.onPrimaryContainer
            )
            Text(
                text = displayFormat.format(selectedDate.time),
                style = MaterialTheme.typography.headlineSmall,
                color = MaterialTheme.colorScheme.onPrimaryContainer,
                fontWeight = FontWeight.Bold
            )
        }
    }
}

@Composable
private fun MonthYearNavigation(
    currentViewDate: Calendar,
    onMonthChange: (Calendar) -> Unit,
    currentLanguage: String
) {
    val monthFormat = if (currentLanguage == "es") {
        SimpleDateFormat("MMMM yyyy", Locale("es", "ES"))
    } else {
        SimpleDateFormat("MMMM yyyy", Locale.ENGLISH)
    }

    Row(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        IconButton(onClick = {
            val newDate = (currentViewDate.clone() as Calendar).apply {
                add(Calendar.MONTH, -1)
            }
            onMonthChange(newDate)
        }) {
            Text(
                text = "‚Üê",
                fontSize = 20.sp,
                color = MaterialTheme.colorScheme.primary,
                fontWeight = FontWeight.Bold
            )
        }

        Text(
            text = monthFormat.format(currentViewDate.time).replaceFirstChar {
                if (it.isLowerCase()) it.titlecase() else it.toString()
            },
            style = MaterialTheme.typography.titleMedium,
            fontWeight = FontWeight.Bold,
            color = MaterialTheme.colorScheme.onSurface
        )

        IconButton(onClick = {
            val newDate = (currentViewDate.clone() as Calendar).apply {
                add(Calendar.MONTH, 1)
            }
            onMonthChange(newDate)
        }) {
            Text(
                text = "‚Üí",
                fontSize = 20.sp,
                color = MaterialTheme.colorScheme.primary,
                fontWeight = FontWeight.Bold
            )
        }
    }
}

@Composable
private fun CalendarGrid(
    currentViewDate: Calendar,
    selectedDate: Calendar,
    onDateSelected: (Calendar) -> Unit,
    currentLanguage: String
) {
    val diasSemana = if (currentLanguage == "es") {
        listOf(
            StringResourceManager.getString("lunes", currentLanguage),
            StringResourceManager.getString("martes", currentLanguage),
            StringResourceManager.getString("miercoles", currentLanguage),
            StringResourceManager.getString("jueves", currentLanguage),
            StringResourceManager.getString("viernes", currentLanguage),
            StringResourceManager.getString("sabado", currentLanguage),
            StringResourceManager.getString("domingo", currentLanguage)
        )
    } else {
        listOf("M", "T", "W", "T", "F", "S", "S")
    }

    Column {
        Row(modifier = Modifier.fillMaxWidth()) {
            diasSemana.forEach { dia ->
                Text(
                    text = dia,
                    modifier = Modifier.weight(1f),
                    textAlign = TextAlign.Center,
                    style = MaterialTheme.typography.bodySmall,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.primary
                )
            }
        }

        Spacer(modifier = Modifier.height(8.dp))

        val year = currentViewDate.get(Calendar.YEAR)
        val month = currentViewDate.get(Calendar.MONTH)

        val firstDayOfMonth = (currentViewDate.clone() as Calendar).apply {
            set(Calendar.DAY_OF_MONTH, 1)
        }

        val firstDayOfWeek = (firstDayOfMonth.get(Calendar.DAY_OF_WEEK) + 5) % 7
        val daysInMonth = currentViewDate.getActualMaximum(Calendar.DAY_OF_MONTH)
        val totalCells = 42

        LazyVerticalGrid(
            columns = GridCells.Fixed(7),
            modifier = Modifier.height(240.dp),
            verticalArrangement = Arrangement.spacedBy(4.dp),
            horizontalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            items(totalCells) { index ->
                val dayNumber = index - firstDayOfWeek + 1

                if (dayNumber in 1..daysInMonth) {
                    val dayDate = (currentViewDate.clone() as Calendar).apply {
                        set(Calendar.DAY_OF_MONTH, dayNumber)
                    }

                    val isSelected = isSameDay(dayDate, selectedDate)
                    val isToday = isSameDay(dayDate, Calendar.getInstance())

                    DayCell(
                        day = dayNumber,
                        isSelected = isSelected,
                        isToday = isToday,
                        onClick = { onDateSelected(dayDate) }
                    )
                } else {
                    Box(modifier = Modifier.size(40.dp))
                }
            }
        }
    }
}

@Composable
private fun DayCell(
    day: Int,
    isSelected: Boolean,
    isToday: Boolean,
    onClick: () -> Unit
) {
    Box(
        modifier = Modifier
            .size(40.dp)
            .clickable { onClick() }
            .background(
                color = when {
                    isSelected -> MaterialTheme.colorScheme.primary
                    isToday -> MaterialTheme.colorScheme.primaryContainer
                    else -> Color.Transparent
                },
                shape = RoundedCornerShape(8.dp)
            ),
        contentAlignment = Alignment.Center
    ) {
        Text(
            text = day.toString(),
            style = MaterialTheme.typography.bodyMedium,
            color = when {
                isSelected -> MaterialTheme.colorScheme.onPrimary
                isToday -> MaterialTheme.colorScheme.onPrimaryContainer
                else -> MaterialTheme.colorScheme.onSurface
            },
            fontWeight = if (isSelected || isToday) FontWeight.Bold else FontWeight.Normal
        )
    }
}

private fun isSameDay(cal1: Calendar, cal2: Calendar): Boolean {
    return cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR)
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun TimePickerDialog(
    onTimeSelected: (String) -> Unit,
    onDismiss: () -> Unit,
    initialTime: String = "09:00",
    currentLanguage: String
) {
    val timeParts = initialTime.split(":")
    val initialHour = timeParts.getOrNull(0)?.toIntOrNull() ?: 9
    val initialMinute = timeParts.getOrNull(1)?.toIntOrNull() ?: 0

    val timePickerState = rememberTimePickerState(
        initialHour = initialHour,
        initialMinute = initialMinute,
        is24Hour = true
    )

    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text(StringResourceManager.getString("seleccionar_hora", currentLanguage)) },
        text = {
            Column(
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                TimePicker(
                    state = timePickerState,
                    modifier = Modifier.padding(16.dp)
                )
            }
        },
        confirmButton = {
            TextButton(
                onClick = {
                    val hour = String.format("%02d", timePickerState.hour)
                    val minute = String.format("%02d", timePickerState.minute)
                    onTimeSelected("$hour:$minute")
                }
            ) {
                Text(StringResourceManager.getString("aceptar", currentLanguage))
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text(StringResourceManager.getString("cancelar", currentLanguage))
            }
        }
    )
}

// app/src/main/java/es/nuskysoftware/marketsales/ui/pantallas/PantallaArticulos.kt
package es.nuskysoftware.marketsales.ui.pantallas

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.github.skydoves.colorpicker.compose.AlphaSlider
import com.github.skydoves.colorpicker.compose.BrightnessSlider
import com.github.skydoves.colorpicker.compose.HsvColorPicker
import com.github.skydoves.colorpicker.compose.rememberColorPickerController
import es.nuskysoftware.marketsales.R
import es.nuskysoftware.marketsales.data.local.entity.ArticuloEntity
import es.nuskysoftware.marketsales.ui.viewmodel.ArticuloViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.ArticuloViewModelFactory
import es.nuskysoftware.marketsales.ui.viewmodel.CategoriaViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.CategoriaViewModelFactory
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.FooterMarca
import es.nuskysoftware.marketsales.utils.StringResourceManager
import es.nuskysoftware.marketsales.utils.generarColorAleatorioPastel
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PantallaArticulos(
    navController: NavController? = null
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()

    // ViewModels con factory
    val articuloViewModel: ArticuloViewModel = viewModel(
        factory = ArticuloViewModelFactory(context)
    )
    val categoriaViewModel: CategoriaViewModel = viewModel(
        factory = CategoriaViewModelFactory(context)
    )

    // Estados de configuraci√≥n
    val currentLanguage by ConfigurationManager.idioma.collectAsState()
    val esPremium by ConfigurationManager.esPremium.collectAsState()

    // Estados de los ViewModels
    val articulos by articuloViewModel.articulos.collectAsState()
    val categorias by categoriaViewModel.categorias.collectAsState()
    val articuloUiState by articuloViewModel.uiState.collectAsState()
    val tieneArticulos by articuloViewModel.tieneArticulos.collectAsState()

    // Estados locales del formulario
    var mostrarFormulario by remember { mutableStateOf(false) }
    var nombreArticulo by remember { mutableStateOf("") }
    var categoriaSeleccionada by remember { mutableStateOf("") }
    var precioVenta by remember { mutableStateOf("") }
    var precioCoste by remember { mutableStateOf("") }
    var stock by remember { mutableStateOf("") }
    var controlarStock by remember { mutableStateOf(false) }
    var controlarCoste by remember { mutableStateOf(false) }
    var favorito by remember { mutableStateOf(false) }
    var modoEdicion by remember { mutableStateOf<ArticuloEntity?>(null) }

    // Estados de di√°logos
    var mostrarDialogoEliminar by remember { mutableStateOf(false) }
    var articuloAEliminar by remember { mutableStateOf<ArticuloEntity?>(null) }
    var mostrarSelectorCategoria by remember { mutableStateOf(false) }

    // Estados para nueva categor√≠a
    var mostrarDialogoNuevaCategoria by remember { mutableStateOf(false) }
    var nombreNuevaCategoria by remember { mutableStateOf("") }
    var colorNuevaCategoria by remember { mutableStateOf(Color(0xFFD1C4E9)) }
    var mostrarColorPicker by remember { mutableStateOf(false) }

    val snackbarHostState = remember { SnackbarHostState() }

    // Funci√≥n para limpiar formulario
    fun limpiarFormulario() {
        nombreArticulo = ""
        categoriaSeleccionada = ""
        precioVenta = ""
        precioCoste = ""
        stock = ""
        controlarStock = false
        controlarCoste = false
        favorito = false
        modoEdicion = null
    }

    // Manejar mensajes del ViewModel
    LaunchedEffect(articuloUiState.message) {
        articuloUiState.message?.let { message ->
            snackbarHostState.showSnackbar(message)
            articuloViewModel.limpiarMensaje()
        }
    }

    LaunchedEffect(articuloUiState.error) {
        articuloUiState.error?.let { error ->
            snackbarHostState.showSnackbar(error)
            articuloViewModel.limpiarError()
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        StringResourceManager.getString("articulos", currentLanguage),
                        fontWeight = FontWeight.Bold
                    )
                },
                navigationIcon = {
                    IconButton(onClick = { navController?.popBackStack() }) {
                        Icon(
                            painter = painterResource(id = R.drawable.ic_arrow_left),
                            contentDescription = StringResourceManager.getString("volver", currentLanguage)
                        )
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary,
                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary
                )
            )
        },
        snackbarHost = { SnackbarHost(snackbarHostState) },
        floatingActionButton = {
            if (!mostrarFormulario) {
                FloatingActionButton(
                    onClick = {
                        limpiarFormulario()
                        mostrarFormulario = true
                    },
                    shape = CircleShape,
                    containerColor = MaterialTheme.colorScheme.primary,
                    contentColor = MaterialTheme.colorScheme.onPrimary
                ) {
                    Icon(
                        imageVector = Icons.Default.Add,
                        contentDescription = StringResourceManager.getString("add_articulo", currentLanguage)
                    )
                }
            }
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            // ========== FORMULARIO DESLIZANTE ==========
            AnimatedVisibility(visible = mostrarFormulario) {
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    elevation = CardDefaults.cardElevation(defaultElevation = 8.dp),
                    colors = CardDefaults.cardColors(
                        containerColor = MaterialTheme.colorScheme.secondaryContainer
                    ),
                    shape = RoundedCornerShape(16.dp)
                ) {
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(20.dp)
                            .verticalScroll(rememberScrollState())
                    ) {
                        Text(
                            text = if (modoEdicion == null)
                                StringResourceManager.getString("nuevo_articulo", currentLanguage)
                            else
                                StringResourceManager.getString("editar_articulo", currentLanguage),
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold,
                            color = MaterialTheme.colorScheme.onSecondaryContainer
                        )

                        Spacer(modifier = Modifier.height(16.dp))

                        // Campo nombre
                        OutlinedTextField(
                            value = nombreArticulo,
                            onValueChange = { nombreArticulo = it },
                            label = { Text(StringResourceManager.getString("nombre", currentLanguage)) },
                            modifier = Modifier.fillMaxWidth(),
                            isError = nombreArticulo.isNotEmpty() && articuloViewModel.validarNombreArticulo(nombreArticulo) != null,
                            supportingText = {
                                articuloViewModel.validarNombreArticulo(nombreArticulo)?.let { error ->
                                    Text(
                                        text = error,
                                        color = MaterialTheme.colorScheme.error
                                    )
                                }
                            },
                            singleLine = true
                        )

                        Spacer(modifier = Modifier.height(12.dp))

                        // ========== SELECTOR DE CATEGOR√çA MEJORADO ==========
                        OutlinedTextField(
                            value = categorias.find { it.idCategoria == categoriaSeleccionada }?.nombre ?: "",
                            onValueChange = { },
                            label = { Text(StringResourceManager.getString("categoria", currentLanguage)) },
                            modifier = Modifier.fillMaxWidth(),
                            readOnly = true,
                            trailingIcon = {
                                IconButton(onClick = { mostrarSelectorCategoria = true }) {
                                    Icon(
                                        painter = painterResource(id = R.drawable.ic_arrow_down),
                                        contentDescription = "Seleccionar categor√≠a"
                                    )
                                }
                            }
                        )

                        Spacer(modifier = Modifier.height(12.dp))

                        // Precio de venta
                        OutlinedTextField(
                            value = precioVenta,
                            onValueChange = { precioVenta = it },
                            label = { Text(StringResourceManager.getString("precio_venta", currentLanguage)) },
                            modifier = Modifier.fillMaxWidth(),
                            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Decimal),
                            isError = precioVenta.isNotEmpty() && precioVenta.toDoubleOrNull()?.let {
                                articuloViewModel.validarPrecioVenta(it)
                            } != null,
                            supportingText = {
                                precioVenta.toDoubleOrNull()?.let { precio ->
                                    articuloViewModel.validarPrecioVenta(precio)?.let { error ->
                                        Text(
                                            text = error,
                                            color = MaterialTheme.colorScheme.error
                                        )
                                    }
                                }
                            },
                            singleLine = true
                        )

                        Spacer(modifier = Modifier.height(12.dp))

                        // ========== CAMPOS PREMIUM CON RESTRICCIONES ==========

                        // Control de coste
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Checkbox(
                                checked = controlarCoste,
                                onCheckedChange = {
                                    if (esPremium) {
                                        controlarCoste = it
                                    }
                                },
                                enabled = esPremium
                            )
                            Column(modifier = Modifier.weight(1f)) {
                                Text(
                                    text = StringResourceManager.getString("controlar_coste", currentLanguage),
                                    color = if (esPremium) MaterialTheme.colorScheme.onSurface else MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f)
                                )
                                if (!esPremium) {
                                    Text(
                                        text = StringResourceManager.getString("solo_premium_coste", currentLanguage),
                                        style = MaterialTheme.typography.bodySmall,
                                        color = MaterialTheme.colorScheme.error.copy(alpha = 0.7f)
                                    )
                                }
                            }
                        }

                        if (controlarCoste && esPremium) {
                            Spacer(modifier = Modifier.height(8.dp))
                            OutlinedTextField(
                                value = precioCoste,
                                onValueChange = { precioCoste = it },
                                label = { Text(StringResourceManager.getString("precio_coste", currentLanguage)) },
                                modifier = Modifier.fillMaxWidth(),
                                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Decimal),
                                singleLine = true
                            )
                        }

                        Spacer(modifier = Modifier.height(12.dp))

                        // Control de stock
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Checkbox(
                                checked = controlarStock,
                                onCheckedChange = {
                                    if (esPremium) {
                                        controlarStock = it
                                    }
                                },
                                enabled = esPremium
                            )
                            Column(modifier = Modifier.weight(1f)) {
                                Text(
                                    text = StringResourceManager.getString("controlar_stock", currentLanguage),
                                    color = if (esPremium) MaterialTheme.colorScheme.onSurface else MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f)
                                )
                                if (!esPremium) {
                                    Text(
                                        text = StringResourceManager.getString("solo_premium_stock", currentLanguage),
                                        style = MaterialTheme.typography.bodySmall,
                                        color = MaterialTheme.colorScheme.error.copy(alpha = 0.7f)
                                    )
                                }
                            }
                        }

                        if (controlarStock && esPremium) {
                            Spacer(modifier = Modifier.height(8.dp))
                            OutlinedTextField(
                                value = stock,
                                onValueChange = { stock = it },
                                label = { Text(StringResourceManager.getString("stock", currentLanguage)) },
                                modifier = Modifier.fillMaxWidth(),
                                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                                singleLine = true
                            )
                        }

                        Spacer(modifier = Modifier.height(12.dp))

                        // Favorito (disponible para todos)
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Checkbox(
                                checked = favorito,
                                onCheckedChange = { favorito = it }
                            )
                            Text(
                                text = StringResourceManager.getString("marcar_favorito", currentLanguage),
                                modifier = Modifier.weight(1f)
                            )
                        }

                        Spacer(modifier = Modifier.height(20.dp))

                        // Botones
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.spacedBy(12.dp)
                        ) {
                            Button(
                                onClick = {
                                    scope.launch {
                                        val validacionNombre = articuloViewModel.validarNombreArticulo(nombreArticulo)
                                        if (validacionNombre != null) {
                                            snackbarHostState.showSnackbar(validacionNombre)
                                            return@launch
                                        }

                                        val precio = precioVenta.toDoubleOrNull()
                                        if (precio == null) {
                                            snackbarHostState.showSnackbar("Precio de venta inv√°lido")
                                            return@launch
                                        }

                                        if (categoriaSeleccionada.isEmpty()) {
                                            snackbarHostState.showSnackbar("Selecciona una categor√≠a")
                                            return@launch
                                        }

                                        if (modoEdicion == null) {
                                            // Crear nuevo art√≠culo
                                            articuloViewModel.crearArticulo(
                                                nombre = nombreArticulo,
                                                idCategoria = categoriaSeleccionada,
                                                precioVenta = precio,
                                                precioCoste = if (controlarCoste && esPremium && precioCoste.isNotEmpty()) precioCoste.toDoubleOrNull() else null,
                                                stock = if (controlarStock && esPremium && stock.isNotEmpty()) stock.toIntOrNull() else null,
                                                controlarStock = controlarStock && esPremium,
                                                controlarCoste = controlarCoste && esPremium,
                                                favorito = favorito
                                            )
                                        } else {
                                            // Actualizar art√≠culo existente
                                            val articuloActualizado = modoEdicion!!.copy(
                                                nombre = nombreArticulo,
                                                idCategoria = categoriaSeleccionada,
                                                precioVenta = precio,
                                                precioCoste = if (controlarCoste && esPremium && precioCoste.isNotEmpty()) precioCoste.toDoubleOrNull() else null,
                                                stock = if (controlarStock && esPremium && stock.isNotEmpty()) stock.toIntOrNull() else null,
                                                controlarStock = controlarStock && esPremium,
                                                controlarCoste = controlarCoste && esPremium,
                                                favorito = favorito
                                            )
                                            articuloViewModel.actualizarArticulo(articuloActualizado)
                                        }

                                        // Limpiar y cerrar formulario
                                        limpiarFormulario()
                                        mostrarFormulario = false
                                    }
                                },
                                enabled = !articuloUiState.loading && nombreArticulo.isNotBlank() && precioVenta.isNotBlank(),
                                modifier = Modifier.weight(1f)
                            ) {
                                if (articuloUiState.loading) {
                                    CircularProgressIndicator(
                                        modifier = Modifier.size(16.dp),
                                        strokeWidth = 2.dp,
                                        color = MaterialTheme.colorScheme.onPrimary
                                    )
                                } else {
                                    Text(StringResourceManager.getString("guardar", currentLanguage))
                                }
                            }

                            OutlinedButton(
                                onClick = {
                                    limpiarFormulario()
                                    mostrarFormulario = false
                                },
                                modifier = Modifier.weight(1f)
                            ) {
                                Text(StringResourceManager.getString("cancelar", currentLanguage))
                            }
                        }
                    }
                }
            }

            // ========== CONTENIDO PRINCIPAL ==========
            Box(
                modifier = Modifier
                    .weight(1f)
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp)
            ) {
                if (!tieneArticulos) {
                    // Estado vac√≠o
                    Column(
                        modifier = Modifier.fillMaxSize(),
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.Center
                    ) {
                        Icon(
                            painter = painterResource(id = R.drawable.ic_list),
                            contentDescription = null,
                            modifier = Modifier.size(64.dp),
                            tint = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.4f)
                        )

                        Spacer(modifier = Modifier.height(16.dp))

                        Text(
                            text = StringResourceManager.getString("pulsa_crear_primer_articulo", currentLanguage),
                            style = MaterialTheme.typography.titleMedium,
                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f),
                            textAlign = TextAlign.Center
                        )
                    }
                } else {
                    // Lista de art√≠culos en Cards
                    LazyColumn(
                        modifier = Modifier.fillMaxSize(),
                        verticalArrangement = Arrangement.spacedBy(8.dp),
                        contentPadding = PaddingValues(vertical = 8.dp)
                    ) {
                        items(articulos) { articulo ->
                            ArticuloCard(
                                articulo = articulo,
                                categorias = categorias,
                                esPremium = esPremium,
                                onEditar = {
                                    // Cargar datos en el formulario
                                    modoEdicion = articulo
                                    nombreArticulo = articulo.nombre
                                    categoriaSeleccionada = articulo.idCategoria
                                    precioVenta = articulo.precioVenta.toString()
                                    precioCoste = articulo.precioCoste?.toString() ?: ""
                                    stock = articulo.stock?.toString() ?: ""
                                    controlarStock = articulo.controlarStock
                                    controlarCoste = articulo.controlarCoste
                                    favorito = articulo.favorito
                                    mostrarFormulario = true
                                },
                                onEliminar = {
                                    articuloAEliminar = articulo
                                    mostrarDialogoEliminar = true
                                }
                            )
                        }
                    }
                }
            }

            // ========== FOOTER ==========
            FooterMarca()
        }
    }

    // ========== DI√ÅLOGOS ==========

    // ========== SELECTOR DE CATEGOR√çA MEJORADO ==========
    if (mostrarSelectorCategoria) {
        AlertDialog(
            onDismissRequest = { mostrarSelectorCategoria = false },
            title = { Text(StringResourceManager.getString("seleccionar_categoria", currentLanguage)) },
            text = {
                LazyColumn {
                    // Opci√≥n para crear nueva categor√≠a
                    item {
                        Card(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 4.dp)
                                .clickable {
                                    mostrarSelectorCategoria = false
                                    mostrarDialogoNuevaCategoria = true
                                },
                            colors = CardDefaults.cardColors(
                                containerColor = MaterialTheme.colorScheme.primaryContainer
                            )
                        ) {
                            Row(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .padding(16.dp),
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Icon(
                                    imageVector = Icons.Default.Add,
                                    contentDescription = "Crear categor√≠a",
                                    tint = MaterialTheme.colorScheme.onPrimaryContainer
                                )
                                Spacer(modifier = Modifier.width(12.dp))
                                Text(
                                    text = StringResourceManager.getString("crear_nueva_categoria", currentLanguage),
                                    color = MaterialTheme.colorScheme.onPrimaryContainer,
                                    fontWeight = FontWeight.Medium
                                )
                            }
                        }
                    }

                    // Lista de categor√≠as existentes
                    items(categorias) { categoria ->
                        TextButton(
                            onClick = {
                                categoriaSeleccionada = categoria.idCategoria
                                mostrarSelectorCategoria = false
                            },
                            modifier = Modifier.fillMaxWidth()
                        ) {
                            Row(
                                verticalAlignment = Alignment.CenterVertically,
                                modifier = Modifier.fillMaxWidth()
                            ) {
                                // C√≠rculo de color
                                Box(
                                    modifier = Modifier
                                        .size(16.dp)
                                        .clip(CircleShape)
                                        .background(Color(android.graphics.Color.parseColor(categoria.colorHex)))
                                )
                                Spacer(modifier = Modifier.width(12.dp))
                                Text(categoria.nombre)
                            }
                        }
                    }

                    if (categorias.isEmpty()) {
                        item {
                            Text(
                                text = StringResourceManager.getString("sin_categorias", currentLanguage),
                                color = MaterialTheme.colorScheme.onSurfaceVariant,
                                modifier = Modifier.padding(16.dp)
                            )
                        }
                    }
                }
            },
            confirmButton = {
                TextButton(onClick = { mostrarSelectorCategoria = false }) {
                    Text(StringResourceManager.getString("cancelar", currentLanguage))
                }
            }
        )
    }

    // ========== DI√ÅLOGO NUEVA CATEGOR√çA ==========
    if (mostrarDialogoNuevaCategoria) {
        AlertDialog(
            onDismissRequest = {
                mostrarDialogoNuevaCategoria = false
                nombreNuevaCategoria = ""
                colorNuevaCategoria = Color(0xFFD1C4E9)
            },
            title = { Text(StringResourceManager.getString("nueva_categoria", currentLanguage)) },
            text = {
                Column {
                    OutlinedTextField(
                        value = nombreNuevaCategoria,
                        onValueChange = { nombreNuevaCategoria = it },
                        label = { Text(StringResourceManager.getString("nombre", currentLanguage)) },
                        modifier = Modifier.fillMaxWidth(),
                        singleLine = true
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    // Selector de color
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable { mostrarColorPicker = true }
                            .padding(vertical = 8.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = StringResourceManager.getString("seleccionar_color", currentLanguage),
                            modifier = Modifier.weight(1f)
                        )
                        Spacer(modifier = Modifier.width(16.dp))
                        Box(
                            modifier = Modifier
                                .size(32.dp)
                                .clip(CircleShape)
                                .background(colorNuevaCategoria)
                        )
                    }
                }
            },
            confirmButton = {
                TextButton(
                    onClick = {
                        if (nombreNuevaCategoria.isNotBlank()) {
                            scope.launch {
                                val colorFinal = if (colorNuevaCategoria == Color(0xFFD1C4E9)) {
                                    generarColorAleatorioPastel()
                                } else colorNuevaCategoria

                                val colorHex = String.format("#%06X", 0xFFFFFF and colorFinal.toArgb())

                                categoriaViewModel.crearCategoria(nombreNuevaCategoria, colorHex)

                                // Limpiar y cerrar
                                nombreNuevaCategoria = ""
                                colorNuevaCategoria = Color(0xFFD1C4E9)
                                mostrarDialogoNuevaCategoria = false
                            }
                        }
                    },
                    enabled = nombreNuevaCategoria.isNotBlank()
                ) {
                    Text(StringResourceManager.getString("crear", currentLanguage))
                }
            },
            dismissButton = {
                TextButton(onClick = {
                    mostrarDialogoNuevaCategoria = false
                    nombreNuevaCategoria = ""
                    colorNuevaCategoria = Color(0xFFD1C4E9)
                }) {
                    Text(StringResourceManager.getString("cancelar", currentLanguage))
                }
            }
        )
    }

    // ========== SELECTOR DE COLOR ==========
    if (mostrarColorPicker) {
        ColorPickerDialog(
            onColorElegido = { color ->
                colorNuevaCategoria = color
                mostrarColorPicker = false
            },
            onCancelar = { mostrarColorPicker = false }
        )
    }

    // Confirmaci√≥n eliminar
    if (mostrarDialogoEliminar && articuloAEliminar != null) {
        AlertDialog(
            onDismissRequest = {
                mostrarDialogoEliminar = false
                articuloAEliminar = null
            },
            title = {
                Text(StringResourceManager.getString("eliminar_articulo", currentLanguage))
            },
            text = {
                Text(
                    StringResourceManager.getString("confirmar_eliminar_articulo", currentLanguage)
                        .replace("{nombre}", articuloAEliminar!!.nombre)
                )
            },
            confirmButton = {
                Button(
                    onClick = {
                        articuloViewModel.eliminarArticulo(articuloAEliminar!!)
                        mostrarDialogoEliminar = false
                        articuloAEliminar = null
                    },
                    colors = ButtonDefaults.buttonColors(
                        containerColor = MaterialTheme.colorScheme.error
                    )
                ) {
                    Text(
                        StringResourceManager.getString("eliminar", currentLanguage),
                        color = MaterialTheme.colorScheme.onError
                    )
                }
            },
            dismissButton = {
                OutlinedButton(
                    onClick = {
                        mostrarDialogoEliminar = false
                        articuloAEliminar = null
                    }
                ) {
                    Text(StringResourceManager.getString("cancelar", currentLanguage))
                }
            }
        )
    }
}


@Composable
private fun ArticuloCard(
    articulo: ArticuloEntity,
    categorias: List<es.nuskysoftware.marketsales.data.local.entity.CategoriaEntity>,
    esPremium: Boolean,
    onEditar: () -> Unit,
    onEliminar: () -> Unit
) {
    val categoria = categorias.find { it.idCategoria == articulo.idCategoria }

    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surface
        ),
        shape = RoundedCornerShape(12.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(modifier = Modifier.weight(1f)) {
                // Nombre del art√≠culo
                Text(
                    text = articulo.nombre,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Medium,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )

                Spacer(modifier = Modifier.height(4.dp))

                // Categor√≠a
                Text(
                    text = categoria?.nombre ?: "Sin categor√≠a",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )

                // Precio de venta
                Text(
                    text = "Precio: ${articulo.precioVenta} ‚Ç¨",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurface
                )

                // Informaci√≥n Premium
                if (esPremium) {
                    if (articulo.controlarStock && articulo.stock != null) {
                        Text(
                            text = "Stock: ${articulo.stock}",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                    if (articulo.controlarCoste && articulo.precioCoste != null) {
                        Text(
                            text = "Coste: ${articulo.precioCoste} ‚Ç¨",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }

                // Indicador favorito
                if (articulo.favorito) {
                    Text(
                        text = "‚≠ê Favorito",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.primary
                    )
                }
            }

            // Botones de acci√≥n
            Row(
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                IconButton(onClick = onEditar) {
                    Icon(
                        painter = painterResource(id = R.drawable.ic_edit),
                        contentDescription = "Editar",
                        tint = MaterialTheme.colorScheme.primary
                    )
                }

                IconButton(onClick = onEliminar) {
                    Icon(
                        painter = painterResource(id = R.drawable.ic_delete),
                        contentDescription = "Eliminar",
                        tint = MaterialTheme.colorScheme.error
                    )
                }
            }
        }
    }
}


// app/src/main/java/es/nuskysoftware/marketsales/ui/pantallas/PantallaCambio.kt
package es.nuskysoftware.marketsales.ui.pantallas

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import es.nuskysoftware.marketsales.ui.composables.TecladoNumericoPago
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.MonedaUtils

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PantallaCambio(
    totalFormateado: String,
    onBack: () -> Unit,
    onConfirmarCambio: (entregado: Double) -> Unit
) {
    val moneda by ConfigurationManager.moneda.collectAsState()
    val total = remember(totalFormateado) {
        // totalFormateado ya viene con coma y s√≠mbolo, extraemos double
        totalFormateado
            .replace(".", "")        // miles
            .replace(",", ".")       // decimal
            .replace(Regex("[^0-9\\.]"), "")
            .toDoubleOrNull() ?: 0.0
    }

    var entregadoRaw by remember { mutableStateOf("0,00") }

    fun parseDouble(es: String): Double =
        es.replace(".", "").replace(",", ".").toDoubleOrNull() ?: 0.0

    val entregado = parseDouble(entregadoRaw)
    val cambio = (entregado - total).coerceAtLeast(0.0)

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Cambio", fontWeight = FontWeight.Bold, fontSize = 22.sp) },
                navigationIcon = {
                    TextButton(onClick = onBack) { Text("‚Üê") }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary,
                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary
                )
            )
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            // Total grande
            Text("Total", fontSize = 18.sp, color = MaterialTheme.colorScheme.onSurfaceVariant)
            Text(
                MonedaUtils.formatearImporte(total, moneda),
                fontSize = 32.sp,
                fontWeight = FontWeight.ExtraBold,
                color = MaterialTheme.colorScheme.primary
            )

            Spacer(Modifier.height(12.dp))

            // Entregado
            Text("Entregado", fontSize = 18.sp, color = MaterialTheme.colorScheme.onSurfaceVariant)
            TextoImporteGrande(importe = entregadoRaw)

            Spacer(Modifier.height(12.dp))

            // Teclado num√©rico (mismo estilo)
            TecladoNumericoPago(
                onDigitClick = { d ->
                    // Reutilizamos misma l√≥gica que tu VM (2 decimales desplazando)
                    val solo = entregadoRaw.replace(",", "").replace(".", "")
                    val nuevo = (solo + d).takeLast(7).padStart(3, '0')
                    val ent = nuevo.dropLast(2).toLongOrNull()?.toString() ?: "0"
                    val dec = nuevo.takeLast(2)
                    entregadoRaw = "$ent,$dec"
                },
                onClearClick = {
                    val solo = entregadoRaw.replace(",", "").replace(".", "")
                    entregadoRaw = if (solo.length <= 1) "0,00" else {
                        val s = solo.dropLast(1).padStart(3, '0')
                        val ent = s.dropLast(2).toLongOrNull()?.toString() ?: "0"
                        val dec = s.takeLast(2)
                        "$ent,$dec"
                    }
                }
            )

            Spacer(Modifier.height(16.dp))

            // Cambio
            Text("Cambio", fontSize = 18.sp, color = MaterialTheme.colorScheme.onSurfaceVariant)
            Text(
                MonedaUtils.formatearImporte(cambio, moneda),
                fontSize = 36.sp,
                fontWeight = FontWeight.ExtraBold,
                color = MaterialTheme.colorScheme.primary
            )

            Spacer(Modifier.height(20.dp))

            Button(
                onClick = { onConfirmarCambio(entregado) },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(64.dp),
                shape = RoundedCornerShape(12.dp)
            ) {
                Text("Confirmar", fontSize = 18.sp, fontWeight = FontWeight.Medium)
            }
        }
    }
}

@Composable
private fun TextoImporteGrande(importe: String) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),
        shape = RoundedCornerShape(12.dp)
    ) {
        Text(
            text = importe,
            modifier = Modifier.padding(vertical = 12.dp).fillMaxWidth(),
            textAlign = TextAlign.Center,
            fontSize = 28.sp,
            fontWeight = FontWeight.Bold
        )
    }
}



// app/src/main/java/es/nuskysoftware/marketsales/ui/pantallas/PantallaCategorias.kt
package es.nuskysoftware.marketsales.ui.pantallas

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.github.skydoves.colorpicker.compose.AlphaSlider
import com.github.skydoves.colorpicker.compose.BrightnessSlider
import com.github.skydoves.colorpicker.compose.HsvColorPicker
import com.github.skydoves.colorpicker.compose.rememberColorPickerController
import es.nuskysoftware.marketsales.R
import es.nuskysoftware.marketsales.data.local.entity.CategoriaEntity
import es.nuskysoftware.marketsales.ui.viewmodel.CategoriaViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.CategoriaViewModelFactory
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.FooterMarca
import es.nuskysoftware.marketsales.utils.StringResourceManager
import es.nuskysoftware.marketsales.utils.generarColorAleatorioPastel
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PantallaCategorias(
    navController: NavController? = null
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()

    // ViewModel con factory
    val categoriaViewModel: CategoriaViewModel = viewModel(
        factory = CategoriaViewModelFactory(context)
    )

    // Estados de configuraci√≥n
    val currentLanguage by ConfigurationManager.idioma.collectAsState()

    // Estados del ViewModel
    val categorias by categoriaViewModel.categorias.collectAsState()
    val uiState by categoriaViewModel.uiState.collectAsState()
    val tieneCategorias by categoriaViewModel.tieneCategorias.collectAsState()

    // Estados locales
    var mostrarFormulario by remember { mutableStateOf(false) }
    var nombreCategoria by remember { mutableStateOf("") }
    var colorSeleccionado by remember { mutableStateOf(Color(0xFFD1C4E9)) }
    var modoEdicion by remember { mutableStateOf<CategoriaEntity?>(null) }

    var mostrarColorPicker by remember { mutableStateOf(false) }
    var mostrarDialogoEliminar by remember { mutableStateOf(false) }
    var categoriaAEliminar by remember { mutableStateOf<CategoriaEntity?>(null) }

    val snackbarHostState = remember { SnackbarHostState() }

    // Manejar mensajes del ViewModel
    LaunchedEffect(uiState.message) {
        uiState.message?.let { message ->
            snackbarHostState.showSnackbar(message)
            categoriaViewModel.limpiarMensaje()
        }
    }

    LaunchedEffect(uiState.error) {
        uiState.error?.let { error ->
            snackbarHostState.showSnackbar(error)
            categoriaViewModel.limpiarError()
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        StringResourceManager.getString("categorias", currentLanguage),
                        fontWeight = FontWeight.Bold
                    )
                },
                navigationIcon = {
                    IconButton(onClick = { navController?.popBackStack() }) {
                        Icon(
                            painter = painterResource(id = R.drawable.ic_arrow_left),
                            contentDescription = StringResourceManager.getString("volver", currentLanguage)
                        )
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary,
                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary
                )
            )
        },
        snackbarHost = { SnackbarHost(snackbarHostState) },
        floatingActionButton = {
            if (!mostrarFormulario) {
                FloatingActionButton(
                    onClick = {
                        mostrarFormulario = true
                        nombreCategoria = ""
                        colorSeleccionado = Color(0xFFD1C4E9)
                        modoEdicion = null
                    },
                    shape = CircleShape,
                    containerColor = MaterialTheme.colorScheme.primary,
                    contentColor = MaterialTheme.colorScheme.onPrimary
                ) {
                    Icon(
                        imageVector = Icons.Default.Add,
                        contentDescription = StringResourceManager.getString("add_categoria", currentLanguage)
                    )
                }
            }
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            // ========== FORMULARIO DESLIZANTE ==========
            AnimatedVisibility(visible = mostrarFormulario) {
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    elevation = CardDefaults.cardElevation(defaultElevation = 8.dp),
                    colors = CardDefaults.cardColors(
                        containerColor = MaterialTheme.colorScheme.secondaryContainer
                    ),
                    shape = RoundedCornerShape(16.dp)
                ) {
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(20.dp)
                    ) {
                        Text(
                            text = if (modoEdicion == null)
                                StringResourceManager.getString("nueva_categoria", currentLanguage)
                            else
                                StringResourceManager.getString("editar_categoria", currentLanguage),
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold,
                            color = MaterialTheme.colorScheme.onSecondaryContainer
                        )

                        Spacer(modifier = Modifier.height(16.dp))

                        // Campo nombre
                        OutlinedTextField(
                            value = nombreCategoria,
                            onValueChange = { nombreCategoria = it },
                            label = { Text(StringResourceManager.getString("nombre", currentLanguage)) },
                            modifier = Modifier.fillMaxWidth(),
                            isError = nombreCategoria.isNotEmpty() && categoriaViewModel.validarNombreCategoria(nombreCategoria) != null,
                            supportingText = {
                                categoriaViewModel.validarNombreCategoria(nombreCategoria)?.let { error ->
                                    Text(
                                        text = error,
                                        color = MaterialTheme.colorScheme.error
                                    )
                                }
                            },
                            singleLine = true
                        )

                        Spacer(modifier = Modifier.height(16.dp))

                        // Selector de color
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .clickable { mostrarColorPicker = true }
                                .padding(vertical = 8.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(
                                text = StringResourceManager.getString("seleccionar_color", currentLanguage),
                                style = MaterialTheme.typography.bodyLarge,
                                color = MaterialTheme.colorScheme.onSecondaryContainer,
                                modifier = Modifier.weight(1f)
                            )

                            Spacer(modifier = Modifier.width(16.dp))

                            Box(
                                modifier = Modifier
                                    .size(40.dp)
                                    .clip(CircleShape)
                                    .background(colorSeleccionado)
                            )
                        }

                        Spacer(modifier = Modifier.height(20.dp))

                        // Botones
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.spacedBy(12.dp)
                        ) {
                            Button(
                                onClick = {
                                    scope.launch {
                                        val validacionNombre = categoriaViewModel.validarNombreCategoria(nombreCategoria)
                                        if (validacionNombre != null) {
                                            snackbarHostState.showSnackbar(validacionNombre)
                                            return@launch
                                        }

                                        val colorFinal = if (colorSeleccionado == Color(0xFFD1C4E9)) {
                                            generarColorAleatorioPastel()
                                        } else colorSeleccionado

                                        val colorHex = String.format("#%06X", 0xFFFFFF and colorFinal.toArgb())

                                        if (modoEdicion == null) {
                                            categoriaViewModel.crearCategoria(nombreCategoria, colorHex)
                                        } else {
                                            val categoriaEditada = modoEdicion!!.copy(
                                                nombre = nombreCategoria,
                                                colorHex = colorHex
                                            )
                                            categoriaViewModel.actualizarCategoria(categoriaEditada)
                                        }

                                        // Limpiar formulario
                                        nombreCategoria = ""
                                        colorSeleccionado = Color(0xFFD1C4E9)
                                        modoEdicion = null
                                        mostrarFormulario = false
                                    }
                                },
                                enabled = !uiState.loading && nombreCategoria.isNotBlank(),
                                modifier = Modifier.weight(1f)
                            ) {
                                if (uiState.loading) {
                                    CircularProgressIndicator(
                                        modifier = Modifier.size(16.dp),
                                        strokeWidth = 2.dp,
                                        color = MaterialTheme.colorScheme.onPrimary
                                    )
                                } else {
                                    Text(StringResourceManager.getString("guardar", currentLanguage))
                                }
                            }

                            OutlinedButton(
                                onClick = {
                                    mostrarFormulario = false
                                    nombreCategoria = ""
                                    colorSeleccionado = Color(0xFFD1C4E9)
                                    modoEdicion = null
                                },
                                modifier = Modifier.weight(1f)
                            ) {
                                Text(StringResourceManager.getString("cancelar", currentLanguage))
                            }
                        }
                    }
                }
            }

            // ========== CONTENIDO PRINCIPAL ==========
            Box(
                modifier = Modifier
                    .weight(1f)
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp)
            ) {
                if (!tieneCategorias) {
                    // Estado vac√≠o
                    Column(
                        modifier = Modifier.fillMaxSize(),
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.Center
                    ) {
                        Icon(
                            painter = painterResource(id = R.drawable.ic_category),
                            contentDescription = null,
                            modifier = Modifier.size(64.dp),
                            tint = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.4f)
                        )

                        Spacer(modifier = Modifier.height(16.dp))

                        Text(
                            text = StringResourceManager.getString("pulsa_crear_primera_categoria", currentLanguage),
                            style = MaterialTheme.typography.titleMedium,
                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f),
                            textAlign = TextAlign.Center
                        )
                    }
                } else {
                    // Lista de categor√≠as en Cards
                    LazyColumn(
                        modifier = Modifier.fillMaxSize(),
                        verticalArrangement = Arrangement.spacedBy(8.dp),
                        contentPadding = PaddingValues(vertical = 8.dp)
                    ) {
                        items(categorias) { categoria ->
                            CategoriaCard(
                                categoria = categoria,
                                onEditar = {
                                    mostrarFormulario = true
                                    nombreCategoria = categoria.nombre
                                    colorSeleccionado = Color(android.graphics.Color.parseColor(categoria.colorHex))
                                    modoEdicion = categoria
                                },
                                onEliminar = {
                                    categoriaAEliminar = categoria
                                    mostrarDialogoEliminar = true
                                }
                            )
                        }
                    }
                }
            }

            // ========== FOOTER ==========
            FooterMarca()
        }
    }

    // ========== DI√ÅLOGOS ==========

    // Selector de color
    if (mostrarColorPicker) {
        ColorPickerDialog(
            onColorElegido = { color ->
                colorSeleccionado = color
                mostrarColorPicker = false
            },
            onCancelar = { mostrarColorPicker = false }
        )
    }

    // Confirmaci√≥n eliminar
    if (mostrarDialogoEliminar && categoriaAEliminar != null) {
        AlertDialog(
            onDismissRequest = {
                mostrarDialogoEliminar = false
                categoriaAEliminar = null
            },
            title = {
                Text(StringResourceManager.getString("eliminar_categoria", currentLanguage))
            },
            text = {
                Text(
                    StringResourceManager.getString("confirmar_eliminar_categoria", currentLanguage)
                        .replace("{nombre}", categoriaAEliminar!!.nombre)
                )
            },
            confirmButton = {
                Button(
                    onClick = {
                        categoriaViewModel.eliminarCategoria(categoriaAEliminar!!)
                        mostrarDialogoEliminar = false
                        categoriaAEliminar = null
                    },
                    colors = ButtonDefaults.buttonColors(
                        containerColor = MaterialTheme.colorScheme.error
                    )
                ) {
                    Text(
                        StringResourceManager.getString("eliminar", currentLanguage),
                        color = MaterialTheme.colorScheme.onError
                    )
                }
            },
            dismissButton = {
                OutlinedButton(
                    onClick = {
                        mostrarDialogoEliminar = false
                        categoriaAEliminar = null
                    }
                ) {
                    Text(StringResourceManager.getString("cancelar", currentLanguage))
                }
            }
        )
    }
}

@Composable
private fun CategoriaCard(
    categoria: CategoriaEntity,
    onEditar: () -> Unit,
    onEliminar: () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surface
        ),
        shape = RoundedCornerShape(12.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Row(
                verticalAlignment = Alignment.CenterVertically,
                modifier = Modifier.weight(1f)
            ) {
                // C√≠rculo de color
                Box(
                    modifier = Modifier
                        .size(24.dp)
                        .clip(CircleShape)
                        .background(Color(android.graphics.Color.parseColor(categoria.colorHex)))
                )

                Spacer(modifier = Modifier.width(16.dp))

                // Nombre
                Text(
                    text = categoria.nombre,
                    style = MaterialTheme.typography.bodyLarge,
                    fontWeight = FontWeight.Medium,
                    color = MaterialTheme.colorScheme.onSurface
                )
            }

            // Botones de acci√≥n
            Row(
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                IconButton(onClick = onEditar) {
                    Icon(
                        painter = painterResource(id = R.drawable.ic_edit),
                        contentDescription = "Editar",
                        tint = MaterialTheme.colorScheme.primary
                    )
                }

                IconButton(onClick = onEliminar) {
                    Icon(
                        painter = painterResource(id = R.drawable.ic_delete),
                        contentDescription = "Eliminar",
                        tint = MaterialTheme.colorScheme.error
                    )
                }
            }
        }
    }
}

@Composable
fun ColorPickerDialog(
    onColorElegido: (Color) -> Unit,
    onCancelar: () -> Unit
) {
    val controller = rememberColorPickerController()

    AlertDialog(
        onDismissRequest = onCancelar,
        title = { Text("Seleccionar color") },
        text = {
            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                // Selector principal
                HsvColorPicker(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(200.dp)
                        .padding(8.dp),
                    controller = controller,
                    onColorChanged = {}
                )

                // Control de transparencia
                AlphaSlider(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(8.dp),
                    controller = controller
                )

                // Control de brillo
                BrightnessSlider(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(8.dp),
                    controller = controller
                )
            }
        },
        confirmButton = {
            TextButton(onClick = {
                onColorElegido(controller.selectedColor.value)
            }) {
                Text("Aceptar", color = Color.Black) // ‚úÖ NEGRO como solicitaste
            }
        },
        dismissButton = {
            TextButton(onClick = onCancelar) {
                Text("Cancelar", color = Color.Black) // ‚úÖ NEGRO como solicitaste
            }
        }
    )
}

// PantallaConfiguracion.kt V10 - SIMPLIFICADO PARA SISTEMA MONOUSUARIO
package es.nuskysoftware.marketsales.ui.pantallas

import android.util.Log
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.runtime.rememberCoroutineScope
import androidx.navigation.NavController
import es.nuskysoftware.marketsales.R
import es.nuskysoftware.marketsales.data.repository.AuthRepository
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.FooterMarca
import es.nuskysoftware.marketsales.utils.StringResourceManager
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PantallaConfiguracion(
    navController: NavController? = null
) {
    val context = LocalContext.current
    val authRepo = remember { AuthRepository(context) }
    val scope = rememberCoroutineScope()

//    // Estados V10 simplificados
//    val currentLanguage by ConfigurationManager.idioma.collectAsState()
//    val currentFont by ConfigurationManager.fuente.collectAsState()
//    val isDarkTheme by ConfigurationManager.temaOscuro.collectAsState()
//    val currentMoneda by ConfigurationManager.moneda.collectAsState()
//    val esPremium by ConfigurationManager.esPremium.collectAsState()
//    val usuarioEmail by ConfigurationManager.usuarioEmail.collectAsState()
//    val isAuthenticated by ConfigurationManager.isAuthenticated.collectAsState()

    // Estados V10 simplificados
    val currentLanguage by ConfigurationManager.idioma.collectAsState()
    val currentFont by ConfigurationManager.fuente.collectAsState()
    val isDarkTheme by ConfigurationManager.temaOscuro.collectAsState()
    val currentMoneda by ConfigurationManager.moneda.collectAsState()
    val esPremium by ConfigurationManager.esPremium.collectAsState()
    val usuarioEmail by ConfigurationManager.usuarioEmail.collectAsState()
    val isAuthenticated by ConfigurationManager.isAuthenticated.collectAsState()

    // Permisos V10 simplificados
    //val canChangeAdvanced = ConfigurationManager.canChangeConfiguration()
    val canChangeAdvanced = esPremium // En lugar de ConfigurationManager.canChangeConfiguration()

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        StringResourceManager.getString("configuracion", currentLanguage),
                        fontWeight = FontWeight.Bold
                    )
                },
                navigationIcon = {
                    IconButton(onClick = { navController?.popBackStack() }) {
                        Icon(
                            imageVector = Icons.Default.ArrowBack,
                            contentDescription = "Volver"
                        )
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary,
                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary
                )
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            LazyColumn(
                modifier = Modifier
                    .weight(1f)
                    .fillMaxWidth()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                // Informaci√≥n de cuenta V10
                item {
                    TarjetaInformacionCuenta(
                        email = usuarioEmail ?: if (isAuthenticated) "usuario@email.com" else "Usuario Invitado",
                        esPremium = esPremium,
                        isAuthenticated = isAuthenticated,
                        version = "V10.0",
                        language = currentLanguage
                    )
                }

                // Idioma (solo Premium)
                item {
                    OpcionConfiguracionV10(
                        iconRes = R.drawable.ic_language,
                        titulo = StringResourceManager.getString("idioma", currentLanguage),
                        valorActual = if (currentLanguage == "es") "Espa√±ol" else "English",
                        opciones = listOf("es" to "Espa√±ol", "en" to "English"),
                        habilitado = canChangeAdvanced,
                        onSeleccionar = { codigo ->
                            scope.launch {
                                authRepo.updateConfiguration(idioma = codigo)

                            }
                        }
                    )
                }

                // Fuente (solo Premium)
                item {
                    OpcionConfiguracionV10(
                        iconRes = R.drawable.ic_font,
                        titulo = StringResourceManager.getString("fuente", currentLanguage),
                        valorActual = currentFont,
                        opciones = listOf("Montserrat" to "Montserrat", "Poppins" to "Poppins", "Roboto" to "Roboto"),
                        habilitado = canChangeAdvanced,
                        onSeleccionar = { fuente ->
                            scope.launch {
                                authRepo.updateConfiguration(fuente = fuente)
                            }
                        }
                    )
                }

                // Tema Oscuro (todos pueden cambiar)
                item {
                    Card(
                        modifier = Modifier.fillMaxWidth(),
                        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),
                        elevation = CardDefaults.cardElevation(4.dp)
                    ) {
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(16.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                painter = painterResource(id = R.drawable.ic_palette),
                                contentDescription = "Tema",
                                tint = MaterialTheme.colorScheme.primary,
                                modifier = Modifier.size(24.dp)
                            )
                            Spacer(modifier = Modifier.width(16.dp))
                            Column(modifier = Modifier.weight(1f)) {
                                Text(
                                    text = StringResourceManager.getString("tema", currentLanguage),
                                    style = MaterialTheme.typography.bodyLarge,
                                    fontWeight = FontWeight.Medium
                                )
                                Text(
                                    text = if (isDarkTheme) "Oscuro" else "Claro",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                                )
                            }
                            Switch(
                                checked = isDarkTheme,
                                onCheckedChange = { nuevoValor ->
                                    scope.launch {
                                        authRepo.updateConfiguration(temaOscuro = nuevoValor)
                                    }
                                }
                            )
                        }
                    }
                }

                // Moneda (solo Premium)
                item {
                    val monedas = listOf(
                        "‚Ç¨ Euro" to "‚Ç¨ Euro",
                        "$ D√≥lar" to "$ D√≥lar",
                        "¬£ Libra" to "¬£ Libra",
                        "$ Peso Argentino" to "$ Peso Argentino",
                        "$ Peso Mexicano" to "$ Peso Mexicano",
                        "$ Peso Colombiano" to "$ Peso Colombiano",
                        "S/ Sol Peruano" to "S/ Sol Peruano",
                        "$ Peso Chileno" to "$ Peso Chileno",
                        "Bs Bol√≠var" to "Bs Bol√≠var",
                        "$ Real Brasile√±o" to "$ Real Brasile√±o"
                    )

                    OpcionConfiguracionV10(
                        iconRes = R.drawable.ic_money,
                        titulo = "Moneda",
                        valorActual = currentMoneda,
                        opciones = monedas,
                        habilitado = canChangeAdvanced,
                        onSeleccionar = { moneda ->
                            scope.launch {
                                authRepo.updateConfiguration(moneda = moneda)
                            }
                        }
                    )
                }

                // Secci√≥n desarrollo/testing
//                item {
//                    Card(
//                        modifier = Modifier.fillMaxWidth().clickable {
//                            scope.launch {
//                                authRepo.updateUserPremium(!esPremium)
//                            }
//                        },
//                        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.secondaryContainer)
//                    ) {
//                        Row(
//                            modifier = Modifier
//                                .fillMaxWidth()
//                                .padding(16.dp),
//                            verticalAlignment = Alignment.CenterVertically
//                        ) {
//                            Icon(
//                                painter = painterResource(id = R.drawable.ic_settings),
//                                contentDescription = "Desarrollo",
//                                tint = MaterialTheme.colorScheme.onSecondaryContainer,
//                                modifier = Modifier.size(24.dp)
//                            )
//                            Spacer(modifier = Modifier.width(16.dp))
//                            Column(modifier = Modifier.weight(1f)) {
//                                Text(
//                                    text = "Desarrollo",
//                                    style = MaterialTheme.typography.bodyLarge,
//                                    fontWeight = FontWeight.Medium,
//                                    color = MaterialTheme.colorScheme.onSecondaryContainer
//                                )
//                                Text(
//                                    text = if (esPremium) "üöÄ Premium ACTIVO" else "‚úã Modo FREE",
//                                    style = MaterialTheme.typography.bodySmall,
//                                    color = MaterialTheme.colorScheme.onSecondaryContainer.copy(alpha = 0.7f)
//                                )
//                            }
//                        }
//                    }
//                }

                // Reemplazar la secci√≥n de desarrollo/testing en PantallaConfiguracion.kt:

// Secci√≥n desarrollo/testing - ‚úÖ TOGGLE PREMIUM ARREGLADO
                item {
                    Card(
                        modifier = Modifier.fillMaxWidth().clickable {
                            // ‚úÖ CAMBIO: Usar funci√≥n simplificada para desarrollo
                            ConfigurationManager.togglePremiumForDevelopment()
                        },
                        colors = CardDefaults.cardColors(
                            containerColor = if (esPremium) {
                                Color(0xFFFFD700).copy(alpha = 0.3f) // Dorado para Premium
                            } else {
                                MaterialTheme.colorScheme.secondaryContainer // Normal para Free
                            }
                        ),
                        elevation = CardDefaults.cardElevation(
                            defaultElevation = if (esPremium) 8.dp else 4.dp
                        )
                    ) {
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(16.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                painter = painterResource(
                                    id = if (esPremium) R.drawable.ic_info else R.drawable.ic_settings
                                ),
                                contentDescription = "Desarrollo",
                                tint = if (esPremium) {
                                    Color(0xFFFFD700) // Dorado para Premium
                                } else {
                                    MaterialTheme.colorScheme.onSecondaryContainer
                                },
                                modifier = Modifier.size(24.dp)
                            )
                            Spacer(modifier = Modifier.width(16.dp))
                            Column(modifier = Modifier.weight(1f)) {
                                Text(
                                    text = "üîß Toggle Premium (Desarrollo)",
                                    style = MaterialTheme.typography.bodyLarge,
                                    fontWeight = FontWeight.Bold,
                                    color = if (esPremium) {
                                        Color(0xFFFFD700)
                                    } else {
                                        MaterialTheme.colorScheme.onSecondaryContainer
                                    }
                                )
                                Text(
                                    text = if (esPremium) "üöÄ PREMIUM ACTIVO - Tap para FREE" else "‚úã MODO FREE - Tap para PREMIUM",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = if (esPremium) {
                                        Color(0xFFFFD700).copy(alpha = 0.8f)
                                    } else {
                                        MaterialTheme.colorScheme.onSecondaryContainer.copy(alpha = 0.7f)
                                    }
                                )
                                if (esPremium) {
                                    Text(
                                        text = "‚Ä¢ Idiomas adicionales\n‚Ä¢ Fuentes personalizadas\n‚Ä¢ Monedas m√∫ltiples",
                                        style = MaterialTheme.typography.bodySmall,
                                        fontSize = 10.sp,
                                        color = Color(0xFFFFD700).copy(alpha = 0.6f)
                                    )
                                }
                            }

                            // Indicador visual del estado
                            Card(
                                colors = CardDefaults.cardColors(
                                    containerColor = if (esPremium) Color(0xFFFFD700) else Color.Gray
                                ),
                                modifier = Modifier.padding(4.dp)
                            ) {
                                Text(
                                    text = if (esPremium) "PREMIUM" else "FREE",
                                    modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp),
                                    fontSize = 12.sp,
                                    fontWeight = FontWeight.Bold,
                                    color = Color.Black
                                )
                            }
                        }
                    }
                }

                // Promoci√≥n Premium para usuarios FREE
                if (!esPremium) {
                    item {
                        TarjetaPromocionPremium(language = currentLanguage)
                    }
                }
            }

            // Footer
            FooterMarca()
        }
    }
    // üîç LOG TEMPORAL para debugging
    LaunchedEffect(esPremium, canChangeAdvanced) {
        Log.d("PantallaConfiguracion", "üîç Estado actual:")
        Log.d("PantallaConfiguracion", "   - esPremium: $esPremium")
        Log.d("PantallaConfiguracion", "   - canChangeAdvanced: $canChangeAdvanced")
        Log.d("PantallaConfiguracion", "   - isAuthenticated: $isAuthenticated")
    }
}

@Composable
private fun OpcionConfiguracionV10(
    iconRes: Int,
    titulo: String,
    valorActual: String,
    opciones: List<Pair<String, String>>,
    habilitado: Boolean,
    onSeleccionar: (String) -> Unit
) {
    var expanded by remember { mutableStateOf(false) }

    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = if (habilitado)
                MaterialTheme.colorScheme.surface
            else
                MaterialTheme.colorScheme.surface.copy(alpha = 0.5f)
        ),
        elevation = CardDefaults.cardElevation(if (habilitado) 4.dp else 2.dp)
    ) {
        Column {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .clickable(enabled = habilitado) {
                        if (habilitado) expanded = !expanded
                    }
                    .padding(16.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Icon(
                    painter = painterResource(id = iconRes),
                    contentDescription = titulo,
                    tint = if (habilitado)
                        MaterialTheme.colorScheme.primary
                    else
                        MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f),
                    modifier = Modifier.size(24.dp)
                )
                Spacer(modifier = Modifier.width(16.dp))
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = titulo,
                        style = MaterialTheme.typography.bodyLarge,
                        fontWeight = FontWeight.Medium,
                        color = if (habilitado)
                            MaterialTheme.colorScheme.onSurface
                        else
                            MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f)
                    )
                    Text(
                        text = valorActual,
                        style = MaterialTheme.typography.bodySmall,
                        color = if (habilitado)
                            MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                        else
                            MaterialTheme.colorScheme.onSurface.copy(alpha = 0.3f)
                    )
                    if (!habilitado) {
                        Text(
                            text = "Solo Premium",
                            style = MaterialTheme.typography.bodySmall,
                            color = Color.Red.copy(alpha = 0.7f)
                        )
                    }
                }
                if (habilitado) {
                    Icon(
                        painter = painterResource(
                            id = if (expanded) R.drawable.ic_arrow_up else R.drawable.ic_arrow_down
                        ),
                        contentDescription = "Expandir",
                        tint = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f),
                        modifier = Modifier.size(16.dp)
                    )
                }
            }
            if (expanded && habilitado) {
                Column(modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)) {
                    opciones.forEach { (codigo, nombre) ->
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .clickable {
                                    onSeleccionar(codigo)
                                    expanded = false
                                }
                                .padding(vertical = 8.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            RadioButton(
                                selected = valorActual == codigo,
                                onClick = {
                                    onSeleccionar(codigo)
                                    expanded = false
                                }
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text(nombre)
                        }
                    }
                }
            }
        }
    }
}

@Composable
private fun TarjetaInformacionCuenta(
    email: String,
    esPremium: Boolean,
    isAuthenticated: Boolean,
    version: String,
    language: String
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),
        elevation = CardDefaults.cardElevation(4.dp)
    ) {
        Column(modifier = Modifier.padding(16.dp)) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = StringResourceManager.getString("informacion_cuenta", language),
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
                Card(
                    colors = CardDefaults.cardColors(
                        containerColor = when {
                            !isAuthenticated -> Color(0xFFCCCCCC)
                            esPremium -> Color(0xFFFFD700)
                            else -> Color(0xFF90EE90)
                        }
                    ),
                    modifier = Modifier.padding(4.dp)
                ) {
                    Text(
                        text = when {
                            !isAuthenticated -> "INVITADO"
                            esPremium -> "PREMIUM"
                            else -> "FREE"
                        },
                        modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp),
                        fontSize = 12.sp,
                        fontWeight = FontWeight.Bold,
                        color = Color.Black
                    )
                }
            }
            Spacer(modifier = Modifier.height(8.dp))
            Text(
                text = email,
                style = MaterialTheme.typography.bodyLarge,
                color = MaterialTheme.colorScheme.onSurface
            )
            Text(
                text = "App $version",
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
            )
        }
    }
}

@Composable
private fun TarjetaPromocionPremium(language: String) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(containerColor = Color(0xFFFFD700).copy(alpha = 0.3f)),
        elevation = CardDefaults.cardElevation(6.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Icon(
                painter = painterResource(id = R.drawable.ic_info),
                contentDescription = "Premium",
                tint = Color(0xFFFFD700),
                modifier = Modifier.size(32.dp)
            )
            Spacer(modifier = Modifier.height(8.dp))
            Text(
                text = StringResourceManager.getString("promocion_premium", language),
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold,
                color = MaterialTheme.colorScheme.onSurface
            )
            Text(
                text = StringResourceManager.getString("desbloquea_funciones", language),
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.8f)
            )
        }
    }
}


// app/src/main/java/es/nuskysoftware/marketsales/ui/pantallas/PantallaEnviarRecibo.kt
package es.nuskysoftware.marketsales.ui.pantallas

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp

/**
 * Versi√≥n alineada con MainActivity:
 * - Muestra un resumen m√≠nimo (Total + M√©todo)
 * - Dos botones: Enviar (opcional) y Finalizar venta
 * La generaci√≥n del recibo real y guardado se delega al ViewModel de Ventas
 * cuando volvamos con el savedStateHandle["finalizar_metodo"].
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PantallaEnviarRecibo(
    totalFormateado: String,
    metodo: String,
    onBack: () -> Unit,
    onEnviar: () -> Unit,
    onFinalizarVenta: () -> Unit
) {
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Recibo", fontWeight = FontWeight.Bold) },
                navigationIcon = { TextButton(onClick = onBack) { Text("‚Üê") } },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary,
                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary
                )
            )
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text("Total", fontSize = 16.sp, color = MaterialTheme.colorScheme.onSurfaceVariant)
            Text(totalFormateado, fontSize = 28.sp, fontWeight = FontWeight.ExtraBold)

            Spacer(Modifier.height(8.dp))
            Text("M√©todo de pago: ${metodo.uppercase()}", fontSize = 14.sp)

            Spacer(Modifier.height(24.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                OutlinedButton(
                    onClick = onEnviar,
                    modifier = Modifier.weight(1f).height(48.dp)
                ) { Text("Enviar") }

                Button(
                    onClick = onFinalizarVenta,
                    modifier = Modifier.weight(1f).height(48.dp)
                ) { Text("Finalizar venta") }
            }
        }
    }
}



// app/src/main/java/es/nuskysoftware/marketsales/ui/pantallas/PantallaLogin.kt
package es.nuskysoftware.marketsales.ui.pantallas

import android.app.Activity
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardActions
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Email
import androidx.compose.material.icons.filled.Lock
import androidx.compose.material.icons.filled.Visibility
import androidx.compose.material.icons.filled.VisibilityOff
import androidx.compose.material3.*
import androidx.compose.material3.Typography
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.focus.FocusDirection
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalFocusManager
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.text.input.VisualTransformation
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.google.android.gms.auth.api.signin.GoogleSignIn
import com.google.android.gms.common.api.ApiException
import es.nuskysoftware.marketsales.R
import es.nuskysoftware.marketsales.data.repository.AuthState
import es.nuskysoftware.marketsales.ui.viewmodel.AuthViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.AuthViewModelFactory
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.StringResourceManager

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PantallaLogin(
    onNavigateToMain: () -> Unit = {}
) {
    val context = LocalContext.current
    val focusManager = LocalFocusManager.current

    // ‚úÖ Usa applicationContext para evitar fugas
    val authViewModel: AuthViewModel = viewModel(
        factory = AuthViewModelFactory(context.applicationContext)
    )

    val authState by authViewModel.authState.collectAsState()

    // Para forzar recomposici√≥n al cambiar idioma
    val currentLanguage by ConfigurationManager.idioma.collectAsState()

    // Estados locales
    var email by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }
    var isPasswordVisible by remember { mutableStateOf(false) }
    var isLoginMode by remember { mutableStateOf(true) } // true = Login, false = Registro
    var showError by remember { mutableStateOf(false) }
    var errorMessage by remember { mutableStateOf("") }

    // Validaciones
    val isEmailValid = remember(email) { email.contains("@") && email.contains(".") }
    val isPasswordValid = remember(password) { password.length >= 6 }
    val isFormValid = isEmailValid && isPasswordValid

    // üöÄ GOOGLE AUTH - usa tu helper existente
    val googleSignInClient = remember {
        try {
            es.nuskysoftware.marketsales.utils.GoogleAuthHelper.getGoogleSignInClient(context)
        } catch (e: Exception) {
            null // Si falla, Google Auth no disponible
        }
    }

    // Launcher para Google Sign-In
    val googleSignInLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.StartActivityForResult()
    ) { result ->
        if (result.resultCode == Activity.RESULT_OK) {
            val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)
            try {
                val account = task.getResult(ApiException::class.java)
                val idToken = account?.idToken
                if (idToken != null) {
                    authViewModel.signInWithGoogle(idToken)
                } else {
                    errorMessage = "Error obteniendo token de Google"
                    showError = true
                }
            } catch (e: ApiException) {
                errorMessage = "Error en Google Sign-In: ${e.message}"
                showError = true
            }
        }
    }

    // Navegar tras autenticaci√≥n
    LaunchedEffect(authState) {
        when (authState) {
            is AuthState.Authenticated -> onNavigateToMain()
            is AuthState.Error -> {
                errorMessage = (authState as AuthState.Error).message
                showError = true
            }
            else -> { /* no-op */ }
        }
    }

    fun handleAuthAction() {
        if (!isFormValid) return
        showError = false
        if (isLoginMode) authViewModel.loginWithEmail(email.trim(), password)
        else authViewModel.registerWithEmail(email.trim(), password)
    }

    fun handleGoogleSignIn() {
        if (googleSignInClient != null) {
            showError = false
            val signInIntent = googleSignInClient.signInIntent
            googleSignInLauncher.launch(signInIntent)
        } else {
            errorMessage = "Google Auth no disponible - Revisa configuraci√≥n"
            showError = true
        }
    }

    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(
                brush = Brush.verticalGradient(
                    colors = listOf(
                        MaterialTheme.colorScheme.primary.copy(alpha = 0.1f),
                        MaterialTheme.colorScheme.surface
                    )
                )
            )
    ) {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .verticalScroll(rememberScrollState())
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            // Logo
            Card(
                modifier = Modifier
                    .size(100.dp)
                    .padding(bottom = 16.dp),
                shape = RoundedCornerShape(50.dp),
                elevation = CardDefaults.cardElevation(8.dp)
            ) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Image(
                        painter = painterResource(id = R.drawable.ic_store),
                        contentDescription = StringResourceManager.getString("app_name", currentLanguage),
                        modifier = Modifier.size(60.dp)
                    )
                }
            }

            // T√≠tulo App
            Text(
                text = StringResourceManager.getString("app_name", currentLanguage),
                style = MaterialTheme.typography.headlineMedium.copy(
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.primary
                ),
                modifier = Modifier.padding(bottom = 8.dp)
            )

            // Subt√≠tulo Login/Registro
            Text(
                text = if (isLoginMode)
                    StringResourceManager.getString("login_subtitle", currentLanguage)
                else
                    StringResourceManager.getString("register_subtitle", currentLanguage),
                style = MaterialTheme.typography.bodyLarge.copy(
                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                ),
                textAlign = TextAlign.Center,
                modifier = Modifier.padding(bottom = 32.dp)
            )

            // Formulario
            Card(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(bottom = 16.dp),
                elevation = CardDefaults.cardElevation(4.dp),
                shape = RoundedCornerShape(16.dp)
            ) {
                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(24.dp),
                    verticalArrangement = Arrangement.spacedBy(16.dp)
                ) {
                    // Email
                    OutlinedTextField(
                        value = email,
                        onValueChange = {
                            email = it
                            showError = false
                        },
                        label = { Text(StringResourceManager.getString("email", currentLanguage)) },
                        placeholder = { Text(StringResourceManager.getString("email_placeholder", currentLanguage)) },
                        leadingIcon = { Icon(Icons.Default.Email, contentDescription = null) },
                        modifier = Modifier.fillMaxWidth(),
                        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email, imeAction = ImeAction.Next),
                        keyboardActions = KeyboardActions(onNext = { focusManager.moveFocus(FocusDirection.Down) }),
                        isError = email.isNotEmpty() && !isEmailValid,
                        supportingText = {
                            if (email.isNotEmpty() && !isEmailValid) {
                                Text(
                                    text = StringResourceManager.getString("email_invalid", currentLanguage),
                                    color = MaterialTheme.colorScheme.error
                                )
                            }
                        },
                        singleLine = true
                    )

                    // Contrase√±a
                    OutlinedTextField(
                        value = password,
                        onValueChange = {
                            password = it
                            showError = false
                        },
                        label = { Text(StringResourceManager.getString("password", currentLanguage)) },
                        placeholder = { Text(StringResourceManager.getString("password_placeholder", currentLanguage)) },
                        leadingIcon = { Icon(Icons.Default.Lock, contentDescription = null) },
                        trailingIcon = {
                            IconButton(onClick = { isPasswordVisible = !isPasswordVisible }) {
                                Icon(
                                    imageVector = if (isPasswordVisible) Icons.Default.Visibility else Icons.Default.VisibilityOff,
                                    contentDescription = if (isPasswordVisible)
                                        "Ocultar contrase√±a" else "Mostrar contrase√±a"
                                )
                            }
                        },
                        visualTransformation = if (isPasswordVisible) VisualTransformation.None else PasswordVisualTransformation(),
                        modifier = Modifier.fillMaxWidth(),
                        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password, imeAction = ImeAction.Done),
                        keyboardActions = KeyboardActions(onDone = {
                            focusManager.clearFocus()
                            if (isFormValid) handleAuthAction()
                        }),
                        isError = password.isNotEmpty() && !isPasswordValid,
                        supportingText = {
                            if (password.isNotEmpty() && !isPasswordValid) {
                                Text(
                                    text = StringResourceManager.getString("password_invalid", currentLanguage),
                                    color = MaterialTheme.colorScheme.error
                                )
                            }
                        },
                        singleLine = true
                    )

                    // Error gen√©rico
                    if (showError && errorMessage.isNotEmpty()) {
                        Card(
                            modifier = Modifier.fillMaxWidth(),
                            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.errorContainer)
                        ) {
                            Text(
                                text = errorMessage,
                                color = MaterialTheme.colorScheme.onErrorContainer,
                                style = MaterialTheme.typography.bodyMedium,
                                modifier = Modifier.padding(12.dp)
                            )
                        }
                    }
                }
            }

            // Bot√≥n principal
            Button(
                onClick = { handleAuthAction() },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(56.dp),
                enabled = isFormValid && authState !is AuthState.Loading,
                shape = RoundedCornerShape(28.dp)
            ) {
                if (authState is AuthState.Loading) {
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        CircularProgressIndicator(
                            modifier = Modifier.size(20.dp),
                            strokeWidth = 2.dp,
                            color = MaterialTheme.colorScheme.onPrimary
                        )
                        Text(
                            StringResourceManager.getString("loading", currentLanguage),
                            fontSize = 16.sp,
                            fontWeight = FontWeight.Medium
                        )
                    }
                } else {
                    Text(
                        text = if (isLoginMode)
                            StringResourceManager.getString("login_button", currentLanguage)
                        else
                            StringResourceManager.getString("register_button", currentLanguage),
                        fontSize = 16.sp,
                        fontWeight = FontWeight.Medium
                    )
                }
            }

            // Divisor
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(vertical = 24.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                HorizontalDivider(modifier = Modifier.weight(1f))
                Text(
                    StringResourceManager.getString("or", currentLanguage),
                    modifier = Modifier.padding(horizontal = 16.dp),
                    style = MaterialTheme.typography.bodyMedium.copy(
                        color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)
                    )
                )
                HorizontalDivider(modifier = Modifier.weight(1f))
            }

            // üöÄ Google Sign-In (tu estilo)
            if (googleSignInClient != null) {
                OutlinedButton(
                    onClick = { handleGoogleSignIn() },
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(56.dp),
                    enabled = authState !is AuthState.Loading,
                    shape = RoundedCornerShape(28.dp),
                    border = ButtonDefaults.outlinedButtonBorder.copy(
                        width = 2.dp,
                        brush = Brush.horizontalGradient(
                            colors = listOf(
                                MaterialTheme.colorScheme.primary,
                                MaterialTheme.colorScheme.secondary
                            )
                        )
                    )
                ) {
                    if (authState is AuthState.Loading) {
                        CircularProgressIndicator(
                            modifier = Modifier.size(20.dp),
                            strokeWidth = 2.dp,
                            color = MaterialTheme.colorScheme.primary
                        )
                    } else {
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                            horizontalArrangement = Arrangement.spacedBy(12.dp)
                        ) {
                            // Puedes reemplazar por icono de Google si lo tienes en /drawable
                            Icon(
                                painter = painterResource(id = R.drawable.ic_store),
                                contentDescription = "Google",
                                modifier = Modifier.size(20.dp),
                                tint = MaterialTheme.colorScheme.primary
                            )
                            Text(
                                text = if (isLoginMode)
                                    StringResourceManager.getString("google_signin", currentLanguage)
                                else
                                    StringResourceManager.getString("google_register", currentLanguage),
                                fontSize = 16.sp,
                                fontWeight = FontWeight.Medium,
                                color = MaterialTheme.colorScheme.primary
                            )
                        }
                    }
                }
            }

            Spacer(modifier = Modifier.height(32.dp))

            // Toggle Login/Registro
            TextButton(
                onClick = {
                    isLoginMode = !isLoginMode
                    showError = false
                    errorMessage = ""
                }
            ) {
                Text(
                    text = if (isLoginMode)
                        StringResourceManager.getString("go_to_register", currentLanguage)
                    else
                        StringResourceManager.getString("go_to_login", currentLanguage),
                    style = MaterialTheme.typography.bodyMedium.copy(
                        color = MaterialTheme.colorScheme.primary,
                        fontWeight = FontWeight.Medium
                    )
                )
            }

            // Beneficios del registro (solo en modo registro)
            if (!isLoginMode) {
                Spacer(modifier = Modifier.height(16.dp))
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(
                        containerColor = MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.3f)
                    ),
                    elevation = CardDefaults.cardElevation(2.dp)
                ) {
                    Column(modifier = Modifier.padding(16.dp)) {
                        Text(
                            text = StringResourceManager.getString("register_benefits_title", currentLanguage),
                            style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.Bold),
                            color = MaterialTheme.colorScheme.onSurface
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                        listOf("benefit_1", "benefit_2", "benefit_3", "benefit_4").forEach { benefit ->
                            Text(
                                text = StringResourceManager.getString(benefit, currentLanguage),
                                style = MaterialTheme.typography.bodySmall,
                                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.8f),
                                modifier = Modifier.padding(vertical = 2.dp)
                            )
                        }
                    }
                }
            }
        }
    }
}


// app/src/main/java/es/nuskysoftware/marketsales/ui/pantallas/PantallaMercadillos.kt
// ACTUALIZACI√ìN: Pull-to-Refresh Material 3 (sin banner) + Paywall v√≠a Snackbar

package es.nuskysoftware.marketsales.ui.pantallas
import es.nuskysoftware.marketsales.data.repository.SyncState
import es.nuskysoftware.marketsales.ui.viewmodel.AuthViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.AuthViewModelFactory

import es.nuskysoftware.marketsales.ui.components.MenuHamburguesa
import es.nuskysoftware.marketsales.ui.components.BottomBarMercadillo
import es.nuskysoftware.marketsales.ui.components.DialogoSeleccionMercadilloActivo
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Info
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Badge
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.ModalNavigationDrawer
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarDuration
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.SnackbarResult
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.pulltorefresh.PullToRefreshBox
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.DialogProperties
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import kotlinx.coroutines.launch
import kotlinx.coroutines.delay
import es.nuskysoftware.marketsales.R
import es.nuskysoftware.marketsales.data.local.entity.MercadilloEntity
import es.nuskysoftware.marketsales.ui.viewmodel.MercadilloViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.MercadilloViewModelFactory
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.EstadosMercadillo
import es.nuskysoftware.marketsales.utils.FooterMarca
import es.nuskysoftware.marketsales.utils.StringResourceManager

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PantallaMercadillos(
    navController: NavController? = null
) {
    val context = LocalContext.current

    // ViewModel con factory
    val mercadilloViewModel: MercadilloViewModel = viewModel(
        factory = MercadilloViewModelFactory(context)
    )

    val authViewModel: AuthViewModel = viewModel(
        factory = AuthViewModelFactory(context.applicationContext)
    )
    val syncState by authViewModel.syncState.collectAsState()

    // Estados para el drawer
    val drawerState = androidx.compose.material3.rememberDrawerState(androidx.compose.material3.DrawerValue.Closed)
    val scope = rememberCoroutineScope()

    // Estados de configuraci√≥n
    val currentLanguage by ConfigurationManager.idioma.collectAsState()
    val esPremium by ConfigurationManager.esPremium.collectAsState()
    val isAuthenticated by ConfigurationManager.isAuthenticated.collectAsState()

    // Estados del ViewModel
    val uiState by mercadilloViewModel.uiState.collectAsState()
    val calendarioState by mercadilloViewModel.calendarioState.collectAsState()
    val mercadillosPorDia by mercadilloViewModel.mercadillosPorDia.collectAsState()
    val proximoMercadillo by mercadilloViewModel.proximoMercadillo.collectAsState()
    val nombreMesActual by mercadilloViewModel.nombreMesActual.collectAsState()
    val tieneMercadillos by mercadilloViewModel.tieneMercadillos.collectAsState()

    // ‚úÖ NUEVOS ESTADOS PARA BOTTOMBAR
    val mostrarBottomBar by mercadilloViewModel.mostrarBottomBar.collectAsState()
    val mercadillosEnCurso by mercadilloViewModel.mercadillosEnCurso.collectAsState()
    val mercadilloActivoParaOperaciones by mercadilloViewModel.mercadilloActivoParaOperaciones.collectAsState()

    // Estados locales
    var mostrarLeyenda by remember { mutableStateOf(false) }
    var mostrarDialogoSeleccion by remember { mutableStateOf(false) }
    var mercadillosParaSeleccionar by remember { mutableStateOf<List<MercadilloEntity>>(emptyList()) }

    // ‚úÖ NUEVOS ESTADOS PARA MERCADILLOS PR√ìXIMOS
    val mercadillosProximos by mercadilloViewModel.mercadillosProximos.collectAsState()
    val tieneMercadillosProximos by mercadilloViewModel.tieneMercadillosProximos.collectAsState()

    // ‚úÖ NUEVOS ESTADOS PARA BOTTOMBAR
    var mostrarDialogoSeleccionActivo by remember { mutableStateOf(false) }
    var accionPendiente by remember { mutableStateOf<String?>(null) } // "ventas", "gastos", "resumen"

    val snackbarHostState = remember { SnackbarHostState() }

    // ====== PULL-TO-REFRESH (Material 3) ======
    var isRefreshing by remember { mutableStateOf(false) }

    // Manejar mensajes del ViewModel
    LaunchedEffect(uiState.message) {
        uiState.message?.let { message ->
            snackbarHostState.showSnackbar(message)
            mercadilloViewModel.limpiarMensaje()
        }
    }

    LaunchedEffect(uiState.error) {
        uiState.error?.let { error ->
            snackbarHostState.showSnackbar(error)
            mercadilloViewModel.limpiarError()
        }
    }

    // ====== UI ======
    // Envolvemos TODO en PullToRefreshBox para aplicar el gesto de refresco a la pantalla
    PullToRefreshBox(
        isRefreshing = isRefreshing,
        onRefresh = {
            scope.launch {
                isRefreshing = true
                if (esPremium) {
                    // PREMIUM ‚Üí sync completa (subir + bajar) via VM
                    mercadilloViewModel.forzarSincronizacion()
                } else {
                    // FREE ‚Üí refresco local (no red) + paywall
                    delay(600)
                    val result = snackbarHostState.showSnackbar(
                        message = StringResourceManager.getString("premium_required", currentLanguage),
                        actionLabel = StringResourceManager.getString("go_premium", currentLanguage),
                        withDismissAction = true,
                        duration = SnackbarDuration.Short
                    )
                    if (result == SnackbarResult.ActionPerformed) {
                        navController?.navigate("configuracion")
                    }
                }
                isRefreshing = false
            }
        },
        modifier = Modifier.fillMaxSize()
    ) {
        // Drawer + Scaffold
        ModalNavigationDrawer(
            drawerState = drawerState,
            drawerContent = {
                // Solo mostrar el men√∫ si navController no es null
                navController?.let { nav ->
                    MenuHamburguesa(
                        navController = nav,
                        drawerState = drawerState
                    )
                }
            }
        ) {
            Scaffold(
                topBar = {
                    TopAppBar(
                        title = {
                            Text(
                                StringResourceManager.getString("mercadillos", currentLanguage),
                                fontWeight = FontWeight.Bold
                            )
                        },
                        navigationIcon = {
                            IconButton(
                                onClick = {
                                    scope.launch { drawerState.open() }
                                }
                            ) {
                                Icon(
                                    painter = painterResource(id = R.drawable.ic_menu),
                                    contentDescription = StringResourceManager.getString("menu", currentLanguage)
                                )
                            }
                        },
                        colors = TopAppBarDefaults.topAppBarColors(
                            containerColor = MaterialTheme.colorScheme.primary,
                            titleContentColor = MaterialTheme.colorScheme.onPrimary,
                            navigationIconContentColor = MaterialTheme.colorScheme.onPrimary
                        )
                    )
                },
                snackbarHost = { SnackbarHost(snackbarHostState) },
                floatingActionButton = {
                    FloatingActionButton(
                        onClick = {
                            // Navegar a pantalla de crear mercadillo
                            navController?.navigate("alta_mercadillo")
                        },
                        shape = CircleShape,
                        containerColor = MaterialTheme.colorScheme.primary,
                        contentColor = MaterialTheme.colorScheme.onPrimary
                    ) {
                        Icon(
                            imageVector = Icons.Default.Add,
                            contentDescription = StringResourceManager.getString("add_mercadillo", currentLanguage)
                        )
                    }
                },
                // ‚úÖ BOTTOMBAR CONDICIONAL
                bottomBar = {
                    if (mostrarBottomBar) {
                        BottomBarMercadillo(
                            mercadilloActivo = mercadilloActivoParaOperaciones,
                            onVentasClick = { manejarOperacion("ventas", mercadilloViewModel, navController) },
                            onGastosClick = { manejarOperacion("gastos", mercadilloViewModel, navController) },
                            onResumenClick = { manejarOperacion("resumen", mercadilloViewModel, navController) },
                            onCambiarMercadillo = { mercadilloViewModel.cambiarMercadilloActivo() },
                            currentLanguage = currentLanguage
                        )
                    }
                }
            ) { paddingValues ->
                // =================== AJUSTE DE LAYOUT ===================
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues)
                        .background(MaterialTheme.colorScheme.background)
                ) {
                    // Bloque principal que ocupa el espacio disponible
                    Column(
                        modifier = Modifier
                            .weight(1f)
                            .fillMaxWidth()
                    ) {
                        // ========== CALENDARIO CON MERCADILLOS ==========
                        Card(
                            modifier = Modifier
                                .fillMaxWidth()
                                .height(350.dp) // altura fija
                                .padding(horizontal = 16.dp, vertical = 8.dp),
                            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
                            colors = CardDefaults.cardColors(
                                containerColor = MaterialTheme.colorScheme.surface
                            )
                        ) {
                            Column(
                                modifier = Modifier
                                    .fillMaxSize()
                                    .padding(16.dp)
                            ) {
                                // Header del calendario con navegaci√≥n entre meses
                                Row(
                                    modifier = Modifier.fillMaxWidth(),
                                    horizontalArrangement = Arrangement.SpaceBetween,
                                    verticalAlignment = Alignment.CenterVertically
                                ) {
                                    // Flecha mes anterior
                                    IconButton(
                                        onClick = { mercadilloViewModel.navegarMesAnterior() }
                                    ) {
                                        Text(
                                            text = "‚Üê",
                                            fontSize = 20.sp,
                                            color = MaterialTheme.colorScheme.primary
                                        )
                                    }

                                    // T√≠tulo del mes y a√±o
                                    Text(
                                        text = nombreMesActual,
                                        style = MaterialTheme.typography.titleLarge,
                                        fontWeight = FontWeight.Bold,
                                        color = MaterialTheme.colorScheme.onSurface
                                    )

                                    // Flecha mes siguiente
                                    IconButton(
                                        onClick = { mercadilloViewModel.navegarMesSiguiente() }
                                    ) {
                                        Text(
                                            text = "‚Üí",
                                            fontSize = 20.sp,
                                            color = MaterialTheme.colorScheme.primary
                                        )
                                    }

                                    // Bot√≥n de leyenda
                                    IconButton(
                                        onClick = { mostrarLeyenda = true },
                                        modifier = Modifier.size(32.dp)
                                    ) {
                                        Icon(
                                            imageVector = Icons.Default.Info,
                                            contentDescription = StringResourceManager.getString("ver_leyenda", currentLanguage),
                                            tint = MaterialTheme.colorScheme.primary,
                                            modifier = Modifier.size(20.dp)
                                        )
                                    }
                                }

                                Spacer(modifier = Modifier.height(8.dp))

                                // D√≠as de la semana
                                Row(
                                    modifier = Modifier.fillMaxWidth(),
                                    horizontalArrangement = Arrangement.SpaceEvenly
                                ) {
                                    listOf("L", "M", "X", "J", "V", "S", "D").forEach { dia ->
                                        Text(
                                            text = dia,
                                            style = MaterialTheme.typography.bodySmall,
                                            fontWeight = FontWeight.Bold,
                                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f),
                                            modifier = Modifier.weight(1f),
                                            textAlign = TextAlign.Center
                                        )
                                    }
                                }

                                Spacer(modifier = Modifier.height(8.dp))

                                // Grid del calendario
                                CalendarioGrid(
                                    ano = calendarioState.ano,
                                    mes = calendarioState.mes,
                                    mercadillosPorDia = mercadillosPorDia,
                                    onDiaClick = { dia ->
                                        val mercadillosDelDia = mercadillosPorDia[dia] ?: emptyList()
                                        manejarClickDiaCalendario(
                                            mercadillosDelDia,
                                            navController
                                        )
                                    }
                                )
                            }
                        }

                        // ========== CARD PR√ìXIMOS MERCADILLOS ==========
                        CardMercadillosProximos(
                            mercadillosProximos = mercadillosProximos,
                            onMercadilloClick = { mercadillo ->
                                navController?.navigate("editar_mercadillo/${mercadillo.idMercadillo}")
                            }
                        )

                        // ========== ESTADO VAC√çO (debajo del calendario) ==========
                        if (!tieneMercadillos) {
                            Column(
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .padding(32.dp),
                                horizontalAlignment = Alignment.CenterHorizontally,
                                verticalArrangement = Arrangement.Center
                            ) {
                                Icon(
                                    painter = painterResource(id = R.drawable.ic_store),
                                    contentDescription = null,
                                    modifier = Modifier.size(64.dp),
                                    tint = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.4f)
                                )

                                Spacer(modifier = Modifier.height(16.dp))

                                Text(
                                    text = StringResourceManager.getString("sin_mercadillos", currentLanguage),
                                    style = MaterialTheme.typography.titleMedium,
                                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f),
                                    textAlign = TextAlign.Center
                                )

                                Spacer(modifier = Modifier.height(8.dp))

                                Text(
                                    text = StringResourceManager.getString("pulsa_crear_primer_mercadillo", currentLanguage),
                                    style = MaterialTheme.typography.bodyMedium,
                                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f),
                                    textAlign = TextAlign.Center
                                )
                            }
                        }
                    }
                    // üîµ Overlay de descarga/restauraci√≥n
                    when (syncState) {
                        is SyncState.Checking,
                        is SyncState.Downloading,
                        is SyncState.Uploading,
                        is SyncState.Merging -> {
                            Box(
                                modifier = Modifier
                                    .fillMaxSize()
                                    .background(MaterialTheme.colorScheme.background.copy(alpha = 0.6f)),
                                contentAlignment = Alignment.Center
                            ) {
                                Card(
                                    elevation = CardDefaults.cardElevation(8.dp),
                                    colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),
                                    shape = RoundedCornerShape(16.dp)
                                ) {
                                    Column(
                                        modifier = Modifier.padding(20.dp),
                                        horizontalAlignment = Alignment.CenterHorizontally
                                    ) {
                                        CircularProgressIndicator()
                                        Spacer(Modifier.height(12.dp))
                                        val msg = when (syncState) {
                                            is SyncState.Checking    -> "Comprobando datos‚Ä¶"
                                            is SyncState.Downloading -> "Descargando datos‚Ä¶"
                                            is SyncState.Uploading   -> "Subiendo cambios locales‚Ä¶"
                                            is SyncState.Merging     -> "Actualizando datos‚Ä¶"
                                            else -> ""
                                        }
                                        Text(msg, style = MaterialTheme.typography.bodyMedium, fontWeight = FontWeight.Medium)
                                    }
                                }
                            }
                        }
                        is SyncState.Error -> {
                            // Si quieres, muestra un aviso breve; si no, om√≠telo
                        }
                        else -> Unit
                    }


                    // ========== FOOTER ==========
                    FooterMarca()
                }
            }

            // ========== DI√ÅLOGO DE LEYENDA ==========
            if (mostrarLeyenda) {
                LeyendaColoresDialog(
                    onDismiss = { mostrarLeyenda = false },
                    currentLanguage = currentLanguage
                )
            }

            // ========== DI√ÅLOGO DE SELECCI√ìN DE MERCADILLOS (EDICI√ìN) ==========
            if (mostrarDialogoSeleccion) {
                DialogoSeleccionMercadillo(
                    mercadillos = mercadillosParaSeleccionar,
                    onMercadilloSeleccionado = { mercadillo ->
                        mostrarDialogoSeleccion = false
                        navController?.navigate("editar_mercadillo/${mercadillo.idMercadillo}")
                    },
                    onDismiss = { mostrarDialogoSeleccion = false },
                    currentLanguage = currentLanguage
                )
            }

            // ‚úÖ DI√ÅLOGO DE SELECCI√ìN DE MERCADILLO ACTIVO (OPERACIONES)
            if (mostrarDialogoSeleccionActivo) {
                DialogoSeleccionMercadilloActivo(
                    mercadillosEnCurso = mercadillosEnCurso,
                    onMercadilloSeleccionado = { mercadillo ->
                        mercadilloViewModel.seleccionarMercadilloActivo(mercadillo)
                        mostrarDialogoSeleccionActivo = false

                        // Ejecutar la acci√≥n pendiente
                        accionPendiente?.let { accion ->
                            when (accion) {
                                "ventas" -> navController?.navigate("ventas/${mercadillo.idMercadillo}")
                                "gastos" -> navController?.navigate("gastos/${mercadillo.idMercadillo}")
                                "resumen" -> navController?.navigate("resumen/${mercadillo.idMercadillo}")
                            }
                            accionPendiente = null
                        }
                    },
                    onDismiss = {
                        mostrarDialogoSeleccionActivo = false
                        accionPendiente = null
                    },
                    currentLanguage = currentLanguage
                )
            }
        }
    }
}

private fun manejarClickDiaCalendario(
    mercadillosDelDia: List<MercadilloEntity>,
    navController: NavController?
) {
    when (mercadillosDelDia.size) {
        0 -> Unit
        1 -> navController?.navigate("editar_mercadillo/${mercadillosDelDia.first().idMercadillo}")
        else -> {
            // El di√°logo de selecci√≥n se maneja en el estado de la pantalla
        }
    }
}

// Navegaci√≥n desde la Bottombar con selecci√≥n si hay varios activos
private fun manejarOperacion(
    tipoOperacion: String,
    mercadilloViewModel: MercadilloViewModel,
    navController: NavController?
) {
    val (puedeNavegar, mercadillo) = when (tipoOperacion) {
        "ventas" -> mercadilloViewModel.manejarNavegacionVentas()
        "gastos" -> mercadilloViewModel.manejarNavegacionGastos()
        "resumen" -> mercadilloViewModel.manejarNavegacionResumen()
        else -> Pair(false, null)
    }

    if (puedeNavegar && mercadillo != null) {
        when (tipoOperacion) {
            "ventas" -> navController?.navigate("ventas/${mercadillo.idMercadillo}")
            "gastos" -> navController?.navigate("gastos/${mercadillo.idMercadillo}")
            "resumen" -> navController?.navigate("resumen/${mercadillo.idMercadillo}")
        }
    } else {
        // Si no puede navegar directo, el propio ViewModel ya gestiona mostrar selecci√≥n.
    }
}

@Composable
private fun CalendarioGrid(
    ano: Int,
    mes: Int,
    mercadillosPorDia: Map<Int, List<MercadilloEntity>>,
    onDiaClick: (Int) -> Unit
) {
    // Calcular d√≠as del mes y d√≠a de inicio
    val diasDelMes = when (mes) {
        1, 3, 5, 7, 8, 10, 12 -> 31
        4, 6, 9, 11 -> 30
        2 -> if (ano % 4 == 0 && (ano % 100 != 0 || ano % 400 == 0)) 29 else 28
        else -> 31
    }

    // Calcular primer d√≠a del mes (0=lunes, 6=domingo)
    val calendar = java.util.Calendar.getInstance().apply {
        set(ano, mes - 1, 1) // Calendar.MONTH es 0-based
    }
    val primerDiaSemana = (calendar.get(java.util.Calendar.DAY_OF_WEEK) + 5) % 7

    LazyVerticalGrid(
        columns = GridCells.Fixed(7),
        modifier = Modifier.fillMaxWidth(),
        verticalArrangement = Arrangement.spacedBy(4.dp),
        horizontalArrangement = Arrangement.spacedBy(4.dp)
    ) {
        // Espacios vac√≠os para alinear el primer d√≠a del mes
        items(primerDiaSemana) {
            Box(modifier = Modifier.size(40.dp))
        }

        // D√≠as del mes
        items((1..diasDelMes).toList()) { dia ->
            DiaCalendario(
                dia = dia,
                mercadillos = mercadillosPorDia[dia] ?: emptyList(),
                onClick = { onDiaClick(dia) }
            )
        }
    }
}

@Composable
private fun DiaCalendario(
    dia: Int,
    mercadillos: List<MercadilloEntity>,
    onClick: () -> Unit
) {
    // Obtener estados de los mercadillos y ordenar por prioridad
    val estados = mercadillos.map { mercadillo ->
        EstadosMercadillo.Estado.fromCodigo(mercadillo.estado)
            ?: EstadosMercadillo.Estado.PROGRAMADO_PARCIAL
    }.sortedBy { EstadosMercadillo.obtenerPrioridad(it) }

    Box(
        modifier = Modifier
            .size(40.dp)
            .clickable { onClick() }
            .background(
                color = if (estados.size == 1) {
                    // Si hay 1 mercadillo: fondo del color del estado
                    EstadosMercadillo.obtenerColor(estados.first())
                } else {
                    // Si hay 0 o m√∫ltiples: fondo normal
                    MaterialTheme.colorScheme.surface
                },
                shape = RoundedCornerShape(8.dp)
            ),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            // N√∫mero del d√≠a
            Text(
                text = dia.toString(),
                style = MaterialTheme.typography.bodySmall,
                color = if (estados.size == 1) {
                    EstadosMercadillo.obtenerColorTexto(estados.first())
                } else {
                    MaterialTheme.colorScheme.onSurface
                },
                fontWeight = if (mercadillos.isNotEmpty()) FontWeight.Bold else FontWeight.Normal
            )

            // Puntitos si hay m√∫ltiples mercadillos
            if (estados.size > 1) {
                Row(
                    horizontalArrangement = Arrangement.spacedBy(3.dp),
                    modifier = Modifier.padding(top = 2.dp)
                ) {
                    estados.take(2).forEach { estado ->
                        Box(
                            modifier = Modifier
                                .size(6.dp)
                                .background(
                                    EstadosMercadillo.obtenerColor(estado),
                                    CircleShape
                                )
                        )
                    }
                }
            }
        }
    }
}

@Composable
private fun LeyendaColoresDialog(
    onDismiss: () -> Unit,
    currentLanguage: String
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        properties = DialogProperties(usePlatformDefaultWidth = false),
        title = {
            Text(
                text = StringResourceManager.getString("leyenda_estados", currentLanguage),
                style = MaterialTheme.typography.titleLarge,
                fontWeight = FontWeight.Bold
            )
        },
        text = {
            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                EstadosMercadillo.obtenerTodosLosEstados().forEach { estado ->
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        // C√≠rculo de color
                        Box(
                            modifier = Modifier
                                .size(16.dp)
                                .background(
                                    EstadosMercadillo.obtenerColor(estado),
                                    CircleShape
                                )
                        )

                        Spacer(modifier = Modifier.width(12.dp))

                        // Icono
                        Text(
                            text = EstadosMercadillo.obtenerIcono(estado),
                            fontSize = 16.sp
                        )

                        Spacer(modifier = Modifier.width(8.dp))

                        // Descripci√≥n
                        Text(
                            text = estado.descripcion,
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.onSurface
                        )
                    }
                }
            }
        },
        confirmButton = {
            TextButton(onClick = onDismiss) {
                Text(StringResourceManager.getString("entendido", currentLanguage))
            }
        }
    )
}

@Composable
private fun DialogoSeleccionMercadillo(
    mercadillos: List<MercadilloEntity>,
    onMercadilloSeleccionado: (MercadilloEntity) -> Unit,
    onDismiss: () -> Unit,
    currentLanguage: String
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = {
            Text(
                text = "Seleccionar mercadillo",
                style = MaterialTheme.typography.titleLarge,
                fontWeight = FontWeight.Bold
            )
        },
        text = {
            LazyColumn(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                items(mercadillos) { mercadillo ->
                    Card(
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable { onMercadilloSeleccionado(mercadillo) },
                        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
                    ) {
                        Column(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(12.dp)
                        ) {
                            // T√≠tulo con lugar
                            Text(
                                text = mercadillo.lugar,
                                style = MaterialTheme.typography.titleMedium,
                                fontWeight = FontWeight.Bold,
                                color = MaterialTheme.colorScheme.onSurface
                            )

                            Spacer(modifier = Modifier.height(4.dp))

                            // Organizador y horario
                            Text(
                                text = "${mercadillo.organizador} ‚Ä¢ ${mercadillo.horaInicio} - ${mercadillo.horaFin}",
                                style = MaterialTheme.typography.bodyMedium,
                                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                            )

                            Spacer(modifier = Modifier.height(4.dp))

                            // Estado
                            val estado = EstadosMercadillo.Estado.fromCodigo(mercadillo.estado)
                            if (estado != null) {
                                Row(verticalAlignment = Alignment.CenterVertically) {
                                    Text(
                                        text = EstadosMercadillo.obtenerIcono(estado),
                                        fontSize = 12.sp
                                    )
                                    Spacer(modifier = Modifier.width(4.dp))
                                    Text(
                                        text = estado.descripcion,
                                        style = MaterialTheme.typography.bodySmall,
                                        color = EstadosMercadillo.obtenerColor(estado)
                                    )
                                }
                            }
                        }
                    }
                }
            }
        },
        confirmButton = { },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text(StringResourceManager.getString("cancelar", currentLanguage))
            }
        }
    )
}

/**
 * ‚úÖ Card con lista de mercadillos pr√≥ximos
 */
@Composable
fun CardMercadillosProximos(
    mercadillosProximos: List<MercadilloEntity>,
    onMercadilloClick: (MercadilloEntity) -> Unit
) {
    if (mercadillosProximos.isNotEmpty()) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp, vertical = 4.dp),
            elevation = CardDefaults.cardElevation(defaultElevation = 6.dp),
            colors = CardDefaults.cardColors(
                containerColor = MaterialTheme.colorScheme.primaryContainer
            ),
            shape = RoundedCornerShape(12.dp)
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            ) {
                // Header con t√≠tulo y badge de cantidad
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        text = "Pr√≥ximos Mercadillos",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.onPrimaryContainer
                    )
                    Badge(
                        containerColor = MaterialTheme.colorScheme.primary
                    ) {
                        Text(
                            text = mercadillosProximos.size.toString(),
                            color = MaterialTheme.colorScheme.onPrimary,
                            style = MaterialTheme.typography.bodySmall
                        )
                    }
                }

                Spacer(modifier = Modifier.height(12.dp))

                mercadillosProximos.take(3).forEachIndexed { index, mercadillo ->
                    MercadilloProximoItem(
                        mercadillo = mercadillo,
                        onClick = { onMercadilloClick(mercadillo) }
                    )

                    if (index < mercadillosProximos.take(3).size - 1) {
                        Spacer(modifier = Modifier.height(8.dp))
                        HorizontalDivider(
                            color = MaterialTheme.colorScheme.onPrimaryContainer.copy(alpha = 0.2f),
                            thickness = 1.dp
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                    }
                }

                if (mercadillosProximos.size > 3) {
                    Spacer(modifier = Modifier.height(12.dp))

                    Card(
                        modifier = Modifier.fillMaxWidth(),
                        colors = CardDefaults.cardColors(
                            containerColor = MaterialTheme.colorScheme.primary.copy(alpha = 0.1f)
                        ),
                        shape = RoundedCornerShape(8.dp)
                    ) {
                        Text(
                            text = "+ ${mercadillosProximos.size - 3} mercadillos m√°s",
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.primary,
                            fontWeight = FontWeight.Medium,
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(8.dp),
                            textAlign = TextAlign.Center
                        )
                    }
                }
            }
        }
    }
}

@Composable
private fun MercadilloProximoItem(
    mercadillo: MercadilloEntity,
    onClick: () -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable { onClick() }
            .padding(vertical = 4.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Column(modifier = Modifier.weight(1f)) {
            Row(verticalAlignment = Alignment.CenterVertically) {
                Text(text = "üìÖ ", fontSize = 14.sp)
                Text(
                    text = "${mercadillo.fecha} ‚Ä¢ ${mercadillo.horaInicio}",
                    style = MaterialTheme.typography.bodyMedium,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.onPrimaryContainer
                )
            }

            Spacer(modifier = Modifier.height(4.dp))

            Row(verticalAlignment = Alignment.CenterVertically) {
                Text(text = "üìç ", fontSize = 14.sp)
                Text(
                    text = mercadillo.lugar,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onPrimaryContainer,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
            }

            Spacer(modifier = Modifier.height(2.dp))

            Row(verticalAlignment = Alignment.CenterVertically) {
                Text(text = "üë• ", fontSize = 12.sp)
                Text(
                    text = mercadillo.organizador,
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onPrimaryContainer.copy(alpha = 0.8f),
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
            }

            val estado = EstadosMercadillo.Estado.fromCodigo(mercadillo.estado)
            if (estado != null) {
                Spacer(modifier = Modifier.height(4.dp))
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Box(
                        modifier = Modifier
                            .size(8.dp)
                            .background(
                                EstadosMercadillo.obtenerColor(estado),
                                CircleShape
                            )
                    )
                    Spacer(modifier = Modifier.width(6.dp))
                    Text(
                        text = estado.descripcion,
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onPrimaryContainer.copy(alpha = 0.7f),
                        fontSize = 11.sp
                    )
                }
            }

            if (mercadillo.saldoInicial != null) {
                Spacer(modifier = Modifier.height(2.dp))
                Row(verticalAlignment = Alignment.CenterVertically) {
                    Text(text = "üí∞ ", fontSize = 12.sp)
                    Text(
                        text = "‚Ç¨${String.format("%.2f", mercadillo.saldoInicial)}",
                        style = MaterialTheme.typography.bodySmall,
                        color = Color(0xFF4CAF50),
                        fontWeight = FontWeight.Medium,
                        fontSize = 11.sp
                    )
                }
            }
        }

        Column(horizontalAlignment = Alignment.CenterHorizontally) {
            IconButton(
                onClick = onClick,
                modifier = Modifier.size(32.dp)
            ) {
                Text(
                    text = "‚Üí",
                    fontSize = 18.sp,
                    color = MaterialTheme.colorScheme.onPrimaryContainer,
                    fontWeight = FontWeight.Bold
                )
            }
        }
    }
}



// app/src/main/java/es/nuskysoftware/marketsales/ui/pantallas/PantallaMetodoPago.kt
package es.nuskysoftware.marketsales.ui.pantallas

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.StringResourceManager

enum class MetodoPago { EFECTIVO, BIZUM, TARJETA }

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PantallaMetodoPago(
    totalFormateado: String,
    onMetodoSeleccionado: (MetodoPago) -> Unit,
    onBack: () -> Unit
) {
    val currentLanguage by ConfigurationManager.idioma.collectAsState()

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        text = StringResourceManager.getString("metodo_pago", currentLanguage),
                        fontWeight = FontWeight.Bold
                    )
                },
                navigationIcon = {
                    TextButton(onClick = onBack) { Text("‚Üê") }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary,
                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary
                )
            )
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .padding(16.dp),
            horizontalAlignment = androidx.compose.ui.Alignment.CenterHorizontally
        ) {
            Text(
                text = StringResourceManager.getString("selecciona_metodo_pago", currentLanguage),
                style = MaterialTheme.typography.titleMedium
            )

            Spacer(Modifier.height(8.dp))

            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface)
            ) {
                Column(Modifier.fillMaxWidth().padding(16.dp), horizontalAlignment = androidx.compose.ui.Alignment.CenterHorizontally) {
                    Text(
                        text = StringResourceManager.getString("total", currentLanguage),
                        fontSize = 18.sp,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                    Text(
                        text = totalFormateado,
                        fontSize = 32.sp,
                        fontWeight = FontWeight.ExtraBold,
                        color = MaterialTheme.colorScheme.primary
                    )
                }
            }

            Spacer(Modifier.height(16.dp))

            MetodoPagoButton("üí∂", StringResourceManager.getString("efectivo", currentLanguage),
                container = MaterialTheme.colorScheme.primaryContainer,
                content = MaterialTheme.colorScheme.onPrimaryContainer
            ) { onMetodoSeleccionado(MetodoPago.EFECTIVO) }

            Spacer(Modifier.height(12.dp))

            MetodoPagoButton("üì≤", StringResourceManager.getString("bizum", currentLanguage),
                container = MaterialTheme.colorScheme.tertiaryContainer,
                content = MaterialTheme.colorScheme.onTertiaryContainer
            ) { onMetodoSeleccionado(MetodoPago.BIZUM) }

            Spacer(Modifier.height(12.dp))

            MetodoPagoButton("üí≥", StringResourceManager.getString("tarjeta", currentLanguage),
                container = MaterialTheme.colorScheme.secondaryContainer,
                content = MaterialTheme.colorScheme.onSecondaryContainer
            ) { onMetodoSeleccionado(MetodoPago.TARJETA) }
        }
    }
}

@Composable
private fun MetodoPagoButton(
    emoji: String,
    label: String,
    container: androidx.compose.ui.graphics.Color,
    content: androidx.compose.ui.graphics.Color,
    onClick: () -> Unit
) {
    Button(
        onClick = onClick,
        modifier = Modifier.fillMaxWidth().height(64.dp),
        shape = androidx.compose.foundation.shape.RoundedCornerShape(12.dp),
        colors = ButtonDefaults.buttonColors(containerColor = container, contentColor = content)
    ) {
        Text("$emoji  $label", fontSize = 18.sp, fontWeight = FontWeight.SemiBold)
    }
}



// app/src/main/java/es/nuskysoftware/marketsales/ui/pantallas/PantallaPerfil.kt
package es.nuskysoftware.marketsales.ui.pantallas

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.text.KeyboardActions
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Email
import androidx.compose.material.icons.filled.Lock
import androidx.compose.material.icons.filled.Person
import androidx.compose.material.icons.filled.Visibility
import androidx.compose.material.icons.filled.VisibilityOff
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.focus.FocusDirection
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalFocusManager
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.text.input.VisualTransformation
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import kotlinx.coroutines.launch
import android.util.Log
import es.nuskysoftware.marketsales.R
import es.nuskysoftware.marketsales.data.repository.AuthState
import es.nuskysoftware.marketsales.ui.viewmodel.AuthViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.AuthViewModelFactory
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.FooterMarca
import es.nuskysoftware.marketsales.utils.StringResourceManager

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PantallaPerfil(
    navController: NavController? = null
) {
    val context = LocalContext.current
    val focusManager = LocalFocusManager.current
    val scope = rememberCoroutineScope()

    // AuthViewModel para manejar actualizaciones
    val authViewModel: AuthViewModel = viewModel(factory = AuthViewModelFactory(context))
    val authState by authViewModel.authState.collectAsState()
    val currentUser by authViewModel.currentUser.collectAsState()

    // Estados de ConfigurationManager
    val currentLanguage by ConfigurationManager.idioma.collectAsState()
    val usuarioEmail by ConfigurationManager.usuarioEmail.collectAsState()
    val displayName by ConfigurationManager.displayName.collectAsState()

    // Estados locales del formulario
    var nombre by remember { mutableStateOf(displayName ?: "") }
    var email by remember { mutableStateOf(usuarioEmail ?: "") }
    var passwordActual by remember { mutableStateOf("") }
    var passwordNueva by remember { mutableStateOf("") }
    var confirmarPassword by remember { mutableStateOf("") }

    var isPasswordActualVisible by remember { mutableStateOf(false) }
    var isPasswordNuevaVisible by remember { mutableStateOf(false) }
    var isConfirmarPasswordVisible by remember { mutableStateOf(false) }

    var showError by remember { mutableStateOf(false) }
    var showSuccess by remember { mutableStateOf(false) }
    var errorMessage by remember { mutableStateOf("") }
    var successMessage by remember { mutableStateOf("") }

    // Estado de carga para botones individuales
    var isUpdatingInfo by remember { mutableStateOf(false) }
    var isUpdatingPassword by remember { mutableStateOf(false) }

    // Actualizar campos cuando cambie el usuario
    LaunchedEffect(currentUser, displayName, usuarioEmail) {
        nombre = displayName ?: ""
        email = usuarioEmail ?: ""
    }

    // ‚úÖ NUEVO: Actualizar campos cuando se muestre el mensaje de √©xito
    LaunchedEffect(showSuccess) {
        if (showSuccess) {
            kotlinx.coroutines.delay(300)
            val updatedDisplayName = ConfigurationManager.displayName.value
            val updatedEmail = ConfigurationManager.usuarioEmail.value

            Log.d("PantallaPerfil", "üîÑ ConfigurationManager.displayName: $updatedDisplayName")
            Log.d("PantallaPerfil", "üîÑ Campo nombre antes: $nombre")

            if (updatedDisplayName != null) {
                nombre = updatedDisplayName
            }
            if (updatedEmail != null) {
                email = updatedEmail
            }

            Log.d("PantallaPerfil", "üîÑ Campo nombre despu√©s: $nombre")
        }
    }

    // Validaciones
    val isNombreValid = nombre.isNotBlank()
    val isEmailValid = email.contains("@") && email.contains(".")
    val isPasswordActualValid = passwordActual.isNotBlank()
    val isPasswordNuevaValid = passwordNueva.length >= 6
    val isConfirmarPasswordValid = passwordNueva == confirmarPassword
    val canUpdateBasicInfo = isNombreValid && isEmailValid
    val canUpdatePassword = isPasswordActualValid && isPasswordNuevaValid && isConfirmarPasswordValid

    // Manejar estados de AuthViewModel
    LaunchedEffect(authState) {
        when (authState) {
            is AuthState.Error -> {
                errorMessage = (authState as AuthState.Error).message
                showError = true
                showSuccess = false
                isUpdatingInfo = false
                isUpdatingPassword = false
            }
            is AuthState.Authenticated -> {
                isUpdatingInfo = false
                isUpdatingPassword = false
            }
            else -> { }
        }
    }

    LaunchedEffect(displayName) {
        Log.d("PantallaPerfil", "üîÑ ConfigurationManager.displayName: $displayName")
        if (!displayName.isNullOrBlank()) {
            Log.d("PantallaPerfil", "üîÑ Campo nombre antes: $nombre")
            nombre = displayName ?: ""  // ‚úÖ Manejar el nullable
            Log.d("PantallaPerfil", "üîÑ Campo nombre despu√©s: $nombre")
        }
    }
    LaunchedEffect(currentUser, displayName, usuarioEmail) {
        nombre = displayName ?: currentUser?.displayName ?: ""
        email = usuarioEmail ?: currentUser?.email ?: ""
        Log.d("PantallaPerfil", "üîÑ Campos actualizados - nombre: $nombre, email: $email")
    }
    // Funci√≥n para actualizar informaci√≥n b√°sica
    fun updateBasicInfo() {
        scope.launch {
            isUpdatingInfo = true
            showError = false
            showSuccess = false

            try {
                val result = authViewModel.updateUserProfile(
                    displayName = nombre,
                    email = email
                )

                if (result) {
                    successMessage = StringResourceManager.getString("informacion_actualizada", currentLanguage)
                    showSuccess = true
                } else {
                    errorMessage = StringResourceManager.getString("error_actualizar_informacion", currentLanguage)
                    showError = true
                }
            } catch (e: Exception) {
                errorMessage = StringResourceManager.getString("error_generico", currentLanguage).replace("{0}", e.message ?: "")
                showError = true
            } finally {
                isUpdatingInfo = false
            }
        }
    }

    // Funci√≥n para cambiar contrase√±a
    fun updatePassword() {
        scope.launch {
            isUpdatingPassword = true
            showError = false
            showSuccess = false

            try {
                val result = authViewModel.updatePassword(
                    currentPassword = passwordActual,
                    newPassword = passwordNueva
                )

                if (result) {
                    successMessage = StringResourceManager.getString("contrasena_actualizada", currentLanguage)
                    showSuccess = true
                    // Limpiar campos
                    passwordActual = ""
                    passwordNueva = ""
                    confirmarPassword = ""
                } else {
                    errorMessage = StringResourceManager.getString("error_cambiar_contrasena", currentLanguage)
                    showError = true
                }
            } catch (e: Exception) {
                errorMessage = StringResourceManager.getString("error_generico", currentLanguage).replace("{0}", e.message ?: "")
                showError = true
            } finally {
                isUpdatingPassword = false
            }
        }
    }

    // Auto-ocultar mensajes despu√©s de 5 segundos
    LaunchedEffect(showSuccess) {
        if (showSuccess) {
            kotlinx.coroutines.delay(5000)
            showSuccess = false
        }
    }

    LaunchedEffect(showError) {
        if (showError) {
            kotlinx.coroutines.delay(5000)
            showError = false
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        StringResourceManager.getString("perfil", currentLanguage),
                        fontWeight = FontWeight.Bold
                    )
                },
                navigationIcon = {
                    IconButton(onClick = { navController?.popBackStack() }) {
                        Icon(
                            painter = painterResource(id = R.drawable.ic_arrow_left),
                            contentDescription = StringResourceManager.getString("volver", currentLanguage)
                        )
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary,
                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary
                )
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            Column(
                modifier = Modifier
                    .weight(1f)
                    .fillMaxWidth()
                    .verticalScroll(rememberScrollState())
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                // Informaci√≥n de cuenta
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),
                    elevation = CardDefaults.cardElevation(4.dp)
                ) {
                    Column(modifier = Modifier.padding(16.dp)) {
                        Text(
                            text = StringResourceManager.getString("informacion_cuenta", currentLanguage),
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                        Text(
                            text = StringResourceManager.getString("modificar_informacion", currentLanguage),
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                        )
                    }
                }

                // Mensajes de estado (arriba para mejor visibilidad)
                if (showError && errorMessage.isNotEmpty()) {
                    Card(
                        modifier = Modifier.fillMaxWidth(),
                        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.errorContainer)
                    ) {
                        Row(
                            modifier = Modifier.padding(12.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(
                                text = errorMessage,
                                color = MaterialTheme.colorScheme.onErrorContainer,
                                style = MaterialTheme.typography.bodyMedium,
                                modifier = Modifier.weight(1f)
                            )
                            TextButton(onClick = { showError = false }) {
                                Text("‚úï", color = MaterialTheme.colorScheme.onErrorContainer)
                            }
                        }
                    }
                }

                if (showSuccess && successMessage.isNotEmpty()) {
                    Card(
                        modifier = Modifier.fillMaxWidth(),
                        colors = CardDefaults.cardColors(containerColor = Color(0xFF4CAF50).copy(alpha = 0.1f))
                    ) {
                        Row(
                            modifier = Modifier.padding(12.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(
                                text = successMessage,
                                color = Color(0xFF4CAF50),
                                style = MaterialTheme.typography.bodyMedium,
                                modifier = Modifier.weight(1f)
                            )
                            TextButton(onClick = { showSuccess = false }) {
                                Text("‚úï", color = Color(0xFF4CAF50))
                            }
                        }
                    }
                }

                // Formulario de informaci√≥n b√°sica
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),
                    elevation = CardDefaults.cardElevation(4.dp)
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp),
                        verticalArrangement = Arrangement.spacedBy(16.dp)
                    ) {
                        Text(
                            text = StringResourceManager.getString("informacion_personal", currentLanguage),
                            style = MaterialTheme.typography.titleSmall,
                            fontWeight = FontWeight.Bold
                        )

                        // Nombre
                        OutlinedTextField(
                            value = nombre,
                            onValueChange = {
                                nombre = it
                                showError = false
                                showSuccess = false
                            },
                            label = { Text(StringResourceManager.getString("nombre_completo", currentLanguage)) },
                            leadingIcon = { Icon(Icons.Default.Person, contentDescription = null) },
                            modifier = Modifier.fillMaxWidth(),
                            keyboardOptions = KeyboardOptions(
                                keyboardType = KeyboardType.Text,
                                imeAction = ImeAction.Next
                            ),
                            keyboardActions = KeyboardActions(
                                onNext = { focusManager.moveFocus(FocusDirection.Down) }
                            ),
                            isError = nombre.isNotEmpty() && !isNombreValid,
                            supportingText = {
                                if (nombre.isNotEmpty() && !isNombreValid) {
                                    Text(
                                        text = StringResourceManager.getString("nombre_vacio", currentLanguage),
                                        color = MaterialTheme.colorScheme.error
                                    )
                                }
                            },
                            singleLine = true,
                            enabled = !isUpdatingInfo
                        )

                        // Email
                        OutlinedTextField(
                            value = email,
                            onValueChange = {
                                email = it
                                showError = false
                                showSuccess = false
                            },
                            label = { Text(StringResourceManager.getString("correo_electronico", currentLanguage)) },
                            leadingIcon = { Icon(Icons.Default.Email, contentDescription = null) },
                            modifier = Modifier.fillMaxWidth(),
                            keyboardOptions = KeyboardOptions(
                                keyboardType = KeyboardType.Email,
                                imeAction = ImeAction.Done
                            ),
                            keyboardActions = KeyboardActions(
                                onDone = { focusManager.clearFocus() }
                            ),
                            isError = email.isNotEmpty() && !isEmailValid,
                            supportingText = {
                                if (email.isNotEmpty() && !isEmailValid) {
                                    Text(
                                        text = StringResourceManager.getString("email_invalido", currentLanguage),
                                        color = MaterialTheme.colorScheme.error
                                    )
                                }
                            },
                            singleLine = true,
                            enabled = !isUpdatingInfo
                        )

                        // Bot√≥n actualizar informaci√≥n b√°sica
                        Button(
                            onClick = { updateBasicInfo() },
                            modifier = Modifier.fillMaxWidth(),
                            enabled = canUpdateBasicInfo && !isUpdatingInfo && !isUpdatingPassword
                        ) {
                            if (isUpdatingInfo) {
                                CircularProgressIndicator(
                                    modifier = Modifier.size(20.dp),
                                    strokeWidth = 2.dp,
                                    color = MaterialTheme.colorScheme.onPrimary
                                )
                                Spacer(modifier = Modifier.width(8.dp))
                                Text(StringResourceManager.getString("actualizando", currentLanguage))
                            } else {
                                Text(StringResourceManager.getString("actualizar_informacion", currentLanguage))
                            }
                        }
                    }
                }

                // Formulario de cambio de contrase√±a
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),
                    elevation = CardDefaults.cardElevation(4.dp)
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp),
                        verticalArrangement = Arrangement.spacedBy(16.dp)
                    ) {
                        Text(
                            text = StringResourceManager.getString("cambiar_contrasena_titulo", currentLanguage),
                            style = MaterialTheme.typography.titleSmall,
                            fontWeight = FontWeight.Bold
                        )

                        Text(
                            text = StringResourceManager.getString("cambiar_contrasena_descripcion", currentLanguage),
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
                        )

                        // Contrase√±a actual
                        OutlinedTextField(
                            value = passwordActual,
                            onValueChange = {
                                passwordActual = it
                                showError = false
                                showSuccess = false
                            },
                            label = { Text(StringResourceManager.getString("contrasena_actual", currentLanguage)) },
                            leadingIcon = { Icon(Icons.Default.Lock, contentDescription = null) },
                            trailingIcon = {
                                IconButton(onClick = { isPasswordActualVisible = !isPasswordActualVisible }) {
                                    Icon(
                                        imageVector = if (isPasswordActualVisible) Icons.Default.Visibility else Icons.Default.VisibilityOff,
                                        contentDescription = if (isPasswordActualVisible)
                                            StringResourceManager.getString("ocultar_contrasena", currentLanguage)
                                        else
                                            StringResourceManager.getString("mostrar_contrasena", currentLanguage)
                                    )
                                }
                            },
                            visualTransformation = if (isPasswordActualVisible) VisualTransformation.None else PasswordVisualTransformation(),
                            modifier = Modifier.fillMaxWidth(),
                            keyboardOptions = KeyboardOptions(
                                keyboardType = KeyboardType.Password,
                                imeAction = ImeAction.Next
                            ),
                            keyboardActions = KeyboardActions(
                                onNext = { focusManager.moveFocus(FocusDirection.Down) }
                            ),
                            isError = passwordActual.isNotEmpty() && !isPasswordActualValid,
                            supportingText = {
                                if (passwordActual.isNotEmpty() && !isPasswordActualValid) {
                                    Text(
                                        text = StringResourceManager.getString("contrasena_actual_requerida", currentLanguage),
                                        color = MaterialTheme.colorScheme.error
                                    )
                                }
                            },
                            singleLine = true,
                            enabled = !isUpdatingPassword
                        )

                        // Nueva contrase√±a
                        OutlinedTextField(
                            value = passwordNueva,
                            onValueChange = {
                                passwordNueva = it
                                showError = false
                                showSuccess = false
                            },
                            label = { Text(StringResourceManager.getString("nueva_contrasena", currentLanguage)) },
                            leadingIcon = { Icon(Icons.Default.Lock, contentDescription = null) },
                            trailingIcon = {
                                IconButton(onClick = { isPasswordNuevaVisible = !isPasswordNuevaVisible }) {
                                    Icon(
                                        imageVector = if (isPasswordNuevaVisible) Icons.Default.Visibility else Icons.Default.VisibilityOff,
                                        contentDescription = if (isPasswordNuevaVisible)
                                            StringResourceManager.getString("ocultar_contrasena", currentLanguage)
                                        else
                                            StringResourceManager.getString("mostrar_contrasena", currentLanguage)
                                    )
                                }
                            },
                            visualTransformation = if (isPasswordNuevaVisible) VisualTransformation.None else PasswordVisualTransformation(),
                            modifier = Modifier.fillMaxWidth(),
                            keyboardOptions = KeyboardOptions(
                                keyboardType = KeyboardType.Password,
                                imeAction = ImeAction.Next
                            ),
                            keyboardActions = KeyboardActions(
                                onNext = { focusManager.moveFocus(FocusDirection.Down) }
                            ),
                            isError = passwordNueva.isNotEmpty() && !isPasswordNuevaValid,
                            supportingText = {
                                if (passwordNueva.isNotEmpty() && !isPasswordNuevaValid) {
                                    Text(
                                        text = StringResourceManager.getString("contrasena_minimo_caracteres", currentLanguage),
                                        color = MaterialTheme.colorScheme.error
                                    )
                                }
                            },
                            singleLine = true,
                            enabled = !isUpdatingPassword
                        )

                        // Confirmar contrase√±a
                        OutlinedTextField(
                            value = confirmarPassword,
                            onValueChange = {
                                confirmarPassword = it
                                showError = false
                                showSuccess = false
                            },
                            label = { Text(StringResourceManager.getString("confirmar_nueva_contrasena", currentLanguage)) },
                            leadingIcon = { Icon(Icons.Default.Lock, contentDescription = null) },
                            trailingIcon = {
                                IconButton(onClick = { isConfirmarPasswordVisible = !isConfirmarPasswordVisible }) {
                                    Icon(
                                        imageVector = if (isConfirmarPasswordVisible) Icons.Default.Visibility else Icons.Default.VisibilityOff,
                                        contentDescription = if (isConfirmarPasswordVisible)
                                            StringResourceManager.getString("ocultar_contrasena", currentLanguage)
                                        else
                                            StringResourceManager.getString("mostrar_contrasena", currentLanguage)
                                    )
                                }
                            },
                            visualTransformation = if (isConfirmarPasswordVisible) VisualTransformation.None else PasswordVisualTransformation(),
                            modifier = Modifier.fillMaxWidth(),
                            keyboardOptions = KeyboardOptions(
                                keyboardType = KeyboardType.Password,
                                imeAction = ImeAction.Done
                            ),
                            keyboardActions = KeyboardActions(
                                onDone = { focusManager.clearFocus() }
                            ),
                            isError = confirmarPassword.isNotEmpty() && !isConfirmarPasswordValid,
                            supportingText = {
                                if (confirmarPassword.isNotEmpty() && !isConfirmarPasswordValid) {
                                    Text(
                                        text = StringResourceManager.getString("contrasenas_no_coinciden", currentLanguage),
                                        color = MaterialTheme.colorScheme.error
                                    )
                                }
                            },
                            singleLine = true,
                            enabled = !isUpdatingPassword
                        )

                        // Bot√≥n cambiar contrase√±a
                        Button(
                            onClick = { updatePassword() },
                            modifier = Modifier.fillMaxWidth(),
                            enabled = canUpdatePassword && !isUpdatingPassword && !isUpdatingInfo
                        ) {
                            if (isUpdatingPassword) {
                                CircularProgressIndicator(
                                    modifier = Modifier.size(20.dp),
                                    strokeWidth = 2.dp,
                                    color = MaterialTheme.colorScheme.onPrimary
                                )
                                Spacer(modifier = Modifier.width(8.dp))
                                Text(StringResourceManager.getString("cambiando", currentLanguage))
                            } else {
                                Text(StringResourceManager.getString("cambiar_contrasena_btn", currentLanguage))
                            }
                        }
                    }
                }
            }

            // Footer
            FooterMarca()
        }
    }
}

// app/src/main/java/es/nuskysoftware/marketsales/ui/pantallas/PantallaResumenVentas.kt
package es.nuskysoftware.marketsales.ui.pantallas

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel
import es.nuskysoftware.marketsales.data.local.database.AppDatabase
import es.nuskysoftware.marketsales.data.local.entity.LineaVentaEntity
import es.nuskysoftware.marketsales.ui.viewmodel.MercadilloViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.MercadilloViewModelFactory
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.MonedaUtils
import androidx.compose.ui.res.painterResource
import es.nuskysoftware.marketsales.R

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PantallaResumenVentas(
    mercadilloId: String,
    onBack: () -> Unit
) {
    val context = LocalContext.current

    // Mercadillo (para mostrar el lugar en la cabecera)
    val mercadilloVm: MercadilloViewModel = viewModel(factory = MercadilloViewModelFactory(context))
    LaunchedEffect(mercadilloId) { mercadilloVm.cargarMercadillo(mercadilloId) }
    val mercadillo by mercadilloVm.mercadilloParaEditar.collectAsState()

    // L√≠neas de venta del mercadillo
    val lineasVentaDao = remember { AppDatabase.getDatabase(context).lineasVentaDao() }
    val lineas by remember(mercadilloId) {
        lineasVentaDao.obtenerLineasPorMercadillo(mercadilloId)
    }.collectAsState(initial = emptyList())

    // Recibos del mercadillo (para saber m√©todo de pago por idRecibo)
    val recibosDao = remember { AppDatabase.getDatabase(context).recibosDao() }
    val recibos by remember(mercadilloId) {
        recibosDao.obtenerRecibosPorMercadillo(mercadilloId)
    }.collectAsState(initial = emptyList())

    // Mapa idRecibo -> metodoPago
    val metodoPorRecibo = remember(recibos) {
        recibos.associate { it.idRecibo to it.metodoPago }
    }

    val moneda by ConfigurationManager.moneda.collectAsState()
    val totalMercadillo = remember(lineas, moneda) { lineas.sumOf { it.subtotal } }
    val totalFmt = MonedaUtils.formatearImporte(totalMercadillo, moneda)

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        text = mercadillo?.lugar ?: "",
                        fontWeight = FontWeight.Bold
                    )
                },
                navigationIcon = {
                    IconButton(onClick = onBack) {
                        Icon(
                            painter = painterResource(id = R.drawable.ic_arrow_left),
                            contentDescription = "Atr√°s"
                        )
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary,
                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary
                )
            )
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
        ) {
            // Encabezado
            Text(
                text = "Resumen de ventas",
                style = MaterialTheme.typography.titleMedium,
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp, vertical = 8.dp)
            )

            // Lista de l√≠neas (cards horizontales y estrechos)
            LazyColumn(
                modifier = Modifier
                    .weight(1f)
                    .fillMaxWidth(),
                contentPadding = PaddingValues(12.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                items(lineas, key = { it.idLinea }) { linea ->
                    LineaResumenCard(
                        linea = linea,
                        moneda = moneda,
                        metodoPago = metodoPorRecibo[linea.idRecibo] ?: ""
                    )
                }
            }

            // Total al final
            Divider()
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp, vertical = 12.dp),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Total de ventas", fontSize = 16.sp, fontWeight = FontWeight.SemiBold)
                Text(
                    text = totalFmt,
                    fontSize = 18.sp,
                    fontWeight = FontWeight.ExtraBold
                )
            }
        }
    }
}

@Composable
private fun LineaResumenCard(
    linea: LineaVentaEntity,
    moneda: String,
    metodoPago: String
) {
    val precioUnitFmt = remember(linea, moneda) {
        MonedaUtils.formatearImporte(linea.precioUnitario, moneda)
    }
    val totalLineaFmt = remember(linea, moneda) {
        MonedaUtils.formatearImporte(linea.subtotal, moneda)
    }

    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 12.dp, vertical = 10.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // üîπ Icono m√©todo de pago (badge emoji) + cantidad
            MetodoPagoBadge(metodoPago = metodoPago)
            Spacer(Modifier.width(10.dp))
            Text(
                text = linea.cantidad.toString(),
                fontWeight = FontWeight.Bold,
                modifier = Modifier.width(36.dp)
            )

            // Descripci√≥n
            Column(
                modifier = Modifier.weight(1f)
            ) {
                Text(text = linea.descripcion, fontWeight = FontWeight.Medium)
                Text(
                    text = "PU: $precioUnitFmt",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }

            // Total de la l√≠nea
            Text(
                text = totalLineaFmt,
                fontWeight = FontWeight.SemiBold
            )
        }
    }
}

/**
 * Badge redondo con emoji por m√©todo de pago
 * - efectivo -> üí∂
 * - bizum    -> üì≤
 * - tarjeta  -> üí≥
 * - otro     -> üí∞
 */
@Composable
private fun MetodoPagoBadge(metodoPago: String) {
    val emoji = when (metodoPago.lowercase()) {
        "efectivo" -> "üí∂"
        "bizum" -> "üì≤"
        "tarjeta" -> "üí≥"
        else -> "üí∞"
    }
    Surface(
        shape = CircleShape,
        color = MaterialTheme.colorScheme.primaryContainer,
        contentColor = MaterialTheme.colorScheme.onPrimaryContainer
    ) {
        Text(
            text = emoji,
            modifier = Modifier
                .size(28.dp)
                .wrapContentSize(Alignment.Center),
            textAlign = TextAlign.Center,
            fontSize = 16.sp
        )
    }
}


// app/src/main/java/es/nuskysoftware/marketsales/ui/pantallas/PantallaVentas.kt
package es.nuskysoftware.marketsales.ui.pantallas

import android.annotation.SuppressLint
import android.net.Uri
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import es.nuskysoftware.marketsales.R
import es.nuskysoftware.marketsales.data.local.entity.MercadilloEntity
import es.nuskysoftware.marketsales.data.repository.PestanaVenta
import es.nuskysoftware.marketsales.data.repository.MetodoPago as MetodoPagoRepo
import es.nuskysoftware.marketsales.ui.composables.PestanaVentaManual
import es.nuskysoftware.marketsales.ui.composables.PestanaVentaProductos
import es.nuskysoftware.marketsales.ui.viewmodel.VentasViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.VentasViewModelFactory
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.flow.filterNotNull

@SuppressLint("UnrememberedGetBackStackEntry")
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PantallaVentas(
    navController: NavController,
    mercadilloActivo: MercadilloEntity
) {
    val context = androidx.compose.ui.platform.LocalContext.current
    val ventasViewModel: VentasViewModel = viewModel(
        factory = VentasViewModelFactory(context)
    )

    val uiState by ventasViewModel.uiState.collectAsState()
    val snackbarHostState = remember { SnackbarHostState() }

    // Inicializa VM
    LaunchedEffect(mercadilloActivo.idMercadillo, mercadilloActivo.userId) {
        ventasViewModel.inicializar(
            mercadilloId = mercadilloActivo.idMercadillo,
            usuarioId = mercadilloActivo.userId
        )
    }

    // Consume ‚Äúfinalizar venta‚Äù al volver del recibo
    val ventasRoute = remember(mercadilloActivo.idMercadillo) {
        "ventas/${mercadilloActivo.idMercadillo}"
    }
    val ventasBackEntry = remember(navController, ventasRoute) {
        navController.getBackStackEntry(ventasRoute)
    }
    val finalizarMetodoFlow =
        remember(ventasBackEntry) { ventasBackEntry.savedStateHandle.getStateFlow<String?>("finalizar_metodo", null) }

    LaunchedEffect(finalizarMetodoFlow) {
        finalizarMetodoFlow.filterNotNull().collectLatest { metodoStr ->
            val metodoRepo = when (metodoStr.lowercase()) {
                "efectivo" -> MetodoPagoRepo.EFECTIVO
                "bizum" -> MetodoPagoRepo.BIZUM
                else -> MetodoPagoRepo.TARJETA
            }
            ventasViewModel.finalizarVenta(metodoRepo)
            ventasBackEntry.savedStateHandle["finalizar_metodo"] = null
        }
    }

    // Errores
    LaunchedEffect(uiState.error) {
        uiState.error?.let { snackbarHostState.showSnackbar(it); ventasViewModel.limpiarError() }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        text = "Nueva Venta - ${mercadilloActivo.lugar}",
                        fontWeight = FontWeight.Bold
                    )
                },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(
                            painter = painterResource(id = R.drawable.ic_arrow_left),
                            contentDescription = "Atr√°s"
                        )
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary,
                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary
                )
            )
        },
        snackbarHost = { SnackbarHost(snackbarHostState) }
    ) { paddingValues ->

        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            TabRow(
                selectedTabIndex = when (uiState.pestanaActiva) {
                    PestanaVenta.MANUAL -> 0
                    PestanaVenta.PRODUCTOS -> 1
                }
            ) {
                Tab(
                    selected = uiState.pestanaActiva == PestanaVenta.MANUAL,
                    onClick = { ventasViewModel.cambiarPestana(PestanaVenta.MANUAL) },
                    text = { Text("Venta Manual") }
                )
                Tab(
                    selected = uiState.pestanaActiva == PestanaVenta.PRODUCTOS,
                    onClick = { ventasViewModel.cambiarPestana(PestanaVenta.PRODUCTOS) },
                    text = { Text("Productos") },
                    enabled = true
                )
            }

            when (uiState.pestanaActiva) {
                PestanaVenta.MANUAL -> {
                    PestanaVentaManual(
                        ventasViewModel = ventasViewModel,
                        navController = navController,                  // üëà ahora se pasa
                        mercadilloActivo = mercadilloActivo,            // üëà ahora se pasa
                        onRealizarCargo = { totalFmt ->
                            navController.navigate(
                                "metodo_pago/${mercadilloActivo.idMercadillo}/${Uri.encode(totalFmt)}"
                            )
                        }
                    )
                }
                PestanaVenta.PRODUCTOS -> {
                    PestanaVentaProductos(
                        ventasViewModel = ventasViewModel,
                        navController = navController,                  // üëà ahora se pasa
                        mercadilloActivo = mercadilloActivo,            // üëà ahora se pasa
                        onRealizarCargo = { totalFmt ->
                            navController.navigate(
                                "metodo_pago/${mercadilloActivo.idMercadillo}/${Uri.encode(totalFmt)}"
                            )
                        }
                    )
                }
            }
        }
    }
}


package es.nuskysoftware.marketsales.ui.pantallas

import androidx.compose.animation.core.*
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.scale
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import es.nuskysoftware.marketsales.R

@Composable
fun PantallaSplash() {
    // Animaci√≥n de escala
    val infiniteTransition = rememberInfiniteTransition(label = "splash_animation")
    val scale by infiniteTransition.animateFloat(
        initialValue = 0.8f,
        targetValue = 1.2f,
        animationSpec = infiniteRepeatable(
            animation = tween(1000, easing = EaseInOutCubic),
            repeatMode = RepeatMode.Reverse
        ),
        label = "scale_animation"
    )

    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(
                brush = Brush.verticalGradient(
                    colors = listOf(
                        MaterialTheme.colorScheme.primary,
                        MaterialTheme.colorScheme.primaryContainer
                    )
                )
            ),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            // Logo animado
            Card(
                modifier = Modifier
                    .size(120.dp)
                    .scale(scale),
                shape = RoundedCornerShape(60.dp),
                elevation = CardDefaults.cardElevation(defaultElevation = 8.dp),
                colors = CardDefaults.cardColors(
                    containerColor = MaterialTheme.colorScheme.surface
                )
            ) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Image(
                        painter = painterResource(id = R.drawable.ic_store),
                        contentDescription = "Market Sales Logo",
                        modifier = Modifier.size(80.dp)
                    )
                }
            }

            Spacer(modifier = Modifier.height(24.dp))

            // T√≠tulo
            Text(
                text = "Market Sales",
                fontSize = 32.sp,
                fontWeight = FontWeight.Bold,
                color = MaterialTheme.colorScheme.onPrimary
            )

            Spacer(modifier = Modifier.height(8.dp))

            // Subt√≠tulo
            Text(
                text = "Gesti√≥n de Mercadillos",
                fontSize = 16.sp,
                color = MaterialTheme.colorScheme.onPrimary.copy(alpha = 0.8f)
            )

            Spacer(modifier = Modifier.height(48.dp))

            // Indicador de carga
            CircularProgressIndicator(
                modifier = Modifier.size(32.dp),
                color = MaterialTheme.colorScheme.onPrimary,
                strokeWidth = 3.dp
            )
        }
    }
}

// app/src/main/java/es/nuskysoftware/marketsales/ui/pantallas/PantallaVentasCarrito.kt
package es.nuskysoftware.marketsales.ui.pantallas

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import es.nuskysoftware.marketsales.ui.viewmodel.VentasViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.VentasViewModelFactory
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.MonedaUtils

/**
 * Carrito de la compra (edici√≥n del ticket en curso)
 * - Encabezado: idRecibo provisional (RC hhmmss - IDIOMA)
 * - Lista de l√≠neas en tarjetas horizontales
 * - Editar unidades y precio unitario
 * - Eliminar l√≠nea
 * - Total al pie y botones Cancelar/Aceptar
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PantallaVentasCarrito(
    navController: NavController,
    // Para compartir el mismo VM de PantallaVentas, p√°same su backStackEntry si lo usas as√≠
    ventasViewModel: VentasViewModel? = null
) {
    val context = androidx.compose.ui.platform.LocalContext.current

    // Si no inyectan VM (porque llamas directo), crea uno normal; si compartes, p√°salo desde el host
    val vm = ventasViewModel ?: viewModel<VentasViewModel>(factory = VentasViewModelFactory(context))

    val uiState by vm.uiState.collectAsState()
    val moneda by ConfigurationManager.moneda.collectAsState()
    val idioma by ConfigurationManager.idioma.collectAsState()

    // Id provisional para mostrar (no se usa para persistir)
    val idReciboHeader by remember {
        mutableStateOf("RC" + java.text.SimpleDateFormat("HHmmss").format(java.util.Date()) + "-" + idioma.uppercase())
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text(text = idReciboHeader) },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(painter = androidx.compose.ui.res.painterResource(id = es.nuskysoftware.marketsales.R.drawable.ic_arrow_left), contentDescription = "Atr√°s")
                    }
                },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary,
                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary
                )
            )
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .padding(12.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            // Lista de l√≠neas
            LazyColumn(
                modifier = Modifier
                    .weight(1f)
                    .fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                items(uiState.lineasTicket, key = { it.id }) { linea ->
                    Card(
                        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),
                        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
                    ) {
                        Column(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(12.dp)
                        ) {
                            // Descripci√≥n
                            Text(text = linea.descripcion, style = MaterialTheme.typography.titleMedium)

                            Spacer(Modifier.height(8.dp))

                            Row(
                                modifier = Modifier.fillMaxWidth(),
                                horizontalArrangement = Arrangement.spacedBy(12.dp),
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                // Unidades (‚Äì  [qty]  +)
                                Row(verticalAlignment = Alignment.CenterVertically) {
                                    TextButton(
                                        onClick = {
                                            val nueva = (linea.cantidad - 1).coerceAtLeast(0)
                                            vm.editarCantidadLinea(linea.id, nueva)
                                        }
                                    ) { Text("‚Äì") }

                                    Text(text = linea.cantidad.toString(), modifier = Modifier.widthIn(min = 24.dp))

                                    TextButton(onClick = { vm.editarCantidadLinea(linea.id, linea.cantidad + 1) }) {
                                        Text("+")
                                    }
                                }

                                // Precio unitario (editable)
                                var precioTxt by remember(linea.id, linea.precioUnitario) {
                                    mutableStateOf(
                                        // mostramos con coma si as√≠ formateas en UI
                                        String.format(java.util.Locale.US, "%.2f", linea.precioUnitario).replace('.', ',')
                                    )
                                }


                                // Total (calculado)
                                Text(
                                    text = MonedaUtils.formatearImporte(linea.subtotal, moneda),
                                    style = MaterialTheme.typography.titleMedium,
                                    modifier = Modifier.weight(1f)
                                )

                                // Eliminar
                                IconButton(onClick = { vm.eliminarLinea(linea.id) }) {
                                    Icon(imageVector = Icons.Default.Delete, contentDescription = "Eliminar")
                                }
                            }
                        }
                    }
                }
            }

            // Total
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(text = "Total", style = MaterialTheme.typography.titleMedium)
                Text(
                    text = MonedaUtils.formatearImporte(uiState.totalTicket, moneda),
                    style = MaterialTheme.typography.titleLarge,
                    color = MaterialTheme.colorScheme.primary
                )
            }

            // Botonera
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(top = 4.dp),
                horizontalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                OutlinedButton(
                    onClick = { navController.popBackStack() },
                    modifier = Modifier.weight(1f).height(48.dp)
                ) { Text("Cancelar") }

                Button(
                    onClick = { navController.popBackStack() }, // los cambios ya est√°n en el VM
                    modifier = Modifier.weight(1f).height(48.dp)
                ) { Text("Aceptar") }
            }
        }
    }
}

package es.nuskysoftware.marketsales.ui.theme

import androidx.compose.material3.ColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.staticCompositionLocalOf
import androidx.compose.ui.graphics.Color

// ================= COLORES PRINCIPALES - VERDE PASTEL =================

// ------------------- Tema Claro - Verde Pastel M√ÅS SUAVE -------------------
val PrimaryLight = Color(0xFF81C784)        // Verde pastel m√°s suave
val OnPrimaryLight = Color(0xFFFFFFFF)      // Blanco sobre verde
val SecondaryLight = Color(0xFFA5D6A7)      // Verde pastel muy claro
val OnSecondaryLight = Color(0xFF2E7D32)    // Verde oscuro sobre verde pastel
val BackgroundLight = Color(0xFFF1F8E9)     // Verde muy claro de fondo
val OnBackgroundLight = Color(0xFF1B5E20)   // Verde muy oscuro para texto

// ------------------- Tema Oscuro - Verde Pastel M√ÅS SUAVE -------------------
val PrimaryDark = Color(0xFF66BB6A)         // Verde pastel medio para oscuro
val OnPrimaryDark = Color(0xFF1B5E20)       // Verde muy oscuro sobre verde pastel
val SecondaryDark = Color(0xFF81C784)       // Verde pastel m√°s claro
val OnSecondaryDark = Color(0xFF2E7D32)     // Verde oscuro sobre verde pastel
val BackgroundDark = Color(0xFF1B5E20)      // Verde muy oscuro de fondo
val OnBackgroundDark = Color(0xFFC8E6C9)    // Verde claro para texto

// ================= COLORES EXTENDIDOS PERSONALIZADOS =================

// ------------------- Extendidos Claro -------------------
val SuccessLight = Color(0xFF4CAF50)        // Verde √©xito
val OnSuccessLight = Color(0xFFFFFFFF)      // Blanco sobre verde
val WarningLight = Color(0xFFFF9800)        // Naranja advertencia
val OnWarningLight = Color(0xFFFFFFFF)      // Blanco sobre naranja
val ErrorLight = Color(0xFFF44336)          // Rojo error
val OnErrorLight = Color(0xFFFFFFFF)        // Blanco sobre rojo
val InfoLight = Color(0xFF4CAF50)           // Verde informaci√≥n (en vez de azul)
val OnInfoLight = Color(0xFFFFFFFF)         // Blanco sobre verde info

val SurfaceLight = Color(0xFFFFFFFF)        // Superficie blanca
val OnSurfaceLight = Color(0xFF2E7D32)      // Verde oscuro sobre superficie
val SurfaceVariantLight = Color(0xFFC8E6C9) // Superficie variante verde claro
val OnSurfaceVariantLight = Color(0xFF1B5E20) // Verde muy oscuro sobre superficie variante

// ------------------- Extendidos Oscuro -------------------
val SuccessDark = Color(0xFF388E3C)         // Verde √©xito oscuro
val OnSuccessDark = Color(0xFFFFFFFF)       // Blanco sobre verde oscuro
val WarningDark = Color(0xFFF57C00)         // Naranja advertencia oscuro
val OnWarningDark = Color(0xFFFFFFFF)       // Blanco sobre naranja oscuro
val ErrorDark = Color(0xFFD32F2F)           // Rojo error oscuro
val OnErrorDark = Color(0xFFFFFFFF)         // Blanco sobre rojo oscuro
val InfoDark = Color(0xFF388E3C)            // Verde informaci√≥n oscuro
val OnInfoDark = Color(0xFFFFFFFF)          // Blanco sobre verde info oscuro

val SurfaceDark = Color(0xFF2E7D32)         // Superficie verde oscuro
val OnSurfaceDark = Color(0xFFA5D6A7)       // Verde claro sobre superficie oscura
val SurfaceVariantDark = Color(0xFF1B5E20)  // Superficie variante verde muy oscuro
val OnSurfaceVariantDark = Color(0xFF81C784) // Verde pastel sobre superficie variante

// ================= CLASE PARA COLORES EXTENDIDOS =================

data class ExtendedColors(
    val success: Color,
    val onSuccess: Color,
    val warning: Color,
    val onWarning: Color,
    val error: Color,
    val onError: Color,
    val info: Color,
    val onInfo: Color,
    val surface: Color,
    val onSurface: Color,
    val surfaceVariant: Color,
    val onSurfaceVariant: Color
)

// ------------------- Instancias de colores extendidos -------------------
val LightExtendedColors = ExtendedColors(
    success = SuccessLight,
    onSuccess = OnSuccessLight,
    warning = WarningLight,
    onWarning = OnWarningLight,
    error = ErrorLight,
    onError = OnErrorLight,
    info = InfoLight,
    onInfo = OnInfoLight,
    surface = SurfaceLight,
    onSurface = OnSurfaceLight,
    surfaceVariant = SurfaceVariantLight,
    onSurfaceVariant = OnSurfaceVariantLight
)

val DarkExtendedColors = ExtendedColors(
    success = SuccessDark,
    onSuccess = OnSuccessDark,
    warning = WarningDark,
    onWarning = OnWarningDark,
    error = ErrorDark,
    onError = OnErrorDark,
    info = InfoDark,
    onInfo = OnInfoDark,
    surface = SurfaceDark,
    onSurface = OnSurfaceDark,
    surfaceVariant = SurfaceVariantDark,
    onSurfaceVariant = OnSurfaceVariantDark
)

// ================= COMPOSITION LOCAL PARA ACCESO GLOBAL =================

val LocalExtendedColors = staticCompositionLocalOf {
    LightExtendedColors
}

// ================= EXTENSI√ìN PARA ACCESO F√ÅCIL =================

val ColorScheme.extended: ExtendedColors
    @Composable
    get() = LocalExtendedColors.current

// ================= COLORES ADICIONALES VERDE PASTEL =================

// Colores espec√≠ficos de la aplicaci√≥n
val PrimaryGreen = Color(0xFF4CAF50)
val SecondaryGreenLight = Color(0xFF81C784)
val AccentGreenPastel = Color(0xFFA5D6A7)
val WarningOrange = Color(0xFFFF9800)

// Verdes para fondos y bordes
val Green50 = Color(0xFFF1F8E9)
val Green100 = Color(0xFFC8E6C9)
val Green200 = Color(0xFFA5D6A7)
val Green300 = Color(0xFF81C784)
val Green400 = Color(0xFF66BB6A)
val Green500 = Color(0xFF4CAF50)
val Green600 = Color(0xFF43A047)
val Green700 = Color(0xFF388E3C)
val Green800 = Color(0xFF2E7D32)
val Green900 = Color(0xFF1B5E20)

// Colores verde pastel suave para Market Sales
val VerdePrimario = Color(0xFF90EE90)      // Verde claro pastel
val VerdeSecundario = Color(0xFF98FB98)     // Verde p√°lido
val VerdeTerciario = Color(0xFFAFEEAF)      // Verde muy claro

// Colores de fondo y superficie
val FondoClaro = Color(0xFFF5F5F5)          // Gris muy claro
val BlancoTexto = Color(0xFFFFFFFF)         // Blanco puro
val NegroTexto = Color(0xFF000000)          // Negro puro
val GrisOscuro = Color(0xFF424242)          // Gris oscuro para modo oscuro

// Colores adicionales
val GrisClaro = Color(0xFFE0E0E0)           // Gris claro para bordes
val AzulAccento = Color(0xFF2196F3)         // Azul para enlaces
val RojoError = Color(0xFFF44336)           // Rojo para errores
val VerdeExito = Color(0xFF4CAF50)          // Verde para √©xito

// app/src/main/java/es/nuskysoftware/marketsales/ui/theme/LocalConfiguration.kt
package es.nuskysoftware.marketsales.ui.theme

import androidx.compose.runtime.Composable
import androidx.compose.runtime.compositionLocalOf
import es.nuskysoftware.marketsales.utils.ConfigurationManager

/**
 * CompositionLocal que proporciona acceso al ConfigurationManager
 * en cualquier parte del √°rbol de composici√≥n
 */
val LocalConfigurationManager = compositionLocalOf<ConfigurationManager> {
    error("ConfigurationManager no proporcionado")
}

/**
 * Funci√≥n para acceder al ConfigurationManager actual
 */
@Composable
fun getConfigurationManager(): ConfigurationManager {
    return LocalConfigurationManager.current
}

package es.nuskysoftware.marketsales.ui.theme

import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.Shapes
import androidx.compose.ui.unit.dp

/**
 * Shape.kt - Market Sales
 * Definici√≥n de formas para componentes Material3
 */

val Shapes = Shapes(
    // Formas peque√±as - para botones, chips, etc.
    small = RoundedCornerShape(4.dp),

    // Formas medianas - para cards, dialogs, etc.
    medium = RoundedCornerShape(8.dp),

    // Formas grandes - para bottom sheets, navigation drawers, etc.
    large = RoundedCornerShape(16.dp)
)

// Formas personalizadas adicionales
object CustomShapes {
    val extraSmall = RoundedCornerShape(2.dp)
    val extraLarge = RoundedCornerShape(24.dp)
    val circular = RoundedCornerShape(50)

    // Formas espec√≠ficas para la app
    val cardShape = RoundedCornerShape(12.dp)
    val buttonShape = RoundedCornerShape(8.dp)
    val fabShape = RoundedCornerShape(16.dp)
    val dialogShape = RoundedCornerShape(20.dp)
}

// app/src/main/java/es/nuskysoftware/marketsales/ui/theme/Theme.kt
package es.nuskysoftware.marketsales.ui.theme

import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.CompositionLocalProvider
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue

// Esquema de colores claro con verde pastel suave
private val LightColorScheme = lightColorScheme(
    primary = VerdePrimario,
    onPrimary = BlancoTexto,
    secondary = VerdeSecundario,
    onSecondary = BlancoTexto,
    tertiary = VerdeTerciario,
    background = FondoClaro,
    surface = BlancoTexto,
    onBackground = NegroTexto,
    onSurface = NegroTexto
)

// Esquema de colores oscuro con verde pastel suave adaptado
private val DarkColorScheme = darkColorScheme(
    primary = VerdePrimario,
    onPrimary = BlancoTexto,
    secondary = VerdeSecundario,
    onSecondary = BlancoTexto,
    tertiary = VerdeTerciario,
    background = NegroTexto,
    surface = GrisOscuro,
    onBackground = BlancoTexto,
    onSurface = BlancoTexto
)

@Composable
fun MarketSalesTheme(
    configurationManager: es.nuskysoftware.marketsales.utils.ConfigurationManager,
    content: @Composable () -> Unit
) {
    // Observar cambios usando los StateFlow que S√ç existen
    val isDarkTheme by configurationManager.temaOscuro.collectAsState()
    val currentFont by configurationManager.fuente.collectAsState()

    // Seleccionar esquema de colores
    val colorScheme = if (isDarkTheme) {
        DarkColorScheme
    } else {
        LightColorScheme
    }

    // Obtener tipograf√≠a basada en la fuente configurada
    val typography = getTypographyForFont(currentFont)

    // Proporcionar el ConfigurationManager a todo el √°rbol de composici√≥n
    CompositionLocalProvider(
        LocalConfigurationManager provides configurationManager
    ) {
        MaterialTheme(
            colorScheme = colorScheme,
            typography = typography,
            shapes = Shapes,
            content = content
        )
    }
}

/**
 * Funci√≥n para obtener la tipograf√≠a seg√∫n la fuente seleccionada
 */
@Composable
private fun getTypographyForFont(fontName: String) = when (fontName) {
    "Montserrat" -> MontserratTypography
    "Poppins" -> PoppinsTypography
    "Roboto" -> RobotoTypography
    else -> MontserratTypography // Por defecto
}
package es.nuskysoftware.marketsales.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.Font
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp
import es.nuskysoftware.marketsales.R


/**
 * Type.kt - Market Sales
 * ‚úÖ M√∫ltiples familias tipogr√°ficas din√°micas
 */

// ------------------- Definimos las familias tipogr√°ficas -------------------
val Montserrat = FontFamily(
    Font(R.font.montserrat_regular, FontWeight.Normal),
    Font(R.font.montserrat_medium, FontWeight.Medium),
    Font(R.font.montserrat_bold, FontWeight.Bold)
)

val Poppins = FontFamily(
    Font(R.font.poppins_regular, FontWeight.Normal),
    Font(R.font.poppins_medium, FontWeight.Medium),
    Font(R.font.poppins_bold, FontWeight.Bold)
)

val Roboto = FontFamily.Default // Roboto viene por defecto en Android

// ------------------- Funci√≥n para crear Typography con fuente espec√≠fica -------------------
private fun createTypography(fontFamily: FontFamily): Typography {
    return Typography(
        // T√≠tulo grande (pantallas principales)
        titleLarge = TextStyle(
            fontFamily = fontFamily,
            fontWeight = FontWeight.Bold,
            fontSize = 22.sp
        ),
        // T√≠tulo medio
        titleMedium = TextStyle(
            fontFamily = fontFamily,
            fontWeight = FontWeight.Medium,
            fontSize = 18.sp
        ),
        // Texto normal
        bodyLarge = TextStyle(
            fontFamily = fontFamily,
            fontWeight = FontWeight.Normal,
            fontSize = 16.sp
        ),
        // Texto peque√±o
        bodyMedium = TextStyle(
            fontFamily = fontFamily,
            fontWeight = FontWeight.Normal,
            fontSize = 14.sp
        )
    )
}

// ------------------- Tipograf√≠as precreadas -------------------
val MontserratTypography = createTypography(Montserrat)
val PoppinsTypography = createTypography(Poppins)
val RobotoTypography = createTypography(Roboto)

// app/src/main/java/es/nuskysoftware/marketsales/ui/viewmodel/ArticuloViewModel.kt
package es.nuskysoftware.marketsales.ui.viewmodel

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import es.nuskysoftware.marketsales.data.local.entity.ArticuloEntity
import es.nuskysoftware.marketsales.data.repository.ArticuloRepository
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch

/**
 * ArticuloViewModel V11 - Market Sales
 *
 * ARQUITECTURA REACTIVA:
 * - StateFlow para estados reactivos
 * - Observa cambios en tiempo real
 * - Compatible con sistema h√≠brido "Reloj Suizo"
 * - Estados de UI para loading, errores, etc.
 * - Validaciones Premium para campos de coste y stock
 */
class ArticuloViewModel(
    private val repository: ArticuloRepository
) : ViewModel() {

    companion object {
        private const val TAG = "ArticuloViewModel"
    }

    // ========== ESTADOS REACTIVOS ==========

    private val _uiState = MutableStateFlow(ArticuloUiState())
    val uiState: StateFlow<ArticuloUiState> = _uiState.asStateFlow()

    // Art√≠culos del usuario actual en tiempo real
    val articulos = repository.getArticulosUsuarioActual()
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    init {
        Log.d(TAG, "‚úÖ ArticuloViewModel inicializado")
    }

    // ========== OPERACIONES CRUD ==========

    /**
     * Crea un nuevo art√≠culo
     */
    fun crearArticulo(
        nombre: String,
        idCategoria: String,
        precioVenta: Double,
        precioCoste: Double? = null,
        stock: Int? = null,
        controlarStock: Boolean = false,
        controlarCoste: Boolean = false,
        favorito: Boolean = false,
        fotoUri: String? = null
    ) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(loading = true, error = null)

            try {
                // Validar datos b√°sicos
                val validacionNombre = validarNombreArticulo(nombre)
                if (validacionNombre != null) {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        error = validacionNombre
                    )
                    return@launch
                }

                val validacionPrecio = validarPrecioVenta(precioVenta)
                if (validacionPrecio != null) {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        error = validacionPrecio
                    )
                    return@launch
                }

                // Validar nombre duplicado
                if (repository.existeArticuloConNombre(nombre)) {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        error = "Ya existe un art√≠culo con ese nombre"
                    )
                    return@launch
                }

                // Validar campos Premium si est√°n activos
                if (controlarCoste && precioCoste != null) {
                    val validacionCoste = validarPrecioCoste(precioCoste)
                    if (validacionCoste != null) {
                        _uiState.value = _uiState.value.copy(
                            loading = false,
                            error = validacionCoste
                        )
                        return@launch
                    }
                }

                if (controlarStock && stock != null) {
                    val validacionStock = validarStock(stock)
                    if (validacionStock != null) {
                        _uiState.value = _uiState.value.copy(
                            loading = false,
                            error = validacionStock
                        )
                        return@launch
                    }
                }

                val articuloId = repository.crearArticulo(
                    nombre = nombre,
                    idCategoria = idCategoria,
                    precioVenta = precioVenta,
                    precioCoste = precioCoste,
                    stock = stock,
                    controlarStock = controlarStock,
                    controlarCoste = controlarCoste,
                    favorito = favorito,
                    fotoUri = fotoUri
                )

                _uiState.value = _uiState.value.copy(
                    loading = false,
                    message = "Art√≠culo creado exitosamente",
                    error = null
                )

                Log.d(TAG, "‚úÖ Art√≠culo creado: $nombre (ID: $articuloId)")

            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    loading = false,
                    error = "Error creando art√≠culo: ${e.message}"
                )
                Log.e(TAG, "‚ùå Error creando art√≠culo", e)
            }
        }
    }

    /**
     * Actualiza un art√≠culo existente
     */
    fun actualizarArticulo(articulo: ArticuloEntity) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(loading = true, error = null)

            try {
                // Validar datos b√°sicos
                val validacionNombre = validarNombreArticulo(articulo.nombre)
                if (validacionNombre != null) {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        error = validacionNombre
                    )
                    return@launch
                }

                val validacionPrecio = validarPrecioVenta(articulo.precioVenta)
                if (validacionPrecio != null) {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        error = validacionPrecio
                    )
                    return@launch
                }

                // Validar nombre duplicado (excluyendo el art√≠culo actual)
                if (repository.existeArticuloConNombre(articulo.nombre, articulo.idArticulo)) {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        error = "Ya existe un art√≠culo con ese nombre"
                    )
                    return@launch
                }

                // Validar campos Premium si est√°n activos
                if (articulo.controlarCoste && articulo.precioCoste != null) {
                    val validacionCoste = validarPrecioCoste(articulo.precioCoste)
                    if (validacionCoste != null) {
                        _uiState.value = _uiState.value.copy(
                            loading = false,
                            error = validacionCoste
                        )
                        return@launch
                    }
                }

                if (articulo.controlarStock && articulo.stock != null) {
                    val validacionStock = validarStock(articulo.stock)
                    if (validacionStock != null) {
                        _uiState.value = _uiState.value.copy(
                            loading = false,
                            error = validacionStock
                        )
                        return@launch
                    }
                }

                val exito = repository.actualizarArticulo(articulo)

                if (exito) {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        message = "Art√≠culo actualizado exitosamente",
                        error = null
                    )
                    Log.d(TAG, "‚úÖ Art√≠culo actualizado: ${articulo.nombre}")
                } else {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        error = "Error actualizando art√≠culo"
                    )
                }

            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    loading = false,
                    error = "Error actualizando art√≠culo: ${e.message}"
                )
                Log.e(TAG, "‚ùå Error actualizando art√≠culo", e)
            }
        }
    }

    /**
     * Elimina un art√≠culo
     */
    fun eliminarArticulo(articulo: ArticuloEntity) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(loading = true, error = null)

            try {
                val exito = repository.eliminarArticulo(articulo)

                if (exito) {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        message = "Art√≠culo eliminado exitosamente",
                        error = null
                    )
                    Log.d(TAG, "‚úÖ Art√≠culo eliminado: ${articulo.nombre}")
                } else {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        error = "Error eliminando art√≠culo"
                    )
                }

            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    loading = false,
                    error = "Error eliminando art√≠culo: ${e.message}"
                )
                Log.e(TAG, "‚ùå Error eliminando art√≠culo", e)
            }
        }
    }

    /**
     * Obtiene un art√≠culo por ID
     */
    suspend fun getArticuloById(id: String): ArticuloEntity? {
        return try {
            repository.getArticuloById(id)
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error obteniendo art√≠culo por ID: $id", e)
            null
        }
    }

    /**
     * Obtiene art√≠culos filtrados por categor√≠a
     */
    fun getArticulosByCategoria(categoriaId: String): Flow<List<ArticuloEntity>> {
        return repository.getArticulosByCategoria(categoriaId)
    }

    /**
     * Busca art√≠culos por nombre
     */
    fun searchArticulos(query: String): Flow<List<ArticuloEntity>> {
        return repository.searchArticulos(query)
    }

    // ========== SINCRONIZACI√ìN ==========

    /**
     * Fuerza sincronizaci√≥n manual
     */
    fun forzarSincronizacion() {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(loading = true, error = null)

            try {
                val exito = repository.forzarSincronizacion()

                _uiState.value = _uiState.value.copy(
                    loading = false,
                    message = if (exito) "Sincronizaci√≥n completada" else "Error en sincronizaci√≥n",
                    error = if (!exito) "No se pudo completar la sincronizaci√≥n" else null
                )

                Log.d(TAG, if (exito) "‚úÖ Sincronizaci√≥n forzada exitosa" else "‚ö†Ô∏è Error en sincronizaci√≥n forzada")

            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    loading = false,
                    error = "Error en sincronizaci√≥n: ${e.message}"
                )
                Log.e(TAG, "‚ùå Error en sincronizaci√≥n forzada", e)
            }
        }
    }

    // ========== GESTI√ìN DE UI ==========

    /**
     * Limpia mensajes de error o √©xito
     */
    fun limpiarMensajes() {
        _uiState.value = _uiState.value.copy(
            error = null,
            message = null
        )
    }

    /**
     * Limpia solo el mensaje de error
     */
    fun limpiarError() {
        _uiState.value = _uiState.value.copy(error = null)
    }

    /**
     * Limpia solo el mensaje de √©xito
     */
    fun limpiarMensaje() {
        _uiState.value = _uiState.value.copy(message = null)
    }

    // ========== VALIDACIONES ==========

    /**
     * Valida si un nombre de art√≠culo es v√°lido
     */
    fun validarNombreArticulo(nombre: String): String? {
        return when {
            nombre.isBlank() -> "El nombre no puede estar vac√≠o"
            nombre.length < 2 -> "El nombre debe tener al menos 2 caracteres"
            nombre.length > 100 -> "El nombre no puede tener m√°s de 100 caracteres"
            else -> null
        }
    }

    /**
     * Valida si un precio de venta es v√°lido
     */
    fun validarPrecioVenta(precio: Double): String? {
        return when {
            precio < 0 -> "El precio no puede ser negativo"
            precio > 999999.99 -> "El precio es demasiado alto"
            else -> null
        }
    }

    /**
     * Valida si un precio de coste es v√°lido
     */
    fun validarPrecioCoste(precio: Double): String? {
        return when {
            precio < 0 -> "El precio de coste no puede ser negativo"
            precio > 999999.99 -> "El precio de coste es demasiado alto"
            else -> null
        }
    }

    /**
     * Valida si un stock es v√°lido
     */
    fun validarStock(stock: Int): String? {
        return when {
            stock < 0 -> "El stock no puede ser negativo"
            stock > 999999 -> "El stock es demasiado alto"
            else -> null
        }
    }

    // ========== UTILIDADES ==========

    /**
     * Obtiene el n√∫mero total de art√≠culos del usuario
     */
    val totalArticulos: StateFlow<Int> = articulos
        .map { it.size }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), 0)

    /**
     * Indica si hay art√≠culos creados
     */
    val tieneArticulos: StateFlow<Boolean> = articulos
        .map { it.isNotEmpty() }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), false)

    /**
     * Art√≠culos favoritos
     */
    val articulosFavoritos: StateFlow<List<ArticuloEntity>> = articulos
        .map { lista -> lista.filter { it.favorito } }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    /**
     * Art√≠culos con stock bajo (menos de 5 unidades)
     */
    val articulosStockBajo: StateFlow<List<ArticuloEntity>> = articulos
        .map { lista ->
            lista.filter { articulo ->
                articulo.controlarStock && articulo.stock != null && articulo.stock < 5
            }
        }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())
}

/**
 * Estado de la UI del ArticuloViewModel
 */
data class ArticuloUiState(
    val loading: Boolean = false,
    val error: String? = null,
    val message: String? = null
)

// app/src/main/java/es/nuskysoftware/marketsales/ui/viewmodel/ArticuloViewModelFactory.kt
package es.nuskysoftware.marketsales.ui.viewmodel

import android.content.Context
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import es.nuskysoftware.marketsales.data.repository.ArticuloRepository

/**
 * Factory para ArticuloViewModel que inyecta ArticuloRepository con Context
 * ‚úÖ FINAL: Context requerido para ArticuloRepository (AppDatabase + ConnectivityObserver)
 */
class ArticuloViewModelFactory(
    private val context: Context
) : ViewModelProvider.Factory {

    @Suppress("UNCHECKED_CAST")
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(ArticuloViewModel::class.java)) {
            return ArticuloViewModel(ArticuloRepository(context)) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class: ${modelClass.name}")
    }
}

package es.nuskysoftware.marketsales.ui.viewmodel

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.google.firebase.auth.EmailAuthProvider
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.UserProfileChangeRequest
import com.google.firebase.auth.FirebaseUser
import es.nuskysoftware.marketsales.data.repository.AuthRepository
import es.nuskysoftware.marketsales.data.repository.AuthResult
import es.nuskysoftware.marketsales.data.repository.AuthState
import es.nuskysoftware.marketsales.data.repository.SyncState
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.tasks.await

class AuthViewModel(
    private val authRepository: AuthRepository
) : ViewModel() {

    companion object { private const val TAG = "AuthViewModel" }

    private val firebaseAuth = FirebaseAuth.getInstance()

    // Estados expuestos
    val authState: StateFlow<AuthState> = authRepository.authState
    val currentUser: StateFlow<FirebaseUser?> = authRepository.currentUser

    // Restauraci√≥n Premium
    val restoreAllowed: StateFlow<Boolean?> get() = authRepository.restoreAllowed
    val restoreBlockMessage: StateFlow<String?> get() = authRepository.restoreBlockMessage

    // ‚úÖ Estado de sincronizaci√≥n para la pantallita
    val syncState: StateFlow<SyncState> get() = authRepository.syncState

    init {
        Log.d(TAG, "AuthViewModel inicializado")
        testAuthConnection()
    }

    private fun testAuthConnection() {
        viewModelScope.launch {
            try {
                val connectionTest = authRepository.testConnection()
                val isAuthenticated = authRepository.isUserAuthenticated()
                val user = currentUser.value
                Log.d(TAG, "‚úÖ DEBUG AuthViewModel - Test resultados:")
                Log.d(TAG, "   - Conexi√≥n Firebase: $connectionTest")
                Log.d(TAG, "   - Usuario autenticado: $isAuthenticated")
                Log.d(TAG, "   - Usuario actual: ${user?.email ?: "null"}")
            } catch (e: Exception) {
                Log.e(TAG, "Error en test de conexi√≥n", e)
            }
        }
    }

    // ---------- AUTENTICACI√ìN ----------
    fun registerWithEmail(email: String, password: String) {
        viewModelScope.launch {
            Log.d(TAG, "ViewModel: Iniciando registro para $email")
            try {
                when (val result = authRepository.registerWithEmail(email, password)) {
                    is AuthResult.Success -> Log.d(TAG, "ViewModel: Registro ok - ${result.user?.email}")
                    is AuthResult.Error   -> Log.e(TAG, "ViewModel: Error en registro - ${result.message}")
                }
            } catch (e: Exception) {
                Log.e(TAG, "ViewModel: Excepci√≥n no controlada en registro", e)
            }
        }
    }

    fun loginWithEmail(email: String, password: String) {
        viewModelScope.launch {
            Log.d(TAG, "ViewModel: Iniciando login para $email")
            try {
                when (val result = authRepository.loginWithEmail(email, password)) {
                    is AuthResult.Success -> Log.d(TAG, "ViewModel: Login ok - ${result.user?.email}")
                    is AuthResult.Error   -> Log.e(TAG, "ViewModel: Error en login - ${result.message}")
                }
            } catch (e: Exception) {
                Log.e(TAG, "ViewModel: Excepci√≥n no controlada en login", e)
            }
        }
    }

    fun signInWithGoogle(idToken: String) {
        viewModelScope.launch {
            Log.d(TAG, "ViewModel: Iniciando Google Auth")
            try {
                when (val result = authRepository.signInWithGoogle(idToken)) {
                    is AuthResult.Success -> {
                        Log.d(TAG, "ViewModel: Google ok - ${result.user?.email}")
                        Log.d(TAG, "ViewModel: Nombre - ${result.user?.displayName}")
                    }
                    is AuthResult.Error   -> Log.e(TAG, "ViewModel: Error Google - ${result.message}")
                }
            } catch (e: Exception) {
                Log.e(TAG, "ViewModel: Excepci√≥n no controlada en Google Auth", e)
            }
        }
    }

    fun logout() {
        viewModelScope.launch {
            Log.d(TAG, "ViewModel: Iniciando logout")
            try {
                when (val result = authRepository.logout()) {
                    is AuthResult.Success -> Log.d(TAG, "ViewModel: Logout ok")
                    is AuthResult.Error   -> Log.e(TAG, "ViewModel: Error logout - ${result.message}")
                }
            } catch (e: Exception) {
                Log.e(TAG, "ViewModel: Excepci√≥n no controlada en logout", e)
            }
        }
    }

    fun isUserAuthenticated(): Boolean = authRepository.isUserAuthenticated()

    fun clearAuthError() { Log.d(TAG, "ViewModel: Limpiando errores de autenticaci√≥n") }

    // ---------- PERFIL ----------
    suspend fun updateUserProfile(displayName: String, email: String): Boolean {
        return try {
            val user = firebaseAuth.currentUser ?: return false

            val profileUpdates = UserProfileChangeRequest.Builder()
                .setDisplayName(displayName)
                .build()

            user.updateProfile(profileUpdates).await()
            user.reload().await()

            if (user.email != email) { user.updateEmail(email).await() }

            authRepository.updateUserProfileAndMarkDirty(user.uid, displayName, email)

            ConfigurationManager.updateUserConfiguration(
                displayName = displayName,
                usuarioEmail = email,
                isAuthenticated = true
            )
            true
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error actualizando perfil", e)
            false
        }
    }

    suspend fun updatePassword(currentPassword: String, newPassword: String): Boolean {
        return try {
            val user = firebaseAuth.currentUser ?: return false
            val email = user.email ?: return false
            val credential = EmailAuthProvider.getCredential(email, currentPassword)
            user.reauthenticate(credential).await()
            user.updatePassword(newPassword).await()
            Log.d(TAG, "‚úÖ Contrase√±a actualizada correctamente")
            true
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error cambiando contrase√±a", e)
            false
        }
    }

    // ---------- PREMIUM / RESTAURACI√ìN ----------
    fun upgradeToPremiumAndRestore() {
        viewModelScope.launch {
            try {
                val ok = authRepository.updateUserPremium(true)
                if (ok) {
                    authRepository.refreshUserConfiguration()
                }
            } catch (e: Exception) {
                Log.e(TAG, "‚ùå Error al actualizar a Premium y restaurar", e)
            }
        }
    }
}


//
//package es.nuskysoftware.marketsales.ui.viewmodel
//
//import android.util.Log
//import androidx.lifecycle.ViewModel
//import androidx.lifecycle.viewModelScope
//import com.google.firebase.auth.EmailAuthProvider
//import com.google.firebase.auth.FirebaseAuth
//import com.google.firebase.auth.UserProfileChangeRequest
//import com.google.firebase.auth.FirebaseUser
//import es.nuskysoftware.marketsales.data.repository.AuthRepository
//import es.nuskysoftware.marketsales.data.repository.AuthResult
//import es.nuskysoftware.marketsales.data.repository.AuthState
//import es.nuskysoftware.marketsales.utils.ConfigurationManager
//import kotlinx.coroutines.flow.StateFlow
//import kotlinx.coroutines.launch
//import kotlinx.coroutines.tasks.await
//
//class AuthViewModel(
//    private val authRepository: AuthRepository
//) : ViewModel() {
//
//    companion object { private const val TAG = "AuthViewModel" }
//
//    private val firebaseAuth = FirebaseAuth.getInstance()
//
//    // Estados expuestos
//    val authState: StateFlow<AuthState> = authRepository.authState
//    val currentUser: StateFlow<FirebaseUser?> = authRepository.currentUser
//
//    // ‚úÖ EXPOSE: flags de restauraci√≥n/pago Premium para la UI
//    val restoreAllowed: StateFlow<Boolean?> get() = authRepository.restoreAllowed
//    val restoreBlockMessage: StateFlow<String?> get() = authRepository.restoreBlockMessage
//
//    init {
//        Log.d(TAG, "AuthViewModel inicializado")
//        testAuthConnection()
//    }
//
//    private fun testAuthConnection() {
//        viewModelScope.launch {
//            try {
//                val connectionTest = authRepository.testConnection()
//                val isAuthenticated = authRepository.isUserAuthenticated()
//                val user = currentUser.value
//                Log.d(TAG, "‚úÖ DEBUG AuthViewModel - Test resultados:")
//                Log.d(TAG, "   - Conexi√≥n Firebase: $connectionTest")
//                Log.d(TAG, "   - Usuario autenticado: $isAuthenticated")
//                Log.d(TAG, "   - Usuario actual: ${user?.email ?: "null"}")
//            } catch (e: Exception) {
//                Log.e(TAG, "Error en test de conexi√≥n", e)
//            }
//        }
//    }
//
//    // ---------- AUTENTICACI√ìN ----------
//    fun registerWithEmail(email: String, password: String) {
//        viewModelScope.launch {
//            Log.d(TAG, "ViewModel: Iniciando registro para $email")
//            try {
//                when (val result = authRepository.registerWithEmail(email, password)) {
//                    is AuthResult.Success -> Log.d(TAG, "ViewModel: Registro ok - ${result.user?.email}")
//                    is AuthResult.Error   -> Log.e(TAG, "ViewModel: Error en registro - ${result.message}")
//                }
//            } catch (e: Exception) {
//                Log.e(TAG, "ViewModel: Excepci√≥n no controlada en registro", e)
//            }
//        }
//    }
//
//    fun loginWithEmail(email: String, password: String) {
//        viewModelScope.launch {
//            Log.d(TAG, "ViewModel: Iniciando login para $email")
//            try {
//                when (val result = authRepository.loginWithEmail(email, password)) {
//                    is AuthResult.Success -> Log.d(TAG, "ViewModel: Login ok - ${result.user?.email}")
//                    is AuthResult.Error   -> Log.e(TAG, "ViewModel: Error en login - ${result.message}")
//                }
//            } catch (e: Exception) {
//                Log.e(TAG, "ViewModel: Excepci√≥n no controlada en login", e)
//            }
//        }
//    }
//
//    fun signInWithGoogle(idToken: String) {
//        viewModelScope.launch {
//            Log.d(TAG, "ViewModel: Iniciando Google Auth")
//            try {
//                when (val result = authRepository.signInWithGoogle(idToken)) {
//                    is AuthResult.Success -> {
//                        Log.d(TAG, "ViewModel: Google ok - ${result.user?.email}")
//                        Log.d(TAG, "ViewModel: Nombre - ${result.user?.displayName}")
//                    }
//                    is AuthResult.Error   -> Log.e(TAG, "ViewModel: Error Google - ${result.message}")
//                }
//            } catch (e: Exception) {
//                Log.e(TAG, "ViewModel: Excepci√≥n no controlada en Google Auth", e)
//            }
//        }
//    }
//
//    fun logout() {
//        viewModelScope.launch {
//            Log.d(TAG, "ViewModel: Iniciando logout")
//            try {
//                when (val result = authRepository.logout()) {
//                    is AuthResult.Success -> Log.d(TAG, "ViewModel: Logout ok")
//                    is AuthResult.Error   -> Log.e(TAG, "ViewModel: Error logout - ${result.message}")
//                }
//            } catch (e: Exception) {
//                Log.e(TAG, "ViewModel: Excepci√≥n no controlada en logout", e)
//            }
//        }
//    }
//
//    fun isUserAuthenticated(): Boolean = authRepository.isUserAuthenticated()
//
//    fun clearAuthError() { Log.d(TAG, "ViewModel: Limpiando errores de autenticaci√≥n") }
//
//    // ---------- PERFIL ----------
//    suspend fun updateUserProfile(displayName: String, email: String): Boolean {
//        return try {
//            val user = firebaseAuth.currentUser ?: return false
//
//            val profileUpdates = UserProfileChangeRequest.Builder()
//                .setDisplayName(displayName)
//                .build()
//
//            user.updateProfile(profileUpdates).await()
//            user.reload().await()
//
//            if (user.email != email) { user.updateEmail(email).await() }
//
//            authRepository.updateUserProfileAndMarkDirty(user.uid, displayName, email)
//
//            ConfigurationManager.updateUserConfiguration(
//                displayName = displayName,
//                usuarioEmail = email,
//                isAuthenticated = true
//            )
//            true
//        } catch (e: Exception) {
//            Log.e(TAG, "‚ùå Error actualizando perfil", e)
//            false
//        }
//    }
//
//    suspend fun updatePassword(currentPassword: String, newPassword: String): Boolean {
//        return try {
//            val user = firebaseAuth.currentUser ?: return false
//            val email = user.email ?: return false
//            val credential = EmailAuthProvider.getCredential(email, currentPassword)
//            user.reauthenticate(credential).await()
//            user.updatePassword(newPassword).await()
//            Log.d(TAG, "‚úÖ Contrase√±a actualizada correctamente")
//            true
//        } catch (e: Exception) {
//            Log.e(TAG, "‚ùå Error cambiando contrase√±a", e)
//            false
//        }
//    }
//
//    // ---------- PREMIUM / RESTAURACI√ìN ----------
//    fun upgradeToPremiumAndRestore() {
//        viewModelScope.launch {
//            try {
//                val ok = authRepository.updateUserPremium(true)
//                if (ok) {
//                    // Re-ejecuta la carga h√≠brida ‚Üí har√° bootstrap/sync si procede
//                    authRepository.refreshUserConfiguration()
//                }
//            } catch (e: Exception) {
//                Log.e(TAG, "‚ùå Error al actualizar a Premium y restaurar", e)
//            }
//        }
//    }
//}
//


// app/src/main/java/es/nuskysoftware/marketsales/ui/viewmodel/AuthViewModelFactory.kt
package es.nuskysoftware.marketsales.ui.viewmodel

import android.content.Context
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import es.nuskysoftware.marketsales.data.repository.AuthRepository

/**
 * Factory para AuthViewModel que inyecta AuthRepository con Context
 * ‚úÖ FINAL: Context requerido para AuthRepository
 */
class AuthViewModelFactory(
    private val context: Context
) : ViewModelProvider.Factory {

    @Suppress("UNCHECKED_CAST")
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(AuthViewModel::class.java)) {
            return AuthViewModel(AuthRepository(context)) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class: ${modelClass.name}")
    }
}


// app/src/main/java/es/nuskysoftware/marketsales/data/viewmodel/CategoriaViewModel.kt
package es.nuskysoftware.marketsales.ui.viewmodel

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import es.nuskysoftware.marketsales.data.local.entity.CategoriaEntity
import es.nuskysoftware.marketsales.data.repository.CategoriaRepository
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch

/**
 * CategoriaViewModel V11 - Market Sales
 *
 * ARQUITECTURA REACTIVA:
 * - StateFlow para estados reactivos
 * - Observa cambios en tiempo real
 * - Compatible con sistema h√≠brido "Reloj Suizo"
 * - Estados de UI para loading, errores, etc.
 */
class CategoriaViewModel(
    private val repository: CategoriaRepository
) : ViewModel() {

    companion object {
        private const val TAG = "CategoriaViewModel"
    }

    // ========== ESTADOS REACTIVOS ==========

    private val _uiState = MutableStateFlow(CategoriaUiState())
    val uiState: StateFlow<CategoriaUiState> = _uiState.asStateFlow()

    // Categor√≠as del usuario actual en tiempo real
    val categorias = repository.getCategoriasUsuarioActual()
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    init {
        Log.d(TAG, "‚úÖ CategoriaViewModel inicializado")
    }

    // ========== OPERACIONES CRUD ==========

    /**
     * Crea una nueva categor√≠a
     */
    fun crearCategoria(
        nombre: String,
        colorHex: String,
        orden: Int = 0
    ) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(loading = true, error = null)

            try {
                // Validar nombre duplicado
                if (repository.existeCategoriaConNombre(nombre)) {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        error = "Ya existe una categor√≠a con ese nombre"
                    )
                    return@launch
                }

                val categoriaId = repository.crearCategoria(nombre, colorHex, orden)

                _uiState.value = _uiState.value.copy(
                    loading = false,
                    message = "Categor√≠a creada exitosamente",
                    error = null
                )

                Log.d(TAG, "‚úÖ Categor√≠a creada: $nombre (ID: $categoriaId)")

            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    loading = false,
                    error = "Error creando categor√≠a: ${e.message}"
                )
                Log.e(TAG, "‚ùå Error creando categor√≠a", e)
            }
        }
    }

    /**
     * Actualiza una categor√≠a existente
     */
    fun actualizarCategoria(categoria: CategoriaEntity) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(loading = true, error = null)

            try {
                // Validar nombre duplicado (excluyendo la categor√≠a actual)
                if (repository.existeCategoriaConNombre(categoria.nombre, categoria.idCategoria)) {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        error = "Ya existe una categor√≠a con ese nombre"
                    )
                    return@launch
                }

                val exito = repository.actualizarCategoria(categoria)

                if (exito) {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        message = "Categor√≠a actualizada exitosamente",
                        error = null
                    )
                    Log.d(TAG, "‚úÖ Categor√≠a actualizada: ${categoria.nombre}")
                } else {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        error = "Error actualizando categor√≠a"
                    )
                }

            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    loading = false,
                    error = "Error actualizando categor√≠a: ${e.message}"
                )
                Log.e(TAG, "‚ùå Error actualizando categor√≠a", e)
            }
        }
    }

    /**
     * Elimina una categor√≠a
     */
    fun eliminarCategoria(categoria: CategoriaEntity) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(loading = true, error = null)

            try {
                val exito = repository.eliminarCategoria(categoria)

                if (exito) {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        message = "Categor√≠a eliminada exitosamente",
                        error = null
                    )
                    Log.d(TAG, "‚úÖ Categor√≠a eliminada: ${categoria.nombre}")
                } else {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        error = "Error eliminando categor√≠a"
                    )
                }

            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    loading = false,
                    error = "Error eliminando categor√≠a: ${e.message}"
                )
                Log.e(TAG, "‚ùå Error eliminando categor√≠a", e)
            }
        }
    }

    /**
     * Obtiene una categor√≠a por ID
     */
    suspend fun getCategoriaById(id: String): CategoriaEntity? {
        return try {
            repository.getCategoriaById(id)
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error obteniendo categor√≠a por ID: $id", e)
            null
        }
    }

    // ========== SINCRONIZACI√ìN ==========

    /**
     * Fuerza sincronizaci√≥n manual
     */
    fun forzarSincronizacion() {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(loading = true, error = null)

            try {
                val exito = repository.forzarSincronizacion()

                _uiState.value = _uiState.value.copy(
                    loading = false,
                    message = if (exito) "Sincronizaci√≥n completada" else "Error en sincronizaci√≥n",
                    error = if (!exito) "No se pudo completar la sincronizaci√≥n" else null
                )

                Log.d(TAG, if (exito) "‚úÖ Sincronizaci√≥n forzada exitosa" else "‚ö†Ô∏è Error en sincronizaci√≥n forzada")

            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    loading = false,
                    error = "Error en sincronizaci√≥n: ${e.message}"
                )
                Log.e(TAG, "‚ùå Error en sincronizaci√≥n forzada", e)
            }
        }
    }

    // ========== GESTI√ìN DE UI ==========

    /**
     * Limpia mensajes de error o √©xito
     */
    fun limpiarMensajes() {
        _uiState.value = _uiState.value.copy(
            error = null,
            message = null
        )
    }

    /**
     * Limpia solo el mensaje de error
     */
    fun limpiarError() {
        _uiState.value = _uiState.value.copy(error = null)
    }

    /**
     * Limpia solo el mensaje de √©xito
     */
    fun limpiarMensaje() {
        _uiState.value = _uiState.value.copy(message = null)
    }

    // ========== VALIDACIONES ==========

    /**
     * Valida si un nombre de categor√≠a es v√°lido
     */
    fun validarNombreCategoria(nombre: String): String? {
        return when {
            nombre.isBlank() -> "El nombre no puede estar vac√≠o"
            nombre.length < 2 -> "El nombre debe tener al menos 2 caracteres"
            nombre.length > 50 -> "El nombre no puede tener m√°s de 50 caracteres"
            else -> null
        }
    }

    /**
     * Valida si un color hex es v√°lido
     */
    fun validarColorHex(colorHex: String): String? {
        return if (colorHex.matches(Regex("^#[0-9A-Fa-f]{6}$"))) {
            null
        } else {
            "Color inv√°lido"
        }
    }

    // ========== UTILIDADES ==========

    /**
     * Obtiene el n√∫mero total de categor√≠as del usuario
     */
    val totalCategorias: StateFlow<Int> = categorias
        .map { it.size }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), 0)

    /**
     * Indica si hay categor√≠as creadas
     */
    val tieneCategorias: StateFlow<Boolean> = categorias
        .map { it.isNotEmpty() }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), false)
}

/**
 * Estado de la UI del CategoriaViewModel
 */
data class CategoriaUiState(
    val loading: Boolean = false,
    val error: String? = null,
    val message: String? = null
)


// app/src/main/java/es/nuskysoftware/marketsales/ui/viewmodel/CategoriaViewModelFactory.kt
package es.nuskysoftware.marketsales.ui.viewmodel

import android.content.Context
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import es.nuskysoftware.marketsales.data.repository.CategoriaRepository

/**
 * Factory para CategoriaViewModel que inyecta CategoriaRepository con Context
 * ‚úÖ FINAL: Context requerido para CategoriaRepository (AppDatabase + ConnectivityObserver)
 */
class CategoriaViewModelFactory(
    private val context: Context
) : ViewModelProvider.Factory {

    @Suppress("UNCHECKED_CAST")
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(CategoriaViewModel::class.java)) {
            return CategoriaViewModel(CategoriaRepository(context)) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class: ${modelClass.name}")
    }
}

// app/src/main/java/es/nuskysoftware/marketsales/ui/viewmodel/ConfiguracionViewModel.kt
package es.nuskysoftware.marketsales.ui.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import es.nuskysoftware.marketsales.data.local.entity.ConfiguracionEntity
import es.nuskysoftware.marketsales.data.repository.ConfiguracionRepository
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

class ConfiguracionViewModel(
    private val repository: ConfiguracionRepository
) : ViewModel() {

    val configuracion: StateFlow<ConfiguracionEntity?> = repository.configuracion

    init {
        // Crear configuraci√≥n por defecto si no existe
        viewModelScope.launch {
            repository.crearConfiguracionPorDefecto()
        }
    }

    /**
     * Actualiza la contrase√±a del usuario
     */
    fun actualizarPassword(nuevaPassword: String) {
        viewModelScope.launch {
            repository.actualizarPassword(nuevaPassword)
        }
    }

    /**
     * Actualiza el tema (claro/oscuro)
     */
    fun actualizarTema(esTemaOscuro: Boolean) {
        viewModelScope.launch {
            repository.actualizarTema(esTemaOscuro)
        }
    }

    /**
     * Actualiza la fuente de la aplicaci√≥n
     */
    fun actualizarFuente(fuente: String) {
        viewModelScope.launch {
            repository.actualizarFuente(fuente)
        }
    }

    /**
     * Actualiza el idioma de la aplicaci√≥n
     */
    fun actualizarIdioma(idioma: String) {
        viewModelScope.launch {
            repository.actualizarIdioma(idioma)
        }
    }

    /**
     * Actualiza la moneda de la aplicaci√≥n
     */
    fun actualizarMoneda(moneda: String) {
        viewModelScope.launch {
            repository.actualizarMoneda(moneda)
        }
    }

    /**
     * Actualiza la versi√≥n de la app (0=FREE, 1=PREMIUM)
     */
    fun actualizarVersion(version: Int) {
        viewModelScope.launch {
            repository.actualizarVersionApp(version)
        }
    }

    /**
     * Actualiza el email del usuario
     */
    fun actualizarEmail(email: String) {
        viewModelScope.launch {
            repository.actualizarUsuarioEmail(email)
        }
    }

    /**
     * Fuerza la sincronizaci√≥n con Firebase
     */
    fun sincronizar() {
        viewModelScope.launch {
            repository.sincronizar()
        }
    }
}

package es.nuskysoftware.marketsales.ui.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import es.nuskysoftware.marketsales.data.repository.ConfiguracionRepository

class ConfiguracionViewModelFactory(
    private val repository: ConfiguracionRepository
) : ViewModelProvider.Factory {

    @Suppress("UNCHECKED_CAST")
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(ConfiguracionViewModel::class.java)) {
            return ConfiguracionViewModel(repository) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}


// app/src/main/java/es/nuskysoftware/marketsales/ui/viewmodel/MercadilloViewModel.kt
package es.nuskysoftware.marketsales.ui.viewmodel

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import es.nuskysoftware.marketsales.data.local.entity.MercadilloEntity
import es.nuskysoftware.marketsales.data.repository.MercadilloRepository
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.utils.EstadosMercadillo
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.*

/**
 * MercadilloViewModel V14 - Market Sales
 *
 * ARQUITECTURA REACTIVA + REGLAS DE NEGOCIO + BOTTOMBAR + PR√ìXIMOS:
 * - StateFlow para estados reactivos
 * - Observa cambios en tiempo real
 * - Compatible con sistema h√≠brido "Reloj Suizo"
 * - Estados de UI para loading, errores, etc.
 * - Gesti√≥n completa de mercadillos y estados autom√°ticos
 * - L√≥gica espec√≠fica para calendario y pr√≥ximos mercadillos
 * - NUEVAS REGLAS DE NEGOCIO IMPLEMENTADAS
 * - GESTI√ìN DE MERCADILLO ACTIVO PARA BOTTOMBAR
 * - FUNCIONALIDAD DEBUG PARA CAMBIO DE ESTADOS
 * - ‚úÖ NUEVA: LISTADO COMPLETO DE MERCADILLOS PR√ìXIMOS
 */
class MercadilloViewModel(
    private val repository: MercadilloRepository
) : ViewModel() {

    companion object {
        private const val TAG = "MercadilloViewModel"
    }

    // Formateadores de fecha
    private val dateFormat = SimpleDateFormat("dd-MM-yyyy", Locale.getDefault())
    private val timeFormat = SimpleDateFormat("HH:mm", Locale.getDefault())

    // ========== ESTADOS REACTIVOS ==========

    private val _uiState = MutableStateFlow(MercadilloUiState())
    val uiState: StateFlow<MercadilloUiState> = _uiState.asStateFlow()

    // Estado del calendario (mes/a√±o actual visible)
    private val _calendarioState = MutableStateFlow(CalendarioState())
    val calendarioState: StateFlow<CalendarioState> = _calendarioState.asStateFlow()

    // ========== ESTADOS PARA EDICI√ìN ==========
    private val _mercadilloParaEditar = MutableStateFlow<MercadilloEntity?>(null)
    val mercadilloParaEditar: StateFlow<MercadilloEntity?> = _mercadilloParaEditar.asStateFlow()

    // ========== GESTI√ìN DE MERCADILLO ACTIVO (BOTTOMBAR) ==========

    /**
     * Mercadillo seleccionado para operaciones (ventas/gastos/resumen)
     * Se mantiene durante la sesi√≥n
     */
    private val _mercadilloActivoSeleccionado = MutableStateFlow<MercadilloEntity?>(null)
    val mercadilloActivoSeleccionado: StateFlow<MercadilloEntity?> = _mercadilloActivoSeleccionado.asStateFlow()

    // Mercadillos del usuario actual en tiempo real
    val mercadillos = repository.getMercadillosUsuarioActual()
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    /**
     * Obtiene mercadillos en curso (estado EN_CURSO = 3)
     */
    val mercadillosEnCurso: StateFlow<List<MercadilloEntity>> = mercadillos
        .map { listaMercadillos ->
            listaMercadillos.filter { mercadillo ->
                mercadillo.estado == EstadosMercadillo.Estado.EN_CURSO.codigo
            }
        }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    /**
     * Indica si debe mostrarse el BottomBar (hay mercadillos en curso)
     */
    val mostrarBottomBar: StateFlow<Boolean> = mercadillosEnCurso
        .map { it.isNotEmpty() }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), false)

    /**
     * Obtiene el mercadillo activo para operaciones
     * Si hay uno seleccionado previamente y sigue en curso, lo usa
     * Si no, devuelve null para que se muestre el di√°logo de selecci√≥n
     */
    val mercadilloActivoParaOperaciones: StateFlow<MercadilloEntity?> = combine(
        mercadillosEnCurso,
        mercadilloActivoSeleccionado
    ) { enCurso, seleccionado ->
        when {
            enCurso.isEmpty() -> {
                // No hay mercadillos en curso, limpiar selecci√≥n
                _mercadilloActivoSeleccionado.value = null
                null
            }
            enCurso.size == 1 -> {
                // Solo hay uno en curso, seleccionarlo autom√°ticamente
                val unico = enCurso.first()
                if (seleccionado?.idMercadillo != unico.idMercadillo) {
                    _mercadilloActivoSeleccionado.value = unico
                }
                unico
            }
            seleccionado != null && enCurso.any { it.idMercadillo == seleccionado.idMercadillo } -> {
                // El seleccionado sigue en curso, mantenerlo
                seleccionado
            }
            else -> {
                // Hay m√∫ltiples y no hay selecci√≥n v√°lida
                null
            }
        }
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), null)

    // ========== ‚úÖ NUEVA FUNCIONALIDAD: MERCADILLOS PR√ìXIMOS ==========

    /**
     * ‚úÖ NUEVA: Obtiene TODOS los mercadillos desde hoy en adelante
     */
    val mercadillosProximos: StateFlow<List<MercadilloEntity>> =
        ConfigurationManager.usuarioLogueado.flatMapLatest { userId ->
            val effectiveUserId = userId ?: "usuario_default"
            Log.d(TAG, "üîÑ Usuario cambi√≥ a: $effectiveUserId - Recargando mercadillos pr√≥ximos")

            flow {
                while (true) {
                    val proximosMercadillos = repository.getMercadillosDesdeHoy(effectiveUserId)
                    emit(proximosMercadillos)
                    kotlinx.coroutines.delay(60_000) // Actualizar cada minuto
                }
            }
        }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    /**
     * ‚úÖ MANTENER COMPATIBILIDAD: El pr√≥ximo mercadillo (primer elemento de la lista)
     */
    val proximoMercadillo: StateFlow<MercadilloEntity?> = mercadillosProximos
        .map { lista -> lista.firstOrNull() }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), null)

    /**
     * ‚úÖ NUEVA: Indica si hay mercadillos pr√≥ximos
     */
    val tieneMercadillosProximos: StateFlow<Boolean> = mercadillosProximos
        .map { it.isNotEmpty() }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), false)

    /**
     * ‚úÖ NUEVA: Cuenta el n√∫mero de mercadillos pr√≥ximos
     */
    val totalMercadillosProximos: StateFlow<Int> = mercadillosProximos
        .map { it.size }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), 0)

    init {
        Log.d(TAG, "‚úÖ MercadilloViewModel inicializado con funcionalidad mercadillosProximos")

        // Inicializar calendario con mes actual
        val hoy = Calendar.getInstance()
        _calendarioState.value = CalendarioState(
            ano = hoy.get(Calendar.YEAR),
            mes = hoy.get(Calendar.MONTH) + 1 // Calendar.MONTH es 0-based
        )
    }

    // ========== OPERACIONES CRUD ==========

    /**
     * Crea un nuevo mercadillo - CON REGLAS DE NEGOCIO
     */
    fun crearMercadillo(
        fecha: String,
        lugar: String,
        organizador: String,
        esGratis: Boolean = true,
        importeSuscripcion: Double = 0.0,
        requiereMesa: Boolean = true,
        requiereCarpa: Boolean = true,
        hayPuntoLuz: Boolean = false,
        horaInicio: String = "09:00",
        horaFin: String = "14:00",
        saldoInicial: Double? = null
    ) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(loading = true, error = null)

            try {
                // ‚úÖ NUEVA VALIDACI√ìN DE FECHA PARA ALTA
                val validacionFechaAlta = validarFechaParaAlta(fecha)
                if (validacionFechaAlta != null) {
                    _uiState.value = _uiState.value.copy(loading = false, error = validacionFechaAlta)
                    return@launch
                }

                // ‚úÖ NUEVA VALIDACI√ìN DE M√öLTIPLES MERCADILLOS
                val validacionMultiples = validarMultiplesMercadillosPorDia(fecha)
                if (validacionMultiples != null) {
                    _uiState.value = _uiState.value.copy(loading = false, error = validacionMultiples)
                    return@launch
                }

                // Validaciones b√°sicas existentes
                val validacionLugar = validarLugar(lugar)
                if (validacionLugar != null) {
                    _uiState.value = _uiState.value.copy(loading = false, error = validacionLugar)
                    return@launch
                }

                val validacionOrganizador = validarOrganizador(organizador)
                if (validacionOrganizador != null) {
                    _uiState.value = _uiState.value.copy(loading = false, error = validacionOrganizador)
                    return@launch
                }

                val validacionHorarios = validarHorarios(horaInicio, horaFin)
                if (validacionHorarios != null) {
                    _uiState.value = _uiState.value.copy(loading = false, error = validacionHorarios)
                    return@launch
                }

                // Validar suscripci√≥n si no es gratis
                if (!esGratis) {
                    val validacionSuscripcion = validarImporteSuscripcion(importeSuscripcion)
                    if (validacionSuscripcion != null) {
                        _uiState.value = _uiState.value.copy(loading = false, error = validacionSuscripcion)
                        return@launch
                    }
                }

                // Validar saldo inicial si se proporcion√≥
                if (saldoInicial != null) {
                    val validacionSaldo = validarSaldoInicial(saldoInicial)
                    if (validacionSaldo != null) {
                        _uiState.value = _uiState.value.copy(loading = false, error = validacionSaldo)
                        return@launch
                    }
                }

                val mercadilloId = repository.crearMercadillo(
                    fecha = fecha,
                    lugar = lugar,
                    organizador = organizador,
                    esGratis = esGratis,
                    importeSuscripcion = importeSuscripcion,
                    requiereMesa = requiereMesa,
                    requiereCarpa = requiereCarpa,
                    hayPuntoLuz = hayPuntoLuz,
                    horaInicio = horaInicio,
                    horaFin = horaFin,
                    saldoInicial = saldoInicial
                )

                // Mensaje personalizado seg√∫n si hay saldo inicial
                val mensaje = if (saldoInicial != null) {
                    "Mercadillo creado con saldo inicial de ‚Ç¨${String.format("%.2f", saldoInicial)}"
                } else {
                    "Mercadillo creado exitosamente"
                }

                _uiState.value = _uiState.value.copy(
                    loading = false,
                    message = mensaje,
                    error = null
                )

                Log.d(TAG, "‚úÖ Mercadillo creado: $lugar - $fecha (ID: $mercadilloId)${if (saldoInicial != null) " - Saldo inicial: ‚Ç¨$saldoInicial" else ""}")

            } catch (e: Exception) {
                val errorMsg = when {
                    e.message?.contains("Ya existe un mercadillo") == true ->
                        "Ya existe un mercadillo en esa fecha y hora"
                    else -> "Error creando mercadillo: ${e.message}"
                }

                _uiState.value = _uiState.value.copy(loading = false, error = errorMsg)
                Log.e(TAG, "‚ùå Error creando mercadillo", e)
            }
        }
    }

    /**
     * Carga un mercadillo para edici√≥n
     */
    fun cargarMercadillo(mercadilloId: String) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(loading = true, error = null)

            try {
                val mercadillo = repository.getMercadilloById(mercadilloId)
                if (mercadillo != null) {
                    // ‚úÖ VALIDAR SI SE PUEDE EDITAR SEG√öN ESTADO
                    val puedeEditar = puedeEditarMercadillo(mercadillo)
                    if (!puedeEditar.first) {
                        _uiState.value = _uiState.value.copy(
                            loading = false,
                            error = puedeEditar.second
                        )
                        return@launch
                    }

                    _mercadilloParaEditar.value = mercadillo
                    Log.d(TAG, "‚úÖ Mercadillo cargado para edici√≥n: ${mercadillo.lugar}")
                } else {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        error = "Mercadillo no encontrado"
                    )
                }
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    loading = false,
                    error = "Error cargando mercadillo: ${e.message}"
                )
                Log.e(TAG, "‚ùå Error cargando mercadillo para edici√≥n", e)
            } finally {
                _uiState.value = _uiState.value.copy(loading = false)
            }
        }
    }

    /**
     * Actualiza un mercadillo existente - CON REGLAS DE NEGOCIO
     */
    fun actualizarMercadillo(
        mercadilloId: String,
        fecha: String,
        lugar: String,
        organizador: String,
        esGratis: Boolean = true,
        importeSuscripcion: Double = 0.0,
        requiereMesa: Boolean = true,
        requiereCarpa: Boolean = true,
        hayPuntoLuz: Boolean = false,
        horaInicio: String = "09:00",
        horaFin: String = "14:00",
        saldoInicial: Double? = null
    ) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(loading = true, error = null)

            try {
                // Obtener mercadillo actual
                val mercadilloActual = repository.getMercadilloById(mercadilloId)
                if (mercadilloActual == null) {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        error = "Mercadillo no encontrado"
                    )
                    return@launch
                }

                // ‚úÖ VALIDAR SI SE PUEDE EDITAR SEG√öN ESTADO
                val puedeEditar = puedeEditarMercadillo(mercadilloActual)
                if (!puedeEditar.first) {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        error = puedeEditar.second
                    )
                    return@launch
                }

                // ‚úÖ VALIDAR CAMPOS ESPEC√çFICOS SEG√öN ESTADO
                val validacionCampos = validarCamposSegunEstado(mercadilloActual, fecha, saldoInicial)
                if (validacionCampos != null) {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        error = validacionCampos
                    )
                    return@launch
                }

                // Validaciones b√°sicas
                val validacionLugar = validarLugar(lugar)
                if (validacionLugar != null) {
                    _uiState.value = _uiState.value.copy(loading = false, error = validacionLugar)
                    return@launch
                }

                val validacionOrganizador = validarOrganizador(organizador)
                if (validacionOrganizador != null) {
                    _uiState.value = _uiState.value.copy(loading = false, error = validacionOrganizador)
                    return@launch
                }

                val validacionHorarios = validarHorarios(horaInicio, horaFin)
                if (validacionHorarios != null) {
                    _uiState.value = _uiState.value.copy(loading = false, error = validacionHorarios)
                    return@launch
                }

                // Validar suscripci√≥n si no es gratis
                if (!esGratis) {
                    val validacionSuscripcion = validarImporteSuscripcion(importeSuscripcion)
                    if (validacionSuscripcion != null) {
                        _uiState.value = _uiState.value.copy(loading = false, error = validacionSuscripcion)
                        return@launch
                    }
                }

                // Validar saldo inicial si se proporcion√≥
                if (saldoInicial != null) {
                    val validacionSaldo = validarSaldoInicial(saldoInicial)
                    if (validacionSaldo != null) {
                        _uiState.value = _uiState.value.copy(loading = false, error = validacionSaldo)
                        return@launch
                    }
                }

                // Crear mercadillo actualizado manteniendo algunos campos originales
                val mercadilloActualizado = mercadilloActual.copy(
                    fecha = fecha,
                    lugar = lugar,
                    organizador = organizador,
                    esGratis = esGratis,
                    importeSuscripcion = importeSuscripcion,
                    requiereMesa = requiereMesa,
                    requiereCarpa = requiereCarpa,
                    hayPuntoLuz = hayPuntoLuz,
                    horaInicio = horaInicio,
                    horaFin = horaFin,
                    saldoInicial = saldoInicial,
                    // ‚úÖ ACTUALIZAR ESTADO SI CAMBI√ì EL SALDO INICIAL
                    estado = calcularNuevoEstadoPorCambios(mercadilloActual, saldoInicial)
                )

                val exito = repository.actualizarMercadillo(mercadilloActualizado)

                if (exito) {
                    val mensaje = "Mercadillo actualizado exitosamente"
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        message = mensaje,
                        error = null
                    )

                    // Limpiar mercadillo para edici√≥n
                    _mercadilloParaEditar.value = null

                    Log.d(TAG, "‚úÖ Mercadillo actualizado: $lugar - $fecha (ID: $mercadilloId)")
                } else {
                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        error = "Error actualizando mercadillo"
                    )
                }

            } catch (e: Exception) {
                val errorMsg = "Error actualizando mercadillo: ${e.message}"
                _uiState.value = _uiState.value.copy(loading = false, error = errorMsg)
                Log.e(TAG, "‚ùå Error actualizando mercadillo", e)
            }
        }
    }

    /**
     * Limpia el mercadillo para edici√≥n
     */
    fun limpiarMercadilloParaEditar() {
        _mercadilloParaEditar.value = null
    }

    // ========== GESTI√ìN DE MERCADILLO ACTIVO (BOTTOMBAR) ==========

    /**
     * Selecciona un mercadillo espec√≠fico para operaciones
     */
    fun seleccionarMercadilloActivo(mercadillo: MercadilloEntity) {
        _mercadilloActivoSeleccionado.value = mercadillo
        Log.d(TAG, "‚úÖ Mercadillo activo seleccionado: ${mercadillo.lugar}")
    }

    /**
     * Limpia la selecci√≥n de mercadillo activo
     */
    fun limpiarMercadilloActivo() {
        _mercadilloActivoSeleccionado.value = null
        Log.d(TAG, "üßπ Mercadillo activo limpiado")
    }

    /**
     * Cambia el mercadillo activo seleccionado
     */
    fun cambiarMercadilloActivo() {
        // Esto activar√° el di√°logo de selecci√≥n en la UI
        _mercadilloActivoSeleccionado.value = null
    }

    // ========== NAVEGACI√ìN A OPERACIONES ==========

    /**
     * Maneja la navegaci√≥n a ventas
     * Devuelve true si puede navegar directamente, false si necesita selecci√≥n
     */
    fun manejarNavegacionVentas(): Pair<Boolean, MercadilloEntity?> {
        val mercadillosDisponibles = mercadillosEnCurso.value
        val activo = mercadilloActivoParaOperaciones.value

        return when {
            mercadillosDisponibles.isEmpty() -> {
                _uiState.value = _uiState.value.copy(error = "No hay mercadillos en curso")
                Pair(false, null)
            }
            activo != null -> {
                // Puede navegar directamente
                Pair(true, activo)
            }
            else -> {
                // Necesita selecci√≥n
                Pair(false, null)
            }
        }
    }

    /**
     * Maneja la navegaci√≥n a gastos
     */
    fun manejarNavegacionGastos(): Pair<Boolean, MercadilloEntity?> {
        return manejarNavegacionVentas() // Misma l√≥gica
    }

    /**
     * Maneja la navegaci√≥n a resumen
     */
    fun manejarNavegacionResumen(): Pair<Boolean, MercadilloEntity?> {
        return manejarNavegacionVentas() // Misma l√≥gica
    }

    // ========== FUNCIONALIDAD DEBUG - CAMBIO DE ESTADOS ==========

    /**
     * Cambia el estado de un mercadillo (SOLO PARA DEBUG)
     */
    fun cambiarEstadoMercadillo(mercadilloId: String, nuevoEstado: EstadosMercadillo.Estado) {
        viewModelScope.launch {
            try {
                val mercadillo = repository.getMercadilloById(mercadilloId)
                if (mercadillo != null) {
                    val mercadilloActualizado = mercadillo.copy(
                        estado = nuevoEstado.codigo,
                        version = mercadillo.version + 1,
                        lastModified = System.currentTimeMillis(),
                        sincronizadoFirebase = false
                    )

                    val exito = repository.actualizarMercadillo(mercadilloActualizado)

                    if (exito) {
                        _uiState.value = _uiState.value.copy(
                            message = "Estado cambiado a: ${nuevoEstado.descripcion}"
                        )
                        Log.d(TAG, "üîß DEBUG: Estado cambiado - ${mercadillo.lugar} -> ${nuevoEstado.descripcion}")
                    } else {
                        _uiState.value = _uiState.value.copy(
                            error = "Error cambiando estado"
                        )
                    }
                }
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    error = "Error cambiando estado: ${e.message}"
                )
                Log.e(TAG, "‚ùå Error cambiando estado DEBUG", e)
            }
        }
    }

    // ========== NUEVAS VALIDACIONES CON REGLAS DE NEGOCIO ==========

    /**
     * Valida si una fecha es v√°lida para crear mercadillos (no anterior a hoy)
     */
    fun validarFechaParaAlta(fecha: String): String? {
        // Validaci√≥n b√°sica de formato
        val validacionBasica = validarFecha(fecha)
        if (validacionBasica != null) return validacionBasica

        try {
            val fechaMercadillo = dateFormat.parse(fecha)
            val fechaActual = Date()

            // ‚úÖ REGLA 1: No permitir fechas anteriores a hoy
            if (fechaMercadillo != null && fechaMercadillo.before(fechaActual)) {
                return "No se puede crear un mercadillo en una fecha anterior a hoy"
            }

            return null
        } catch (e: Exception) {
            return "Fecha inv√°lida"
        }
    }

    /**
     * Valida si el usuario puede crear m√∫ltiples mercadillos en una fecha
     */
    private suspend fun validarMultiplesMercadillosPorDia(fecha: String): String? {
        try {
            val userId = ConfigurationManager.getCurrentUserId() ?: return "Usuario no autenticado"
            val esPremium = ConfigurationManager.getIsPremium()

            // Contar mercadillos existentes en esa fecha
            val mercadillosEnFecha = repository.getMercadillosPorFecha(userId, fecha)

            // ‚úÖ REGLA 2: Solo Premium puede crear m√∫ltiples mercadillos por d√≠a
            if (mercadillosEnFecha.isNotEmpty() && !esPremium) {
                return "Los usuarios FREE solo pueden crear un mercadillo por d√≠a. Actualiza a Premium para crear m√∫ltiples mercadillos."
            }

            return null
        } catch (e: Exception) {
            Log.e(TAG, "Error validando m√∫ltiples mercadillos", e)
            return "Error validando disponibilidad de fecha"
        }
    }

    /**
     * Valida si un mercadillo puede ser editado seg√∫n su estado
     */
    private fun puedeEditarMercadillo(mercadillo: MercadilloEntity): Pair<Boolean, String> {
        val estado = EstadosMercadillo.Estado.fromCodigo(mercadillo.estado)
            ?: return Pair(false, "Estado de mercadillo no v√°lido")

        return when (estado) {
            EstadosMercadillo.Estado.PROGRAMADO_PARCIAL,
            EstadosMercadillo.Estado.PROGRAMADO_TOTAL -> {
                // ‚úÖ REGLA 3: Programado (1,2): todo modificable
                Pair(true, "")
            }
            EstadosMercadillo.Estado.EN_CURSO -> {
                // ‚úÖ REGLA 4: Actual (3): modificable pero con restricciones
                Pair(true, "")
            }
            EstadosMercadillo.Estado.PENDIENTE_ARQUEO,
            EstadosMercadillo.Estado.PENDIENTE_ASIGNAR_SALDO,
            EstadosMercadillo.Estado.CERRADO_COMPLETO,
            EstadosMercadillo.Estado.CANCELADO -> {
                // ‚úÖ REGLA 5: Otros estados (4,5,6,7): no modificable
                Pair(false, "No se puede modificar un mercadillo en estado: ${estado.descripcion}")
            }
        }
    }

    /**
     * Valida campos espec√≠ficos seg√∫n el estado del mercadillo
     */
    private fun validarCamposSegunEstado(
        mercadilloActual: MercadilloEntity,
        nuevaFecha: String,
        nuevoSaldoInicial: Double?
    ): String? {
        val estado = EstadosMercadillo.Estado.fromCodigo(mercadilloActual.estado)
            ?: return "Estado de mercadillo no v√°lido"

        when (estado) {
            EstadosMercadillo.Estado.EN_CURSO -> {
                // ‚úÖ REGLA 4: Actual (3): no fecha ni saldo inicial
                if (nuevaFecha != mercadilloActual.fecha) {
                    return "No se puede modificar la fecha de un mercadillo en curso"
                }
                if (nuevoSaldoInicial != mercadilloActual.saldoInicial) {
                    return "No se puede modificar el saldo inicial de un mercadillo en curso"
                }
            }
            EstadosMercadillo.Estado.PROGRAMADO_PARCIAL,
            EstadosMercadillo.Estado.PROGRAMADO_TOTAL -> {
                // ‚úÖ REGLA 3: Programado: todo modificable (sin restricciones adicionales)
            }
            else -> {
                // Ya validado en puedeEditarMercadillo
            }
        }

        return null
    }

    /**
     * Calcula el nuevo estado basado en los cambios realizados
     */
    private fun calcularNuevoEstadoPorCambios(
        mercadilloActual: MercadilloEntity,
        nuevoSaldoInicial: Double?
    ): Int {
        val estadoActual = EstadosMercadillo.Estado.fromCodigo(mercadilloActual.estado)
            ?: return mercadilloActual.estado

        // ‚úÖ REGLA 9: Todos los datos ‚Üí Programado Total
        when (estadoActual) {
            EstadosMercadillo.Estado.PROGRAMADO_PARCIAL -> {
                // Si se agrega saldo inicial, pasa a PROGRAMADO_TOTAL
                if (nuevoSaldoInicial != null && mercadilloActual.saldoInicial == null) {
                    return EstadosMercadillo.Estado.PROGRAMADO_TOTAL.codigo
                }
            }
            EstadosMercadillo.Estado.PROGRAMADO_TOTAL -> {
                // Si se quita saldo inicial, pasa a PROGRAMADO_PARCIAL
                if (nuevoSaldoInicial == null && mercadilloActual.saldoInicial != null) {
                    return EstadosMercadillo.Estado.PROGRAMADO_PARCIAL.codigo
                }
            }
            else -> {
                // Para otros estados, mantener el estado actual
            }
        }

        return mercadilloActual.estado
    }

    // ========== GESTI√ìN DEL CALENDARIO ==========

    /**
     * Navega al mes anterior en el calendario
     */
    fun navegarMesAnterior() {
        val estadoActual = _calendarioState.value
        val nuevaFecha = Calendar.getInstance().apply {
            set(Calendar.YEAR, estadoActual.ano)
            set(Calendar.MONTH, estadoActual.mes - 1) // Calendar.MONTH es 0-based
            add(Calendar.MONTH, -1)
        }

        _calendarioState.value = estadoActual.copy(
            ano = nuevaFecha.get(Calendar.YEAR),
            mes = nuevaFecha.get(Calendar.MONTH) + 1
        )

        Log.d(TAG, "üìÖ Navegando a: ${nuevaFecha.get(Calendar.MONTH) + 1}/${nuevaFecha.get(Calendar.YEAR)}")
    }

    /**
     * Navega al mes siguiente en el calendario
     */
    fun navegarMesSiguiente() {
        val estadoActual = _calendarioState.value
        val nuevaFecha = Calendar.getInstance().apply {
            set(Calendar.YEAR, estadoActual.ano)
            set(Calendar.MONTH, estadoActual.mes - 1) // Calendar.MONTH es 0-based
            add(Calendar.MONTH, 1)
        }

        _calendarioState.value = estadoActual.copy(
            ano = nuevaFecha.get(Calendar.YEAR),
            mes = nuevaFecha.get(Calendar.MONTH) + 1
        )

        Log.d(TAG, "üìÖ Navegando a: ${nuevaFecha.get(Calendar.MONTH) + 1}/${nuevaFecha.get(Calendar.YEAR)}")
    }

    /**
     * Obtiene mercadillos del mes actual visible en el calendario
     */
    val mercadillosDelMesVisible: StateFlow<List<MercadilloEntity>> =
        calendarioState.flatMapLatest { estado ->
            repository.getMercadillosPorMes(estado.ano, estado.mes)
        }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    /**
     * Agrupa mercadillos por d√≠a para el calendario
     */
    val mercadillosPorDia: StateFlow<Map<Int, List<MercadilloEntity>>> =
        mercadillosDelMesVisible.map { mercadillos ->
            mercadillos.groupBy { mercadillo ->
                try {
                    mercadillo.fecha.split("-")[0].toInt() // D√≠a del formato "dd-MM-yyyy"
                } catch (e: Exception) {
                    0 // Si hay error en el formato, usar d√≠a 0 (no se mostrar√°)
                }
            }.filterKeys { it > 0 } // Filtrar d√≠as inv√°lidos
        }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyMap())

    // ========== CONSULTAS ESPEC√çFICAS ==========

    /**
     * Obtiene mercadillos que requieren atenci√≥n
     */
    val mercadillosRequierenAtencion = repository.getMercadillosRequierenAtencion()
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())

    /**
     * Obtiene estad√≠sticas de mercadillos por estado
     */
    val estadisticasPorEstado: StateFlow<Map<EstadosMercadillo.Estado, Int>> = flow {
        while (true) {
            emit(repository.getEstadisticasPorEstado())
            kotlinx.coroutines.delay(5 * 60_000) // Actualizar cada 5 minutos
        }
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyMap())

    // ========== SINCRONIZACI√ìN ==========

    /**
     * Fuerza sincronizaci√≥n manual
     */
    fun forzarSincronizacion() {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(loading = true, error = null)

            try {
                val exito = repository.forzarSincronizacion()

                _uiState.value = _uiState.value.copy(
                    loading = false,
                    message = if (exito) "Sincronizaci√≥n completada" else "Error en sincronizaci√≥n",
                    error = if (!exito) "No se pudo completar la sincronizaci√≥n" else null
                )

                Log.d(TAG, if (exito) "‚úÖ Sincronizaci√≥n forzada exitosa" else "‚ö†Ô∏è Error en sincronizaci√≥n forzada")

            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    loading = false,
                    error = "Error en sincronizaci√≥n: ${e.message}"
                )
                Log.e(TAG, "‚ùå Error en sincronizaci√≥n forzada", e)
            }
        }
    }

    /**
     * Sincroniza SOLO desde Firebase sin recalcular estados autom√°ticos
     */
    fun sincronizarSoloDesdeFirebase() {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(loading = true, error = null)

            try {
                val userId = ConfigurationManager.getCurrentUserId()
                if (userId != null) {
                    // Solo sincronizar mercadillos pendientes y descargar de Firebase
                    // SIN llamar a actualizarEstadosAutomaticos()
                    repository.sincronizarSinEstadosAutomaticos()

                    _uiState.value = _uiState.value.copy(
                        loading = false,
                        message = "Sincronizaci√≥n completada (sin cambios autom√°ticos)",
                        error = null
                    )
                    Log.d(TAG, "‚úÖ Sincronizaci√≥n desde Firebase sin estados autom√°ticos")
                }
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    loading = false,
                    error = "Error en sincronizaci√≥n: ${e.message}"
                )
                Log.e(TAG, "‚ùå Error en sincronizaci√≥n desde Firebase", e)
            }
        }
    }

    // ========== GESTI√ìN DE UI ==========

    /**
     * Limpia mensajes de error o √©xito
     */
    fun limpiarMensajes() {
        _uiState.value = _uiState.value.copy(
            error = null,
            message = null
        )
    }

    /**
     * Limpia solo el mensaje de error
     */
    fun limpiarError() {
        _uiState.value = _uiState.value.copy(error = null)
    }

    /**
     * Limpia solo el mensaje de √©xito
     */
    fun limpiarMensaje() {
        _uiState.value = _uiState.value.copy(message = null)
    }

    // ========== VALIDACIONES EXISTENTES ==========

    /**
     * Valida si una fecha es v√°lida
     */
    fun validarFecha(fecha: String): String? {
        return when {
            fecha.isBlank() -> "La fecha no puede estar vac√≠a"
            !fecha.matches(Regex("\\d{2}-\\d{2}-\\d{4}")) -> "Formato de fecha inv√°lido (dd-MM-yyyy)"
            else -> {
                try {
                    dateFormat.parse(fecha)
                    null
                } catch (e: Exception) {
                    "Fecha inv√°lida"
                }
            }
        }
    }

    /**
     * Valida si un lugar es v√°lido
     */
    fun validarLugar(lugar: String): String? {
        return when {
            lugar.isBlank() -> "El lugar no puede estar vac√≠o"
            lugar.length < 3 -> "El lugar debe tener al menos 3 caracteres"
            lugar.length > 100 -> "El lugar no puede tener m√°s de 100 caracteres"
            else -> null
        }
    }

    /**
     * Valida si un organizador es v√°lido
     */
    fun validarOrganizador(organizador: String): String? {
        return when {
            organizador.isBlank() -> "El organizador no puede estar vac√≠o"
            organizador.length < 3 -> "El organizador debe tener al menos 3 caracteres"
            organizador.length > 100 -> "El organizador no puede tener m√°s de 100 caracteres"
            else -> null
        }
    }

    /**
     * Valida horarios de inicio y fin
     */
    fun validarHorarios(horaInicio: String, horaFin: String): String? {
        return when {
            !horaInicio.matches(Regex("\\d{2}:\\d{2}")) -> "Formato de hora de inicio inv√°lido (HH:mm)"
            !horaFin.matches(Regex("\\d{2}:\\d{2}")) -> "Formato de hora de fin inv√°lido (HH:mm)"
            else -> {
                try {
                    val inicio = timeFormat.parse(horaInicio)
                    val fin = timeFormat.parse(horaFin)
                    if (inicio != null && fin != null && inicio.after(fin)) {
                        "La hora de inicio debe ser anterior a la hora de fin"
                    } else null
                } catch (e: Exception) {
                    "Horarios inv√°lidos"
                }
            }
        }
    }

    /**
     * Valida importe de suscripci√≥n
     */
    fun validarImporteSuscripcion(importe: Double): String? {
        return when {
            importe < 0 -> "El importe no puede ser negativo"
            importe > 999999.99 -> "El importe es demasiado alto"
            else -> null
        }
    }

    /**
     * Valida saldo inicial
     */
    fun validarSaldoInicial(saldo: Double): String? {
        return when {
            saldo < 0 -> "El saldo inicial no puede ser negativo"
            saldo > 999999.99 -> "El saldo inicial es demasiado alto"
            else -> null
        }
    }

    /**
     * Valida saldo final
     */
    fun validarSaldoFinal(saldo: Double): String? {
        return when {
            saldo < 0 -> "El saldo final no puede ser negativo"
            saldo > 999999.99 -> "El saldo final es demasiado alto"
            else -> null
        }
    }

    // ========== UTILIDADES ==========

    /**
     * Obtiene el n√∫mero total de mercadillos del usuario
     */
    val totalMercadillos: StateFlow<Int> = mercadillos
        .map { it.size }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), 0)

    /**
     * Indica si hay mercadillos creados
     */
    val tieneMercadillos: StateFlow<Boolean> = mercadillos
        .map { it.isNotEmpty() }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), false)

    /**
     * Obtiene el nombre del mes actual en espa√±ol
     */
    val nombreMesActual: StateFlow<String> = calendarioState.map { estado ->
        val meses = arrayOf(
            "Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio",
            "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"
        )
        "${meses[estado.mes - 1]} ${estado.ano}"
    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), "")

    /**
     * Obtiene informaci√≥n de un d√≠a espec√≠fico del calendario
     */
    fun getInformacionDia(dia: Int): List<EstadosMercadillo.Estado> {
        val mercadillosDelDia = mercadillosPorDia.value[dia] ?: emptyList()
        return mercadillosDelDia.map { mercadillo ->
            EstadosMercadillo.Estado.fromCodigo(mercadillo.estado)
                ?: EstadosMercadillo.Estado.PROGRAMADO_PARCIAL
        }.sortedBy { EstadosMercadillo.obtenerPrioridad(it) }
    }

    /**
     * Verifica si un mercadillo puede recibir ventas
     */
    fun puedeRecibirVentas(mercadillo: MercadilloEntity): Boolean {
        val estado = EstadosMercadillo.Estado.fromCodigo(mercadillo.estado)
            ?: EstadosMercadillo.Estado.PROGRAMADO_PARCIAL
        return EstadosMercadillo.puedeRecibirVentas(estado)
    }

    /**
     * Verifica si un mercadillo puede ser cancelado
     */
    fun puedeSerCancelado(mercadillo: MercadilloEntity, tieneVentas: Boolean): Boolean {
        val estado = EstadosMercadillo.Estado.fromCodigo(mercadillo.estado)
            ?: EstadosMercadillo.Estado.PROGRAMADO_PARCIAL
        return EstadosMercadillo.puedeSerCancelado(estado, tieneVentas)
    }

    /**
     * Recarga todos los datos cuando cambia el usuario
     */
    fun recargarDatos() {
        viewModelScope.launch {
            Log.d(TAG, "üîÑ Recargando datos para nuevo usuario")

            // Actualizar estados autom√°ticos del nuevo usuario
            val userId = ConfigurationManager.getCurrentUserId()
            if (userId != null && userId != "usuario_default") {
                repository.actualizarEstadosAutomaticos(userId)
            }
        }
    }
}

/**
 * Estado de la UI del MercadilloViewModel
 */
data class MercadilloUiState(
    val loading: Boolean = false,
    val error: String? = null,
    val message: String? = null
)

/**
 * Estado del calendario
 */
data class CalendarioState(
    val ano: Int = Calendar.getInstance().get(Calendar.YEAR),
    val mes: Int = Calendar.getInstance().get(Calendar.MONTH) + 1 // 1-based para facilidad de uso
)


// app/src/main/java/es/nuskysoftware/marketsales/ui/viewmodel/MercadilloViewModelFactory.kt
package es.nuskysoftware.marketsales.ui.viewmodel

import android.content.Context
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import es.nuskysoftware.marketsales.data.repository.MercadilloRepository

/**
 * Factory para MercadilloViewModel que inyecta MercadilloRepository con Context
 * ‚úÖ FINAL: Context requerido para MercadilloRepository (AppDatabase + ConnectivityObserver)
 */
class MercadilloViewModelFactory(
    private val context: Context
) : ViewModelProvider.Factory {

    @Suppress("UNCHECKED_CAST")
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(MercadilloViewModel::class.java)) {
            return MercadilloViewModel(MercadilloRepository(context)) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class: ${modelClass.name}")
    }
}

// app/src/main/java/es/nuskysoftware/marketsales/ui/pantallas/PantallaResumenVentas.kt
package es.nuskysoftware.marketsales.ui.pantallas

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.AttachMoney
import androidx.compose.material.icons.filled.CreditCard
import androidx.compose.material.icons.filled.Smartphone
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import es.nuskysoftware.marketsales.R
import es.nuskysoftware.marketsales.data.local.entity.LineaVentaEntity
import es.nuskysoftware.marketsales.utils.MonedaUtils

// ==== Reemplaza solo este composable y el de MetodoPagoIcon por los de abajo ====

@Composable
internal fun LineaVentaResumenCard(
    linea: LineaVentaEntity,
    metodoPago: String,
    moneda: String
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 1.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(12.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // LEADING RESERVADO (icono + chip cantidad)
            Row(
                modifier = Modifier
                    .width(48.dp),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(6.dp)
            ) {
                MetodoPagoIcon(
                    metodoPago = metodoPago,
                    size = 20.dp
                )

                // Chip de cantidad
                Box(
                    modifier = Modifier
                        .clip(MaterialTheme.shapes.small)
                        .background(MaterialTheme.colorScheme.surfaceVariant)
                        .padding(horizontal = 6.dp, vertical = 2.dp),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        text = linea.cantidad.toString(),
                        style = MaterialTheme.typography.labelMedium,
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }

            Spacer(Modifier.width(10.dp))

            // Centro: descripci√≥n + PU
            Column(
                modifier = Modifier.weight(1f)
            ) {
                Text(
                    text = linea.descripcion,
                    style = MaterialTheme.typography.bodyMedium,
                    maxLines = 2,
                    overflow = TextOverflow.Ellipsis
                )
                Text(
                    text = "PU: " + MonedaUtils.formatearImporte(linea.precioUnitario, moneda),
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }

            // Derecha: total de l√≠nea
            Text(
                text = MonedaUtils.formatearImporte(linea.subtotal, moneda),
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.SemiBold
            )
        }
    }
}

@Composable
private fun MetodoPagoIcon(
    metodoPago: String,
    size: androidx.compose.ui.unit.Dp
) {
    // 1) Intentar con drawables propios si existen
    val drawableId = when (metodoPago.uppercase()) {
        "EFECTIVO" -> R.drawable.ic_cash
        "BIZUM"    -> R.drawable.ic_bizum
        "TARJETA"  -> R.drawable.ic_card
        else       -> 0
    }

    val tint: Color = when (metodoPago.uppercase()) {
        "EFECTIVO" -> MaterialTheme.colorScheme.primary
        "BIZUM"    -> MaterialTheme.colorScheme.tertiary
        "TARJETA"  -> MaterialTheme.colorScheme.secondary
        else       -> MaterialTheme.colorScheme.onSurfaceVariant
    }

    when {
        // a) Hay drawable en /res
        drawableId != 0 -> {
            Icon(
                painter = painterResource(id = drawableId),
                contentDescription = metodoPago,
                tint = tint,
                modifier = Modifier.size(size)
            )
        }
        // b) Usar Material Icons (si tienes material-icons-extended)
        else -> {
            val vec: ImageVector = when (metodoPago.uppercase()) {
                "EFECTIVO" -> Icons.Filled.AttachMoney
                "BIZUM"    -> Icons.Filled.Smartphone
                "TARJETA"  -> Icons.Filled.CreditCard
                else       -> Icons.Filled.AttachMoney
            }
            Icon(
                imageVector = vec,
                contentDescription = metodoPago,
                tint = tint,
                modifier = Modifier.size(size)
            )
        }
    }
}



// app/src/main/java/es/nuskysoftware/marketsales/ui/viewmodel/VentasViewModel.kt

package es.nuskysoftware.marketsales.ui.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import es.nuskysoftware.marketsales.data.repository.LineaVentaUI
import es.nuskysoftware.marketsales.data.repository.MetodoPago
import es.nuskysoftware.marketsales.data.repository.PestanaVenta
import es.nuskysoftware.marketsales.data.repository.TipoLinea
import es.nuskysoftware.marketsales.data.repository.VentasRepository
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

data class VentasUiState(
    val pestanaActiva: PestanaVenta = PestanaVenta.MANUAL,
    val lineasTicket: List<LineaVentaUI> = emptyList(),
    val totalTicket: Double = 0.0,
    val importeActual: String = "0,00",
    val descripcionActual: String = "",
    val filtroCategoria: String = "",
    val terminoBusqueda: String = "",
    val loading: Boolean = false,
    val error: String? = null
)

/**
 * ViewModel de Ventas
 * - Mantiene el carrito (l√≠neas) y el total.
 * - L√≥gica del teclado num√©rico estilo TPV (2 decimales fijos).
 * - Finalizaci√≥n de venta: guarda en Room v√≠a Repository y dispara la sincronizaci√≥n offline-first.
 *
 * NOTA: El Factory va en archivo separado (VentasViewModelFactory.kt).
 */
class VentasViewModel(
    private val repository: VentasRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(VentasUiState())
    val uiState: StateFlow<VentasUiState> = _uiState.asStateFlow()

    // Contexto de la venta (inyectado por la pantalla contenedora)
    private var mercadilloId: String = ""
    private var usuarioId: String = "" // reservado si lo necesitas para metadata

    // ---------- Inicializaci√≥n de contexto ----------
    fun inicializar(mercadilloId: String, usuarioId: String) {
        this.mercadilloId = mercadilloId
        this.usuarioId = usuarioId
    }

    // ---------- Navegaci√≥n entre pesta√±as ----------
    fun cambiarPestana(nuevaPestana: PestanaVenta) {
        _uiState.value = _uiState.value.copy(pestanaActiva = nuevaPestana)
    }

    // ---------- Teclado num√©rico estilo TPV (2 decimales fijos) ----------
    fun onDigitoPresionado(digito: String) {
        val importeActual = _uiState.value.importeActual
        val nuevoImporte = calcularNuevoImporteTPV(importeActual, digito)
        _uiState.value = _uiState.value.copy(importeActual = nuevoImporte)
    }

    fun onDobleDecimalPresionado() {
        val paso1 = calcularNuevoImporteTPV(_uiState.value.importeActual, "0")
        val paso2 = calcularNuevoImporteTPV(paso1, "0")
        _uiState.value = _uiState.value.copy(importeActual = paso2)
    }

    fun onBorrarDigito() {
        val nuevoImporte = retrocederDigitoTPV(_uiState.value.importeActual)
        _uiState.value = _uiState.value.copy(importeActual = nuevoImporte)
    }

    private fun calcularNuevoImporteTPV(importeActual: String, nuevoDigito: String): String {
        // Normaliza coma/punto y quita separadores para tratar todo como d√≠gitos
        val soloNumeros = importeActual.replace(",", "").replace(".", "")
        val numerosConNuevo = soloNumeros + nuevoDigito
        // L√≠mite 7 d√≠gitos -> 99999,99
        val numerosFinal = if (numerosConNuevo.length > 7) {
            numerosConNuevo.takeLast(7)
        } else numerosConNuevo
        return formatearComoImporte(numerosFinal)
    }

    private fun retrocederDigitoTPV(importeActual: String): String {
        val soloNumeros = importeActual.replace(",", "").replace(".", "")
        return if (soloNumeros.length <= 1) {
            "0,00"
        } else {
            val numerosSinUltimo = soloNumeros.dropLast(1)
            formatearComoImporte(numerosSinUltimo)
        }
    }

    private fun formatearComoImporte(numeros: String): String {
        val numerosCompletos = numeros.padStart(3, '0')
        val decimales = numerosCompletos.takeLast(2)
        val enteros = numerosCompletos.dropLast(2)
        val enterosLimpios = enteros.toLongOrNull()?.toString() ?: "0"
        return "$enterosLimpios,$decimales"
    }

    fun obtenerImporteComoDouble(): Double {
        return _uiState.value.importeActual.replace(",", ".").toDoubleOrNull() ?: 0.0
    }

    // ---------- Descripci√≥n ----------
    fun actualizarDescripcion(nuevaDescripcion: String) {
        _uiState.value = _uiState.value.copy(descripcionActual = nuevaDescripcion)
    }

    // ---------- Carrito: a√±adir l√≠nea manual ----------
    fun a√±adirLineaManual() {
        val descripcion = _uiState.value.descripcionActual.trim()
        val importe = obtenerImporteComoDouble()

        if (descripcion.isBlank()) {
            mostrarError("La descripci√≥n es obligatoria")
            return
        }
        if (importe <= 0.0) {
            mostrarError("El importe debe ser mayor que 0")
            return
        }

        val nuevaLinea = LineaVentaUI(
            tipoLinea = TipoLinea.MANUAL,
            descripcion = descripcion,
            cantidad = 1,
            precioUnitario = importe,
            subtotal = importe
        )

        val lineasActualizadas = _uiState.value.lineasTicket + nuevaLinea
        _uiState.value = _uiState.value.copy(
            lineasTicket = lineasActualizadas,
            totalTicket = calcularTotal(lineasActualizadas)
        )

        resetearCampos()
    }

    fun eliminarLinea(lineaId: String) {
        val lineasActualizadas = _uiState.value.lineasTicket.filter { it.id != lineaId }
        _uiState.value = _uiState.value.copy(
            lineasTicket = lineasActualizadas,
            totalTicket = calcularTotal(lineasActualizadas)
        )
    }

    private fun calcularTotal(lineas: List<LineaVentaUI>): Double =
        lineas.sumOf { it.subtotal }

    fun resetearCampos() {
        _uiState.value = _uiState.value.copy(
            importeActual = "0,00",
            descripcionActual = ""
        )
    }

    // ---------- Finalizar venta (Room + trigger sync offline-first) ----------
    /**
     * Guarda la venta en Room a trav√©s del Repository (h√≠brido offline-first).
     * - Requiere que `inicializar(mercadilloId, usuarioId)` se haya llamado antes.
     * - Al completar correctamente, limpia el carrito.
     */
    fun finalizarVenta(metodoPago: MetodoPago) {
        val state = _uiState.value
        if (state.lineasTicket.isEmpty()) {
            mostrarError("No hay l√≠neas para vender")
            return
        }
        if (state.totalTicket <= 0.0) {
            mostrarError("El total debe ser mayor que 0")
            return
        }
        if (mercadilloId.isBlank()) {
            mostrarError("Mercadillo no inicializado")
            return
        }

        viewModelScope.launch {
            _uiState.value = state.copy(loading = true, error = null)
            try {
                val resultado = repository.guardarVenta(
                    idMercadillo = mercadilloId,
                    lineas = state.lineasTicket,
                    metodoPago = metodoPago.name,
                    total = state.totalTicket
                )
                if (resultado.isSuccess) {
                    limpiarVenta()
                } else {
                    mostrarError("Error al guardar la venta: ${resultado.exceptionOrNull()?.message}")
                }
            } catch (e: Exception) {
                mostrarError("Error al guardar la venta: ${e.message}")
            } finally {
                _uiState.value = _uiState.value.copy(loading = false)
            }
        }
    }

    /**
     * Dispara la sincronizaci√≥n de ventas pendientes (si hay conectividad).
     * Seguro de llamar: encapsulado en try/catch.
     */
    fun sincronizarPendientes() {
        viewModelScope.launch {
            try {
               // repository.sincronizarPendientes()
            } catch (_: Exception) {
                // Silencioso: el reintento ocurrir√° m√°s tarde.
            }
        }
    }

    private fun limpiarVenta() {
        // Conserva la pesta√±a activa; resetea el resto
        _uiState.value = VentasUiState(
            pestanaActiva = _uiState.value.pestanaActiva
        )
    }

    // ---------- Errores ----------
    private fun mostrarError(mensaje: String) {
        _uiState.value = _uiState.value.copy(error = mensaje)
    }

    fun limpiarError() {
        _uiState.value = _uiState.value.copy(error = null)
    }

    // ---------- Filtros / b√∫squeda (para pesta√±a productos) ----------
    fun actualizarTerminoBusqueda(termino: String) {
        _uiState.value = _uiState.value.copy(terminoBusqueda = termino)
    }

    fun actualizarFiltroCategoria(categoria: String) {
        _uiState.value = _uiState.value.copy(filtroCategoria = categoria)
    }

    fun a√±adirProducto(idProducto: String, descripcion: String, precio: Double) {
        val actuales = _uiState.value.lineasTicket

        // Busca √∫ltima l√≠nea del mismo producto para incrementar cantidad
        val indice = actuales.indexOfLast { it.tipoLinea == TipoLinea.PRODUCTO && it.idProducto == idProducto }

        val nuevasLineas = if (indice >= 0) {
            val linea = actuales[indice]
            val nuevaCantidad = linea.cantidad + 1
            actuales.toMutableList().apply {
                set(
                    indice,
                    linea.copy(
                        cantidad = nuevaCantidad,
                        subtotal = nuevaCantidad * linea.precioUnitario
                    )
                )
            }
        } else {
            actuales + LineaVentaUI(
                tipoLinea = TipoLinea.PRODUCTO,
                descripcion = descripcion,
                idProducto = idProducto,
                cantidad = 1,
                precioUnitario = precio,
                subtotal = precio
            )
        }

        _uiState.value = _uiState.value.copy(
            lineasTicket = nuevasLineas,
            totalTicket = nuevasLineas.sumOf { it.subtotal }
        )
    }

    // app/src/main/java/es/nuskysoftware/marketsales/ui/viewmodel/VentasViewModel.kt
// dentro de class VentasViewModel { ... }

    // Editar cantidad
    fun editarCantidadLinea(idLinea: String, nuevaCantidad: Int) {
        val actuales = _uiState.value.lineasTicket
        val nuevas = actuales.map { l ->
            if (l.id == idLinea) {
                if (nuevaCantidad <= 0) {
                    null // eliminar
                } else {
                    l.copy(
                        cantidad = nuevaCantidad,
                        subtotal = l.precioUnitario * nuevaCantidad
                    )
                }
            } else l
        }.filterNotNull()
        _uiState.value = _uiState.value.copy(
            lineasTicket = nuevas,
            totalTicket = nuevas.sumOf { it.subtotal }
        )
    }

    // Editar precio unitario
    fun editarPrecioUnitarioLinea(idLinea: String, nuevoPrecio: Double) {
        if (nuevoPrecio < 0) return
        val actuales = _uiState.value.lineasTicket
        val nuevas = actuales.map { l ->
            if (l.id == idLinea) {
                val nuevoSubtotal = nuevoPrecio * l.cantidad
                l.copy(precioUnitario = nuevoPrecio, subtotal = nuevoSubtotal)
            } else l
        }
        _uiState.value = _uiState.value.copy(
            lineasTicket = nuevas,
            totalTicket = nuevas.sumOf { it.subtotal }
        )
    }

}



package es.nuskysoftware.marketsales.ui.viewmodel

import android.content.Context
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import es.nuskysoftware.marketsales.data.repository.VentasRepository
import es.nuskysoftware.marketsales.ui.viewmodel.VentasViewModel

class VentasViewModelFactory(
    private val context: Context
) : ViewModelProvider.Factory {

    @Suppress("UNCHECKED_CAST")
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(VentasViewModel::class.java)) {
            val repository = VentasRepository(context)
            return VentasViewModel(repository) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class: ${modelClass.name}")
    }
}

// app/src/main/java/es/nuskysoftware/marketsales/utils/ColorUtils.kt
package es.nuskysoftware.marketsales.utils

import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.toArgb
import kotlin.random.Random

/**
 * ColorUtils V11 - Market Sales
 *
 * Utilidades para manejo de colores en la aplicaci√≥n.
 * Migrado desde Caja Mercadillos y adaptado para Market Sales.
 */

/**
 * Genera un color aleatorio en tonos pastel
 * Los colores pastel tienen valores RGB altos (150-255) para ser suaves y agradables
 */
fun generarColorAleatorioPastel(): Color {
    val r = Random.nextInt(150, 256)
    val g = Random.nextInt(150, 256)
    val b = Random.nextInt(150, 256)
    return Color(r, g, b)
}

/**
 * Convierte un Color de Compose a String HEX
 */
fun Color.toHexString(): String {
    return String.format("#%06X", 0xFFFFFF and this.toArgb())
}

/**
 * Convierte un String HEX a Color de Compose
 * @param hexString String en formato "#RRGGBB"
 * @return Color o Color.White si el formato es inv√°lido
 */
fun hexStringToColor(hexString: String): Color {
    return try {
        Color(android.graphics.Color.parseColor(hexString))
    } catch (e: Exception) {
        Color.White
    }
}

/**
 * Verifica si un string es un color HEX v√°lido
 */
fun isValidHexColor(hexString: String): Boolean {
    return hexString.matches(Regex("^#[0-9A-Fa-f]{6}$"))
}

/**
 * Obtiene un color de contraste (blanco o negro) seg√∫n el brillo del color de fondo
 */
fun Color.getContrastColor(): Color {
    // Calcular luminancia usando la f√≥rmula est√°ndar
    val luminance = (0.299 * red + 0.587 * green + 0.114 * blue)
    return if (luminance > 0.5) Color.Black else Color.White
}

/**
 * Colores predefinidos pastel para categor√≠as
 */
object ColoresPastelPredefinidos {
    val ROSA_PASTEL = Color(0xFFFFB6C1)
    val AZUL_PASTEL = Color(0xFFADD8E6)
    val VERDE_PASTEL = Color(0xFF98FB98)
    val AMARILLO_PASTEL = Color(0xFFFFFACD)
    val LAVANDA_PASTEL = Color(0xFFE6E6FA)
    val MELOCOTON_PASTEL = Color(0xFFFFDAB9)
    val MENTA_PASTEL = Color(0xFFF0FFF0)
    val CORAL_PASTEL = Color(0xFFF08080)

    /**
     * Lista de todos los colores predefinidos
     */
    val TODOS = listOf(
        ROSA_PASTEL,
        AZUL_PASTEL,
        VERDE_PASTEL,
        AMARILLO_PASTEL,
        LAVANDA_PASTEL,
        MELOCOTON_PASTEL,
        MENTA_PASTEL,
        CORAL_PASTEL
    )

    /**
     * Obtiene un color aleatorio de los predefinidos
     */
    fun obtenerAleatorio(): Color {
        return TODOS.random()
    }
}




// app/src/main/java/es/nuskysoftware/marketsales/utils/ConfigurationManager.kt
package es.nuskysoftware.marketsales.utils

import android.content.ContentValues.TAG
import android.util.Log
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow

/**
 * ‚úÖ COMPLETO V10 - ConfigurationManager con TODOS los m√©todos necesarios
 */
object ConfigurationManager {

    // ========== ESTADOS V10 ==========
    private val _idioma = MutableStateFlow("es")
    private val _fuente = MutableStateFlow("Montserrat")
    private val _temaOscuro = MutableStateFlow(false)
    private val _moneda = MutableStateFlow("‚Ç¨ Euro")
    private val _usuarioLogueado = MutableStateFlow<String?>("usuario_default")
    // O si quieres que el valor inicial cuando nadie est√° logueado sea null:
    // private val _usuarioLogueado = MutableStateFlow<String?>(null)
    private val _usuarioEmail = MutableStateFlow<String?>(null)
    private val _displayName = MutableStateFlow<String?>(null)
    private val _versionApp = MutableStateFlow(0) // Para compatibilidad

    private val _isAuthenticated = MutableStateFlow(false)

    private var lastSuccessfulPremiumState: Boolean? = null

    private var lastUpdateTimestamp = 0L


    // ========== ESTADOS P√öBLICOS ==========
    val idioma: StateFlow<String> = _idioma.asStateFlow()
    val fuente: StateFlow<String> = _fuente.asStateFlow()
    val temaOscuro: StateFlow<Boolean> = _temaOscuro.asStateFlow()
    val moneda: StateFlow<String> = _moneda.asStateFlow()
    val usuarioEmail: StateFlow<String?> = _usuarioEmail.asStateFlow()
    val versionApp: StateFlow<Int> = _versionApp.asStateFlow()

    val isAuthenticated: StateFlow<Boolean> = _isAuthenticated.asStateFlow()
    val displayName: StateFlow<String?> = _displayName.asStateFlow()
    val usuarioLogueado: StateFlow<String?> = _usuarioLogueado.asStateFlow()

    private val _esPremium = MutableStateFlow(false)
    val esPremium: StateFlow<Boolean> = _esPremium.asStateFlow()

    /**
     * Toggle Premium para desarrollo - SIMPLIFICADO SIN PROTECCIONES
     */
    fun togglePremiumForDevelopment() {
        val newValue = !_esPremium.value

        Log.d("ConfigurationManager", "üîß TOGGLE PREMIUM (Development):")
        Log.d("ConfigurationManager", "   - Antes: ${_esPremium.value}")
        Log.d("ConfigurationManager", "   - Despu√©s: $newValue")

        // Cambio directo sin protecciones para desarrollo
        _esPremium.value = newValue
        _versionApp.value = if (newValue) 1 else 0

        Log.d("ConfigurationManager", "‚úÖ Premium toggled exitosamente")
    }

    /**
     * Establece estado premium directamente (para desarrollo)
     */
    fun setPremiumForDevelopment(isPremium: Boolean) {
        Log.d("ConfigurationManager", "üîß SET PREMIUM (Development): ${_esPremium.value} ‚Üí $isPremium")

        _esPremium.value = isPremium
        _versionApp.value = if (isPremium) 1 else 0

        Log.d("ConfigurationManager", "‚úÖ Premium establecido: $isPremium")
    }

    // ========== M√âTODOS PRINCIPALES ==========
    fun updateUserConfigurationProtected(
        displayName: String? = null,
        usuarioEmail: String? = null,
        planUsuario: String = "FREE",
        isAuthenticated: Boolean = false,
        source: String = "unknown"
    ) {
        val currentTime = System.currentTimeMillis()

        // ‚úÖ PROTECCI√ìN: Si el displayName cambi√≥ hace menos de 5 segundos, no sobrescribir
        if (displayName != null && _displayName.value != displayName) {
            if (currentTime - lastUpdateTimestamp < 5000) {
                Log.w("ConfigurationManager", "üö´ PROTECCI√ìN: Evitando sobrescribir displayName reciente")
                Log.w("ConfigurationManager", "   - Valor actual: ${_displayName.value}")
                Log.w("ConfigurationManager", "   - Valor que se quiere poner: $displayName")
                Log.w("ConfigurationManager", "   - Tiempo desde √∫ltimo cambio: ${currentTime - lastUpdateTimestamp}ms")
                return
            }
        }

        // Actualizar timestamp si hay cambio de displayName
        if (displayName != null && _displayName.value != displayName) {
            lastUpdateTimestamp = currentTime
            Log.d("ConfigurationManager", "üïí Actualizando timestamp de protecci√≥n")
        }

        // Llamar al m√©todo normal
        updateUserConfiguration(
            displayName = displayName,
            usuarioEmail = usuarioEmail,
            planUsuario = planUsuario,
            isAuthenticated = isAuthenticated
        )
    }
    /**
     * Obtiene el ID del usuario actual
     */
    fun getCurrentUserId(): String? {
        return _usuarioLogueado.value
    }

    // ========== M√âTODOS GET ==========
    fun getIdioma(): String = _idioma.value
    fun getFuente(): String = _fuente.value
    fun getModoOscuro(): Boolean = _temaOscuro.value
    fun getTemaOscuro(): Boolean = _temaOscuro.value
    fun getMoneda(): String = _moneda.value
    fun getUsuarioEmail(): String? = _usuarioEmail.value
    fun getUsuarioId(): String? = _usuarioLogueado.value.takeIf { it != "usuario_default" }
    fun getVersionApp(): Int = _versionApp.value
    fun getIsPremium(): Boolean = _esPremium.value

    // ========== M√âTODOS DE AUTENTICACI√ìN ==========

    /**
     * Login de usuario
     */
    fun login(userId: String, email: String?, displayName: String? = null, isPremium: Boolean = false) {
        _usuarioLogueado.value = userId
        _usuarioEmail.value = email
        _displayName.value = displayName
       //_esPremium.value = isPremium
        setEsPremiumProtected(isPremium, "updateUserConfiguration")

        _versionApp.value = if (isPremium) 1 else 0
        _isAuthenticated.value = true
    }


    private fun setEsPremiumProtected(newValue: Boolean, source: String = "unknown") {
        val oldValue = _esPremium.value

        Log.d("ConfigurationManager", "üîÑ INTENTO CAMBIO esPremium: $oldValue ‚Üí $newValue")
        Log.d("ConfigurationManager", "   - Fuente: $source")
        Log.d("ConfigurationManager", "   - lastSuccessfulPremiumState: $lastSuccessfulPremiumState")
        Log.d("ConfigurationManager", "   - isAuthenticated: ${_isAuthenticated.value}")

        // üõ°Ô∏è PROTECCI√ìN MEJORADA: Solo bloquear si usuario est√° autenticado
        if (oldValue == true && newValue == false && _isAuthenticated.value == true) {
            Log.e("ConfigurationManager", "üö® BLOQUEANDO CAMBIO - Usuario autenticado premium")
            Thread.currentThread().stackTrace.take(15).forEach { frame ->
                Log.e("ConfigurationManager", "     at ${frame.className}.${frame.methodName}(${frame.fileName}:${frame.lineNumber})")
            }
            return
        }

        // ‚úÖ PERMITIR logout cuando isAuthenticated = false
        if (oldValue == true && newValue == false && _isAuthenticated.value == false) {
            Log.w("ConfigurationManager", "‚úÖ PERMITIENDO logout - Usuario no autenticado")
        }

        _esPremium.value = newValue
        Log.d("ConfigurationManager", "‚úÖ esPremium cambiado: $oldValue ‚Üí $newValue (fuente: $source)")
    }
    /**
     * Logout de usuario
     */

    fun logout() {
        Log.d("ConfigurationManager", "üö™ logout() llamado!")
        Log.d("ConfigurationManager", "   - esPremium antes: ${_esPremium.value}")
        Log.d("ConfigurationManager", "   - STACK TRACE:")
        Thread.currentThread().stackTrace.take(8).forEach { frame ->
            Log.d("ConfigurationManager", "     at ${frame.className}.${frame.methodName}(${frame.fileName}:${frame.lineNumber})")
        }

        // üîì Limpiar estado de protecci√≥n en logout real
        lastSuccessfulPremiumState = null
        Log.d("ConfigurationManager", "   - Protecci√≥n premium limpiada")

        // üîÑ Llamar a reset despu√©s de limpiar protecci√≥n
        resetToDefaults()

        Log.d("ConfigurationManager", "   - esPremium despu√©s: ${_esPremium.value}")
        Log.d("ConfigurationManager", "   - ‚úÖ Logout completado")
    }
    // ========== M√âTODOS DE CONFIGURACI√ìN ==========

    /**
     * Verifica si el usuario puede cambiar configuraci√≥n
     */
    fun canChangeConfiguration(): Boolean {
        return _esPremium.value
    }

    /**
     * Actualiza configuraci√≥n global
     */
    fun updateGlobalConfiguration(
        idioma: String,
        fuente: String,
        temaOscuro: Boolean,
        moneda: String
    ) {
        _idioma.value = idioma
        _fuente.value = fuente
        _temaOscuro.value = temaOscuro
        _moneda.value = moneda
    }

    /**
     * Actualiza premium del usuario
     */
    fun updateUserPremium(isPremium: Boolean) {
        setEsPremiumProtected(isPremium, "updateUserConfiguration")
        _versionApp.value = if (isPremium) 1 else 0
    }

    // ========== M√âTODOS UPDATE EXISTENTES ==========
    fun updateConfiguration(
        idioma: String,
        fuente: String,
        modoOscuro: Boolean,
        isPremium: Boolean
    ) {
        _idioma.value = idioma
        _fuente.value = fuente
        _temaOscuro.value = modoOscuro
        setEsPremiumProtected(isPremium, "updateUserConfiguration")
        _versionApp.value = if (isPremium) 1 else 0
    }

    // A√±ade estos logs TEMPORALES en ConfigurationManager.kt en estos m√©todos:

    fun updateUserConfiguration(
        idioma: String = _idioma.value,
        fuente: String = _fuente.value,
        temaOscuro: Boolean = _temaOscuro.value,
        usuarioEmail: String? = _usuarioEmail.value,
        usuarioId: String? = null,
        planUsuario: String = "FREE",
        empresaId: String? = null,
        tipoUsuario: String? = null,
        displayName: String? = null,
        photoUrl: String? = null,
        isAuthenticated: Boolean = false,
        moneda: String = _moneda.value ,


        ) {
        // üîç LOG TEMPORAL
        Log.d("ConfigurationManager", "üîß updateUserConfiguration llamado:")
        Log.d("ConfigurationManager", "   - planUsuario: $planUsuario")
        Log.d("ConfigurationManager", "   - isAuthenticated: $isAuthenticated")
        Log.d("ConfigurationManager", "   - esPremium antes: ${_esPremium.value}")

        Log.d("ConfigurationManager", "üîß updateUserConfiguration - displayName recibido: $displayName")
        Log.d("ConfigurationManager", "üîß _displayName.value antes: ${_displayName.value}")

        Log.d("ConfigurationManager", "üîß FINAL updateUserConfiguration:")
        Log.d("ConfigurationManager", "   - displayName: ${_displayName.value}")
        Log.d("ConfigurationManager", "   - isAuthenticated: ${_isAuthenticated.value}")
        Log.d("ConfigurationManager", "   - esPremium: ${_esPremium.value}")


        // Actualizar valores de configuraci√≥n
        _idioma.value = idioma
        _fuente.value = fuente
        _temaOscuro.value = temaOscuro
        _usuarioEmail.value = usuarioEmail
        _displayName.value = displayName
        _moneda.value = moneda
        _isAuthenticated.value = isAuthenticated

        // Calcular estado premium
        val isPremium = planUsuario == "PREMIUM" && isAuthenticated
        setEsPremiumProtected(isPremium, "updateUserConfiguration")
        _versionApp.value = if (isPremium) 1 else 0

        // Configurar usuario
        _usuarioLogueado.value = if (isAuthenticated && usuarioId != null) {
            usuarioId
        } else {
            "usuario_default"
        }

        // üíæ Guardar √∫ltimo estado premium v√°lido para protecci√≥n
        if (isPremium) {
            lastSuccessfulPremiumState = true
            Log.d("ConfigurationManager", "   - esPremium despu√©s: ${_esPremium.value}")
        }
        if (displayName != null) {
            _displayName.value = displayName
        }

        Log.d("ConfigurationManager", "üîß _displayName.value despu√©s: ${_displayName.value}")

        // ... resto del c√≥digo ...


        // üîç LOG TEMPORAL
        Log.d("ConfigurationManager", "   - esPremium despu√©s: ${_esPremium.value}")
        Log.d("ConfigurationManager", "   - STACK TRACE:")
        Thread.currentThread().stackTrace.take(8).forEach { frame ->
            Log.d("ConfigurationManager", "     at ${frame.className}.${frame.methodName}(${frame.fileName}:${frame.lineNumber})")
        }
    }

    fun forceUpdateDisplayName(newDisplayName: String) {
        Log.d(TAG, "üîß forceUpdateDisplayName: ${_displayName.value} ‚Üí $newDisplayName")
        _displayName.value = newDisplayName
        Log.d(TAG, "üîß forceUpdateDisplayName DESPU√âS: ${_displayName.value}")
    }


    // ========== M√âTODOS SET ==========
    fun setIdioma(idioma: String) {
        _idioma.value = idioma
    }

    fun setFuente(fuente: String) {
        _fuente.value = fuente
    }

    fun setTemaOscuro(temaOscuro: Boolean) {
        _temaOscuro.value = temaOscuro
    }

    fun setModoOscuro(modoOscuro: Boolean) {
        _temaOscuro.value = modoOscuro
    }

    fun setUsuarioEmail(email: String?) {
        _usuarioEmail.value = email
    }

    fun setUsuarioLogueado(userId: String?) {
        _usuarioLogueado.value = userId ?: "usuario_default"
    }

    fun setUsuarioId(userId: String?) {
        setUsuarioLogueado(userId)
    }

    fun setMoneda(moneda: String) {
        _moneda.value = moneda
    }

    fun setIsPremium(isPremium: Boolean) {
        setEsPremiumProtected(isPremium, "updateUserConfiguration")
        _versionApp.value = if (isPremium) 1 else 0
    }

    fun setVersionApp(versionApp: Int) {
        _versionApp.value = versionApp
        setEsPremiumProtected(versionApp == 1, "setVersionApp")
    }

    fun resetToDefaults() {
        // üîç LOG TEMPORAL
        Log.d("ConfigurationManager", "üîÑ resetToDefaults() llamado!")
        Log.d("ConfigurationManager", "   - esPremium antes: ${_esPremium.value}")
        Log.d("ConfigurationManager", "   - lastSuccessfulPremiumState: $lastSuccessfulPremiumState")
        Log.d("ConfigurationManager", "   - STACK TRACE:")
        Thread.currentThread().stackTrace.take(8).forEach { frame ->
            Log.d("ConfigurationManager", "     at ${frame.className}.${frame.methodName}(${frame.fileName}:${frame.lineNumber})")
        }

        // üõ°Ô∏è PROTECCI√ìN: No resetear si hay un estado premium v√°lido y el usuario est√° autenticado
        if (lastSuccessfulPremiumState == true && _isAuthenticated.value) {
            Log.w("ConfigurationManager", "üö´ EVITANDO RESET - Usuario premium autenticado detectado")
            return
        }

        // Resetear todos los valores a defaults
        _idioma.value = "es"
        _fuente.value = "Montserrat"
        _temaOscuro.value = false
        _moneda.value = "‚Ç¨ Euro"
        _usuarioLogueado.value = "usuario_default"
        _usuarioEmail.value = null
        _displayName.value = null
        setEsPremiumProtected(false, "resetToDefaults")
        _versionApp.value = 0
        _isAuthenticated.value = false

        // Limpiar estado de protecci√≥n solo en logout real
        lastSuccessfulPremiumState = null

        Log.d("ConfigurationManager", "   - ‚úÖ Reset completado")

        Log.d("ConfigurationManager", "   - esPremium despu√©s: ${_esPremium.value}")
        Log.d("ConfigurationManager", "   - ‚úÖ Reset completado")
    }

    // ========== VERIFICACIONES ==========
    fun isUsuarioLogueado(): Boolean {
        return _usuarioLogueado.value != "usuario_default"
    }

    fun isPremium(): Boolean = _esPremium.value
    fun isFree(): Boolean = !_esPremium.value
}


// app/src/main/java/es/nuskysoftware/marketsales/utils/ConnectivityObserver.kt
package es.nuskysoftware.marketsales.utils

import android.content.Context
import android.net.*
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow

/**
 * Observa el estado de la red (online/offline) usando ConnectivityManager
 * y expone un StateFlow<Boolean>.
 */
class ConnectivityObserver(context: Context) {

    private val cm = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
    private val _isConnected = MutableStateFlow(isCurrentlyConnected())
    val isConnected: StateFlow<Boolean> = _isConnected

    init {
        val request = NetworkRequest.Builder()
            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
            .build()

        cm.registerNetworkCallback(request, object : ConnectivityManager.NetworkCallback() {
            override fun onAvailable(network: Network) {
                _isConnected.value = true
            }
            override fun onLost(network: Network) {
                _isConnected.value = isCurrentlyConnected()
            }
        })
    }

    private fun isCurrentlyConnected(): Boolean {
        val n = cm.activeNetwork ?: return false
        val caps = cm.getNetworkCapabilities(n) ?: return false
        return caps.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
    }
}


// app/src/main/java/es/nuskysoftware/marketsales/utils/EstadosMercadillo.kt
package es.nuskysoftware.marketsales.utils

import android.util.Log
import androidx.compose.ui.graphics.Color
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Locale

/**
 * EstadosMercadillo V11 - Market Sales
 *
 * ‚úÖ Sistema centralizado para gestionar todos los estados de mercadillos
 * ‚úÖ Incluye colores, descripciones y l√≥gica relacionada
 * ‚úÖ Estados autom√°ticos basados en condiciones de negocio
 * ‚úÖ Compatible con arquitectura h√≠brida "Reloj Suizo"
 */
object EstadosMercadillo {

    /**
     * Enum con todos los estados posibles de un mercadillo
     * Los c√≥digos coinciden con el campo 'estado' en MercadilloEntity
     */
    enum class Estado(val codigo: Int, val descripcion: String) {
        PROGRAMADO_PARCIAL(1, "Programado parcialmente"),
        PROGRAMADO_TOTAL(2, "Programado totalmente"),
        EN_CURSO(3, "En curso"),
        PENDIENTE_ARQUEO(4, "Terminado (pendiente arqueo)"),
        PENDIENTE_ASIGNAR_SALDO(5, "Arqueo realizado (pendiente asignar saldo)"),
        CERRADO_COMPLETO(6, "Cerrado completamente"),
        CANCELADO(7, "Cancelado");

        companion object {
            /**
             * Obtiene el estado por su c√≥digo
             */
            fun fromCodigo(codigo: Int): Estado? = values().find { it.codigo == codigo }

            /**
             * Obtiene el estado por defecto para nuevos mercadillos
             */
            fun getEstadoInicial(): Estado = PROGRAMADO_PARCIAL
        }
    }

    /**
     * Obtiene el color asociado a cada estado para la UI
     */
    fun obtenerColor(estado: Estado): Color {
        return when (estado) {
            Estado.PROGRAMADO_PARCIAL -> Color(0xFF81C7E8)      // Azul claro
            Estado.PROGRAMADO_TOTAL -> Color(0xFF1976D2)        // Azul oscuro
            Estado.EN_CURSO -> Color(0xFF4CAF50)                // Verde
            Estado.PENDIENTE_ARQUEO -> Color(0xFFFF9800)        // Naranja ‚ö†Ô∏è
            Estado.PENDIENTE_ASIGNAR_SALDO -> Color(0xFFF44336) // Rojo ‚ö†Ô∏è
            Estado.CERRADO_COMPLETO -> Color(0xFF2E7D32)        // Verde oscuro
            Estado.CANCELADO -> Color(0xFF757575)               // Gris
        }
    }

    /**
     * Obtiene el color de texto m√°s apropiado para cada fondo
     */
    fun obtenerColorTexto(estado: Estado): Color {
        return when (estado) {
            Estado.PROGRAMADO_PARCIAL -> Color.Black
            Estado.PROGRAMADO_TOTAL -> Color.White
            Estado.EN_CURSO -> Color.White
            Estado.PENDIENTE_ARQUEO -> Color.Black
            Estado.PENDIENTE_ASIGNAR_SALDO -> Color.White
            Estado.CERRADO_COMPLETO -> Color.White
            Estado.CANCELADO -> Color.White
        }
    }

    /**
     * Devuelve todos los estados para mostrar en la leyenda
     */
    fun obtenerTodosLosEstados(): List<Estado> {
        return Estado.values().toList()
    }

    /**
     * Obtiene el icono/emoji representativo de cada estado
     */
    fun obtenerIcono(estado: Estado): String {
        return when (estado) {
            Estado.PROGRAMADO_PARCIAL -> "üìã"
            Estado.PROGRAMADO_TOTAL -> "üìÖ"
            Estado.EN_CURSO -> "üü¢"
            Estado.PENDIENTE_ARQUEO -> "‚ö†Ô∏è"
            Estado.PENDIENTE_ASIGNAR_SALDO -> "üî¥"
            Estado.CERRADO_COMPLETO -> "‚úÖ"
            Estado.CANCELADO -> "‚ùå"
        }
    }

    /**
     * Indica si el estado requiere atenci√≥n urgente del usuario
     */
    fun requiereAtencion(estado: Estado): Boolean {
        return estado == Estado.PENDIENTE_ARQUEO || estado == Estado.PENDIENTE_ASIGNAR_SALDO
    }

    /**
     * Obtiene el orden de prioridad para mostrar en calendario cuando hay m√∫ltiples mercadillos
     * Menor n√∫mero = mayor prioridad
     */
    fun obtenerPrioridad(estado: Estado): Int {
        return when (estado) {
            Estado.EN_CURSO -> 1                    // M√°xima prioridad
            Estado.PENDIENTE_ARQUEO -> 2            // Urgente
            Estado.PENDIENTE_ASIGNAR_SALDO -> 3     // Urgente
            Estado.PROGRAMADO_TOTAL -> 4
            Estado.PROGRAMADO_PARCIAL -> 5
            Estado.CERRADO_COMPLETO -> 6
            Estado.CANCELADO -> 7                   // M√≠nima prioridad
        }
    }

    /**
     * Indica si un mercadillo puede ser cancelado
     * Solo se puede cancelar si no tiene ventas asociadas
     */
    fun puedeSerCancelado(estado: Estado, tieneVentas: Boolean): Boolean {
        return !tieneVentas && estado != Estado.CANCELADO && estado != Estado.CERRADO_COMPLETO
    }

    /**
     * Indica si se pueden asignar ventas a un mercadillo
     * Solo se pueden asignar ventas a mercadillos EN_CURSO
     */
    fun puedeRecibirVentas(estado: Estado): Boolean {
        return estado == Estado.EN_CURSO
    }

    /**
     * Calcula el estado autom√°tico basado en fecha, hora y datos del mercadillo
     */
    fun calcularEstadoAutomatico(
        saldoInicial: Double?,
        fecha: String,
        horaFin: String,
        arqueoCaja: Double?,
        pendienteAsignarSaldo: Boolean,
        fechaActual: String,
        horaActual: String
    ): Estado {
        try {
            val dateFormat = SimpleDateFormat("dd-MM-yyyy", Locale.getDefault())
            val timeFormat = SimpleDateFormat("HH:mm", Locale.getDefault())

            val fechaMercadillo = dateFormat.parse(fecha)
            val fechaHoy = dateFormat.parse(fechaActual)
            val horaFinMercadillo = timeFormat.parse(horaFin)
            val horaAhora = timeFormat.parse(horaActual)

            if (fechaMercadillo == null || fechaHoy == null || horaFinMercadillo == null || horaAhora == null) {
                return Estado.PROGRAMADO_PARCIAL
            }

            // Calcular ayer
            val calendar = Calendar.getInstance()
            calendar.time = fechaHoy
            calendar.add(Calendar.DAY_OF_MONTH, -1)
            val ayer = calendar.time

            // Si es anterior a ayer ‚Üí mantener estado actual
            if (fechaMercadillo.before(ayer)) {
                return when {
                    arqueoCaja != null -> Estado.CERRADO_COMPLETO
                    pendienteAsignarSaldo -> Estado.PENDIENTE_ASIGNAR_SALDO
                    else -> if (saldoInicial != null) Estado.PROGRAMADO_TOTAL else Estado.PROGRAMADO_PARCIAL
                }
            }

            // Si es ma√±ana o futuro ‚Üí PROGRAMADO
            if (fechaMercadillo.after(fechaHoy)) {
                return if (saldoInicial != null) Estado.PROGRAMADO_TOTAL else Estado.PROGRAMADO_PARCIAL
            }

            // Si es HOY ‚Üí ACTUAL
            if (fechaMercadillo.equals(fechaHoy)) {
                return Estado.EN_CURSO
            }

            // Si es AYER y son menos de las 5:00am ‚Üí ACTUAL (mercadillos nocturnos)
            calendar.time = fechaHoy
            calendar.set(Calendar.HOUR_OF_DAY, 5)
            calendar.set(Calendar.MINUTE, 0)
            calendar.set(Calendar.SECOND, 0)
            val cincoAM = timeFormat.format(calendar.time)
            val cincoAMTime = timeFormat.parse(cincoAM)

            if (fechaMercadillo.equals(ayer) && horaAhora != null && cincoAMTime != null && horaAhora.before(cincoAMTime)) {
                return Estado.EN_CURSO
            }

            // Si es AYER y son las 5:00am o m√°s tarde ‚Üí PENDIENTE_ARQUEO
            if (fechaMercadillo.equals(ayer)) {
                return when {
                    arqueoCaja != null && pendienteAsignarSaldo -> Estado.PENDIENTE_ASIGNAR_SALDO
                    arqueoCaja != null -> Estado.CERRADO_COMPLETO
                    else -> Estado.PENDIENTE_ARQUEO
                }
            }

            // Por defecto
            return when {
                arqueoCaja != null && !pendienteAsignarSaldo -> Estado.CERRADO_COMPLETO
                arqueoCaja != null && pendienteAsignarSaldo -> Estado.PENDIENTE_ASIGNAR_SALDO
                else -> Estado.PENDIENTE_ARQUEO
            }

        } catch (e: Exception) {
            Log.e("EstadosMercadillo", "Error calculando estado autom√°tico", e)
            return if (saldoInicial != null) Estado.PROGRAMADO_TOTAL else Estado.PROGRAMADO_PARCIAL
        }
    }
}


// app/src/main/java/es/nuskysoftware/marketsales/utils/FooterMarca.kt
package es.nuskysoftware.marketsales.utils

import androidx.compose.foundation.layout.*
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp

@Composable
fun FooterMarca() {
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp)
            .windowInsetsPadding(WindowInsets.navigationBars) // ‚úÖ Respeta barras de navegaci√≥n
            .padding(vertical = 8.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(
            text = "¬© La Nusky Software",
            fontSize = 12.sp,
            fontWeight = FontWeight.Normal,
            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f),
            textAlign = TextAlign.Center
        )
    }
}

package es.nuskysoftware.marketsales.utils

import android.content.Context
import com.google.android.gms.auth.api.signin.GoogleSignIn
import com.google.android.gms.auth.api.signin.GoogleSignInClient
import com.google.android.gms.auth.api.signin.GoogleSignInOptions
import es.nuskysoftware.marketsales.R

/**
 * Helper class para manejar Google Sign-In de forma centralizada
 * V8 - Google Auth implementation
 */
object GoogleAuthHelper {

    /**
     * Obtiene el cliente de Google Sign-In configurado
     */
    fun getGoogleSignInClient(context: Context): GoogleSignInClient {
        val webClientId = context.getString(R.string.web_client_id)

        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)
            .requestIdToken(webClientId)
            .requestEmail()
            .requestProfile()
            .build()

        return GoogleSignIn.getClient(context, gso)
    }

    /**
     * Verifica si hay un usuario ya logueado con Google
     */
    fun getLastSignedInAccount(context: Context) = GoogleSignIn.getLastSignedInAccount(context)

    /**
     * Cierra sesi√≥n de Google
     */
    fun signOut(context: Context, onComplete: () -> Unit = {}) {
        getGoogleSignInClient(context).signOut().addOnCompleteListener {
            onComplete()
        }
    }

    /**
     * Revoca el acceso de Google
     */
    fun revokeAccess(context: Context, onComplete: () -> Unit = {}) {
        getGoogleSignInClient(context).revokeAccess().addOnCompleteListener {
            onComplete()
        }
    }
}

// app/src/main/java/es/nuskysoftware/marketsales/utils/MonedaUtils.kt
package es.nuskysoftware.marketsales.utils

import java.text.DecimalFormat
import java.text.DecimalFormatSymbols
import java.util.Locale

/**
 * Utilidades de formato monetario basadas en ConfigurationManager.moneda.
 * Requisito: mostrar como "12,34‚Ç¨" (SIN espacio).
 */
object MonedaUtils {

    /** Obtiene el s√≠mbolo a partir de ConfigurationManager.moneda (ej. "‚Ç¨ Euro", "$ D√≥lar"). */
    fun obtenerSimboloMoneda(configMoneda: String): String {
        val raw = configMoneda.trim()
        if (raw.isEmpty()) return "‚Ç¨"
        val first = raw.first()
        // Si comienza con s√≠mbolo, lo usamos
        if (!first.isLetterOrDigit()) return first.toString()
        // Mapear por nombre
        val lower = raw.lowercase(Locale.ROOT)
        return when {
            "euro" in lower || "‚Ç¨" in lower -> "‚Ç¨"
            "d√≥lar" in lower || "dolar" in lower || "$" in lower -> "$"
            "libra" in lower || "¬£" in lower -> "¬£"
            else -> "‚Ç¨"
        }
    }

    /**
     * Formatea un importe double a "12,34‚Ç¨" (coma decimal, 2 decimales, SIN espacio).
     */
    fun formatearImporte(valor: Double, configMoneda: String): String {
        val symbols = DecimalFormatSymbols(Locale("es", "ES")).apply {
            decimalSeparator = ','
            groupingSeparator = '.'
        }
        val df = DecimalFormat("#,##0.00", symbols)
        val simbolo = obtenerSimboloMoneda(configMoneda)
        return df.format(valor) + simbolo
    }
}


package es.nuskysoftware.marketsales.utils

import java.util.Locale

/**
 * Gestor de recursos de string que permite cambio din√°mico de idioma
 * V11 - Con strings completos para PantallaPerfil + PantallaCategorias
 */
object StringResourceManager {

    fun getString(key: String, language: String = "es"): String {
        return when (language) {
            "en" -> getEnglishString(key)
            "es" -> getSpanishString(key)
            else -> getSpanishString(key)
        }
    }

    /**
     * Strings en espa√±ol
     */
    private fun getSpanishString(key: String): String = when (key) {
        // Pantalla principal
        "app_name" -> "Market Sales"
        "mercadillos" -> "Mercadillos"
        "configuracion" -> "Configuraci√≥n"
        "articulos" -> "Art√≠culos"
        "categorias" -> "Categor√≠as"
        "inventario" -> "Inventario"
        "listados" -> "Listados"
        "iniciar_sesion" -> "Iniciar Sesi√≥n"
        "cerrar_sesion" -> "Cerrar Sesi√≥n"
        "salir" -> "Salir"
        "perfil" -> "Perfil"

        // Configuraci√≥n
        "informacion_cuenta" -> "Informaci√≥n de Cuenta"
        "cambiar_contrasena" -> "Cambiar Contrase√±a"
        "tema" -> "Tema"
        "fuente" -> "Fuente"
        "idioma" -> "Idioma"
        "moneda" -> "Moneda"
        "version_premium" -> "PREMIUM"
        "version_free" -> "FREE"
        "promocion_premium" -> "¬°Actualiza a Premium!"
        "desbloquea_funciones" -> "Desbloquea todas las funciones"

        // Tema
        "tema_claro" -> "Claro"
        "tema_oscuro" -> "Oscuro"

        // Idiomas
        "espanol" -> "Espa√±ol"
        "ingles" -> "English"

        // Fuentes
        "montserrat" -> "Montserrat"
        "poppins" -> "Poppins"
        "roboto" -> "Roboto"

        // Monedas
        "euro" -> "‚Ç¨ Euro"
        "dolar" -> "$ D√≥lar"
        "libra" -> "¬£ Libra"
        "yen" -> "¬• Yen"

        // ‚úÖ PANTALLA PERFIL - STRINGS COMPLETOS
        "modificar_informacion" -> "Modifica tu informaci√≥n personal"
        "informacion_personal" -> "Informaci√≥n Personal"
        "nombre_completo" -> "Nombre completo"
        "correo_electronico" -> "Correo electr√≥nico"
        "actualizar_informacion" -> "Actualizar Informaci√≥n"
        "actualizando" -> "Actualizando..."
        "cambiar_contrasena_titulo" -> "Cambiar Contrase√±a"
        "cambiar_contrasena_descripcion" -> "Deja en blanco si no quieres cambiar la contrase√±a"
        "contrasena_actual" -> "Contrase√±a actual"
        "nueva_contrasena" -> "Nueva contrase√±a"
        "confirmar_nueva_contrasena" -> "Confirmar nueva contrase√±a"
        "cambiando" -> "Cambiando..."
        "cambiar_contrasena_btn" -> "Cambiar Contrase√±a"

        // Validaciones
        "nombre_vacio" -> "El nombre no puede estar vac√≠o"
        "email_invalido" -> "Email inv√°lido"
        "contrasena_actual_requerida" -> "Contrase√±a actual requerida"
        "contrasena_minimo_caracteres" -> "La contrase√±a debe tener al menos 6 caracteres"
        "contrasenas_no_coinciden" -> "Las contrase√±as no coinciden"

        // Mensajes de √©xito/error
        "informacion_actualizada" -> "‚úÖ Informaci√≥n actualizada correctamente"
        "contrasena_actualizada" -> "‚úÖ Contrase√±a actualizada correctamente"
        "error_actualizar_informacion" -> "‚ùå Error al actualizar la informaci√≥n"
        "error_cambiar_contrasena" -> "‚ùå Error al cambiar la contrase√±a"
        "error_generico" -> "‚ùå Error: {0}"

        // Botones y acciones
        "volver" -> "Volver"
        "ocultar_contrasena" -> "Ocultar contrase√±a"
        "mostrar_contrasena" -> "Mostrar contrase√±a"

        // Di√°logos
        "cambiar" -> "Cambiar"
        "cancelar" -> "Cancelar"
        "guardar" -> "Guardar"
        "aceptar" -> "Aceptar"
        "eliminar" -> "Eliminar"
        "contrasenas_no_coinciden_dialogo" -> "Las contrase√±as no coinciden"
        "contrasena_muy_corta" -> "La contrase√±a debe tener al menos 6 caracteres"

        // Mensajes
        "funcion_premium" -> "Esta funci√≥n est√° disponible solo en la versi√≥n Premium"
        "error_actualizacion" -> "Error al actualizar la configuraci√≥n"

        // ‚úÖ NUEVOS STRINGS PARA CATEGOR√çAS
        "add_categoria" -> "A√±adir categor√≠a"
        "nueva_categoria" -> "Nueva Categor√≠a"
        "editar_categoria" -> "Editar Categor√≠a"
        "nombre" -> "Nombre"
        "seleccionar_color" -> "Seleccionar color"
        "pulsa_crear_primera_categoria" -> "Pulsa + para crear tu primera categor√≠a"
        "eliminar_categoria" -> "Eliminar Categor√≠a"
        "confirmar_eliminar_categoria" -> "¬øSeguro que deseas eliminar \"{nombre}\"?"
        "categoria_creada" -> "Categor√≠a creada exitosamente"
        "categoria_actualizada" -> "Categor√≠a actualizada exitosamente"
        "categoria_eliminada" -> "Categor√≠a eliminada exitosamente"
        "error_crear_categoria" -> "Error al crear la categor√≠a"
        "error_actualizar_categoria" -> "Error al actualizar la categor√≠a"
        "error_eliminar_categoria" -> "Error al eliminar la categor√≠a"
        "nombre_categoria_requerido" -> "El nombre de la categor√≠a es requerido"
        "nombre_categoria_muy_corto" -> "El nombre debe tener al menos 2 caracteres"
        "nombre_categoria_muy_largo" -> "El nombre no puede tener m√°s de 50 caracteres"
        "categoria_nombre_duplicado" -> "Ya existe una categor√≠a con ese nombre"
        "color_invalido" -> "Color inv√°lido"
        "sincronizacion_completada" -> "Sincronizaci√≥n completada"
        "error_sincronizacion" -> "Error en sincronizaci√≥n"

        // Art√≠culos - Pantalla principal
        "articulos" -> "Art√≠culos"
        "add_articulo" -> "A√±adir art√≠culo"
        "nuevo_articulo" -> "Nuevo Art√≠culo"
        "editar_articulo" -> "Editar Art√≠culo"
        "pulsa_crear_primer_articulo" -> "Pulsa + para crear tu primer art√≠culo"
        "eliminar_articulo" -> "Eliminar Art√≠culo"
        "confirmar_eliminar_articulo" -> "¬øSeguro que deseas eliminar \"{nombre}\"?"

        // Campos del formulario
        "precio_venta" -> "Precio de venta"
        "precio_coste" -> "Precio de coste"
        "stock" -> "Stock"
        "categoria" -> "Categor√≠a"
        "seleccionar_categoria" -> "Seleccionar categor√≠a"
        "sin_categorias" -> "No hay categor√≠as disponibles"

        // Controles Premium
        "controlar_coste" -> "Controlar coste"
        "controlar_stock" -> "Controlar stock"
        "marcar_favorito" -> "Marcar como favorito"

        // Validaciones y mensajes
        "precio_venta_requerido" -> "El precio de venta es requerido"
        "precio_venta_invalido" -> "Precio de venta inv√°lido"
        "categoria_requerida" -> "Selecciona una categor√≠a"
        "articulo_creado" -> "Art√≠culo creado exitosamente"
        "articulo_actualizado" -> "Art√≠culo actualizado exitosamente"
        "articulo_eliminado" -> "Art√≠culo eliminado exitosamente"
        "error_crear_articulo" -> "Error al crear el art√≠culo"
        "error_actualizar_articulo" -> "Error al actualizar el art√≠culo"
        "error_eliminar_articulo" -> "Error al eliminar el art√≠culo"

        // Estados
        "sin_articulos" -> "No tienes art√≠culos registrados"
        "cargando_articulos" -> "Cargando art√≠culos..."
        "sincronizando_articulos" -> "Sincronizando art√≠culos..."

        // Premium
        "solo_premium_stock" -> "Control de stock disponible solo en Premium"
        "solo_premium_coste" -> "Control de coste disponible solo en Premium"

        // ‚úÖ AUTHENTICATION STRINGS PHASE 2
        "login_subtitle" -> "Inicia sesi√≥n en tu cuenta"
        "register_subtitle" -> "Crea tu nueva cuenta"
        "email" -> "Email"
        "email_placeholder" -> "tu@email.com"
        "email_invalid" -> "Email inv√°lido"
        "password" -> "Contrase√±a"
        "password_placeholder" -> "M√≠nimo 6 caracteres"
        "password_invalid" -> "M√≠nimo 6 caracteres requeridos"
        "login_button" -> "Iniciar Sesi√≥n"
        "register_button" -> "Crear Cuenta"
        "loading" -> "Cargando..."
        "or" -> "o"
        "go_to_register" -> "¬øNo tienes cuenta? Crear cuenta"
        "go_to_login" -> "¬øYa tienes cuenta? Iniciar sesi√≥n"
        "register_benefits_title" -> "üöÄ Beneficios de crear cuenta:"
        "benefit_1" -> "‚Ä¢ Sincronizaci√≥n autom√°tica en todos tus dispositivos"
        "benefit_2" -> "‚Ä¢ Configuraci√≥n personalizada guardada"
        "benefit_3" -> "‚Ä¢ Acceso a funciones Premium"
        "benefit_4" -> "‚Ä¢ Respaldo seguro de tus datos"
        "welcome" -> "Bienvenido"
        "premium_user" -> "Usuario Premium"
        "free_user" -> "Usuario Gratuito"
        "not_authenticated" -> "No autenticado"
        "home" -> "Inicio"
        "markets" -> "Mercadillos"
        "add_market" -> "A√±adir Mercadillo"
        "premium_features" -> "Funciones Premium"
        "upgrade_premium" -> "Actualizar a Premium"
        "about" -> "Acerca de"
        "logout" -> "Cerrar Sesi√≥n"
        "exit_app" -> "Salir de la App"
        "logout_title" -> "Cerrar Sesi√≥n"
        "logout_message" -> "¬øEst√°s seguro de que deseas cerrar sesi√≥n?"
        "logout_confirm" -> "Cerrar Sesi√≥n"
        "exit_title" -> "Salir de la App"
        "exit_message" -> "¬øEst√°s seguro de que deseas salir de Market Sales?"
        "exit_confirm" -> "Salir"
        "available_markets" -> "Mercadillos Disponibles"
        "premium_required" -> "Requiere Premium para acceso completo"
        "see_details" -> "Ver detalles"
        "edit" -> "Editar"
        "menu" -> "Men√∫"
        "premium" -> "Premium"
        "free" -> "Gratuito"

        // üöÄ GOOGLE AUTH V8 - NUEVOS STRINGS AGREGADOS
        "google_signin" -> "Continuar con Google"
        "google_register" -> "Registrarse con Google"
        "google_auth_error" -> "Error de autenticaci√≥n con Google"
        "google_token_error" -> "Error obteniendo token de Google"
        "auth_provider_google" -> "Google"
        "auth_provider_email" -> "Email"
        "google_signin_success" -> "Autenticaci√≥n con Google exitosa"
        "google_signin_failed" -> "Fall√≥ la autenticaci√≥n con Google"

        // ‚úÖ STRINGS PARA MERCADILLOS V11
        "add_mercadillo" -> "A√±adir mercadillo"
        "nuevo_mercadillo" -> "Nuevo Mercadillo"
        "editar_mercadillo" -> "Editar Mercadillo"
        "ver_leyenda" -> "Ver leyenda"
        "leyenda_estados" -> "Leyenda de Estados"
        "entendido" -> "Entendido"
        "proximo_mercadillo" -> "Pr√≥ximo Mercadillo"
        "sin_mercadillos" -> "No tienes mercadillos registrados"
        "pulsa_crear_primer_mercadillo" -> "Pulsa + para crear tu primer mercadillo"

        // Estados de mercadillos
        "estado_programado_parcial" -> "Programado parcialmente"
        "estado_programado_total" -> "Programado totalmente"
        "estado_en_curso" -> "En curso"
        "estado_pendiente_arqueo" -> "Terminado (pendiente arqueo)"
        "estado_pendiente_asignar_saldo" -> "Arqueo realizado (pendiente asignar saldo)"
        "estado_cerrado_completo" -> "Cerrado completamente"
        "estado_cancelado" -> "Cancelado"

        // Formulario de mercadillos
        "fecha_mercadillo" -> "Fecha del mercadillo"
        "lugar_mercadillo" -> "Lugar"
        "organizador_mercadillo" -> "Organizador"
        "hora_inicio" -> "Hora de inicio"
        "hora_fin" -> "Hora de fin"
        "es_gratis" -> "Es gratis"
        "importe_suscripcion" -> "Importe suscripci√≥n"
        "requiere_mesa" -> "Requiere mesa"
        "requiere_carpa" -> "Requiere carpa"
        "hay_punto_luz" -> "Hay punto de luz"

        // Validaciones mercadillos
        "fecha_requerida" -> "La fecha es requerida"
        "fecha_invalida" -> "Formato de fecha inv√°lido (dd-MM-yyyy)"
        "lugar_requerido" -> "El lugar es requerido"
        "lugar_muy_corto" -> "El lugar debe tener al menos 3 caracteres"
        "lugar_muy_largo" -> "El lugar no puede tener m√°s de 100 caracteres"
        "organizador_requerido" -> "El organizador es requerido"
        "organizador_muy_corto" -> "El organizador debe tener al menos 3 caracteres"
        "organizador_muy_largo" -> "El organizador no puede tener m√°s de 100 caracteres"
        "hora_inicio_invalida" -> "Formato de hora de inicio inv√°lido (HH:mm)"
        "hora_fin_invalida" -> "Formato de hora de fin inv√°lido (HH:mm)"
        "horarios_invalidos" -> "La hora de inicio debe ser anterior a la hora de fin"
        "importe_negativo" -> "El importe no puede ser negativo"
        "importe_muy_alto" -> "El importe es demasiado alto"
        "mercadillo_existe_fecha_hora" -> "Ya existe un mercadillo en esa fecha y hora"

        // Mensajes mercadillos
        "mercadillo_creado" -> "Mercadillo creado exitosamente"
        "mercadillo_actualizado" -> "Mercadillo actualizado exitosamente"
        "mercadillo_eliminado" -> "Mercadillo eliminado exitosamente"
        "mercadillo_cancelado" -> "Mercadillo cancelado exitosamente"
        "error_crear_mercadillo" -> "Error creando mercadillo"
        "error_actualizar_mercadillo" -> "Error actualizando mercadillo"
        "error_eliminar_mercadillo" -> "Error eliminando mercadillo"
        "error_cancelar_mercadillo" -> "Error cancelando mercadillo"

        // Saldos y arqueos
        "saldo_inicial" -> "Saldo inicial"
        "saldo_final" -> "Saldo final"
        "asignar_saldo_inicial" -> "Asignar saldo inicial"
        "asignar_automaticamente" -> "Asignar autom√°ticamente"
        "realizar_arqueo" -> "Realizar arqueo"
        "arqueo_caja" -> "Arqueo de caja"
        "saldo_asignado" -> "Saldo inicial asignado"
        "arqueo_realizado" -> "Arqueo de caja realizado exitosamente"
        "sin_saldo_anterior" -> "No hay mercadillos anteriores con saldo disponible"
        "saldo_negativo" -> "El saldo no puede ser negativo"
        "saldo_muy_alto" -> "El saldo es demasiado alto"

        // Confirmaciones
        "confirmar_eliminar_mercadillo" -> "¬øSeguro que deseas eliminar este mercadillo?"
        "confirmar_cancelar_mercadillo" -> "¬øSeguro que deseas cancelar este mercadillo?"
        "mercadillo_tiene_ventas" -> "No se puede cancelar: el mercadillo tiene ventas"
        "mercadillo_estado_no_valido" -> "No se puede cancelar: estado no v√°lido"

        "informacion_basica" -> "Informaci√≥n B√°sica"
        "horarios" -> "Horarios"
        "configuracion_mercadillo" -> "Configuraci√≥n"
        "crear_mercadillo" -> "Crear Mercadillo"
        "actualizar_mercadillo" -> "Actualizar Mercadillo"
        "guardando" -> "Guardando..."
        "saldo_inicial_ayuda" -> "Dinero disponible al inicio del mercadillo"
        "seleccionar_fecha" -> "Seleccionar fecha"
        "seleccionar_hora_inicio" -> "Seleccionar hora inicio"
        "seleccionar_hora_fin" -> "Seleccionar hora fin"

        // Validaciones espec√≠ficas para el formulario
        "fecha_no_puede_estar_vacia" -> "La fecha no puede estar vac√≠a"
        "lugar_no_puede_estar_vacio" -> "El lugar no puede estar vac√≠o"
        "organizador_no_puede_estar_vacio" -> "El organizador no puede estar vac√≠o"
        "formato_fecha_invalido" -> "Formato de fecha inv√°lido (dd-MM-yyyy)"
        "formato_hora_inicio_invalido" -> "Formato de hora de inicio inv√°lido (HH:mm)"
        "formato_hora_fin_invalido" -> "Formato de hora de fin inv√°lido (HH:mm)"
        "hora_inicio_debe_ser_anterior" -> "La hora de inicio debe ser anterior a la hora de fin"
        "lugar_minimo_caracteres" -> "El lugar debe tener al menos 3 caracteres"
        "lugar_maximo_caracteres" -> "El lugar no puede tener m√°s de 100 caracteres"
        "organizador_minimo_caracteres" -> "El organizador debe tener al menos 3 caracteres"
        "organizador_maximo_caracteres" -> "El organizador no puede tener m√°s de 100 caracteres"
        "importe_no_puede_ser_negativo" -> "El importe no puede ser negativo"
        "importe_demasiado_alto" -> "El importe es demasiado alto"
        "saldo_inicial_no_puede_ser_negativo" -> "El saldo inicial no puede ser negativo"
        "saldo_inicial_demasiado_alto" -> "El saldo inicial es demasiado alto"

        "seleccionar_hora" -> "Seleccionar hora"
        "opcional" -> "(opcional)"
        "lunes" -> "L"
        "martes" -> "M"
        "miercoles" -> "X"
        "jueves" -> "J"
        "viernes" -> "V"
        "sabado" -> "S"
        "domingo" -> "D"

        else -> key
    }

    /**
     * Strings en ingl√©s
     */
    private fun getEnglishString(key: String): String = when (key) {
        // Main screen
        "app_name" -> "Market Sales"
        "mercadillos" -> "Markets"
        "configuracion" -> "Settings"
        "articulos" -> "Articles"
        "categorias" -> "Categories"
        "inventario" -> "Inventory"
        "listados" -> "Reports"
        "iniciar_sesion" -> "Login"
        "cerrar_sesion" -> "Logout"
        "salir" -> "Exit"
        "perfil" -> "Profile"

        // Settings
        "informacion_cuenta" -> "Account Information"
        "cambiar_contrasena" -> "Change Password"
        "tema" -> "Theme"
        "fuente" -> "Font"
        "idioma" -> "Language"
        "moneda" -> "Currency"
        "version_premium" -> "PREMIUM"
        "version_free" -> "FREE"
        "promocion_premium" -> "Upgrade to Premium!"
        "desbloquea_funciones" -> "Unlock all features"

        // Theme
        "tema_claro" -> "Light"
        "tema_oscuro" -> "Dark"

        // Languages
        "espanol" -> "Espa√±ol"
        "ingles" -> "English"

        // Fonts
        "montserrat" -> "Montserrat"
        "poppins" -> "Poppins"
        "roboto" -> "Roboto"

        // Currencies
        "euro" -> "‚Ç¨ Euro"
        "dolar" -> "$ Dollar"
        "libra" -> "¬£ Pound"
        "yen" -> "¬• Yen"

        // ‚úÖ PROFILE SCREEN - COMPLETE STRINGS
        "modificar_informacion" -> "Change your personal information"
        "informacion_personal" -> "Personal Information"
        "nombre_completo" -> "Full name"
        "correo_electronico" -> "Email address"
        "actualizar_informacion" -> "Update Information"
        "actualizando" -> "Updating..."
        "cambiar_contrasena_titulo" -> "Change Password"
        "cambiar_contrasena_descripcion" -> "Leave blank if you don't want to change the password"
        "contrasena_actual" -> "Current password"
        "nueva_contrasena" -> "New password"
        "confirmar_nueva_contrasena" -> "Confirm new password"
        "cambiando" -> "Changing..."
        "cambiar_contrasena_btn" -> "Change Password"

        // Validations
        "nombre_vacio" -> "Name cannot be empty"
        "email_invalido" -> "Invalid email"
        "contrasena_actual_requerida" -> "Current password required"
        "contrasena_minimo_caracteres" -> "Password must be at least 6 characters"
        "contrasenas_no_coinciden" -> "Passwords don't match"

        // Success/Error messages
        "informacion_actualizada" -> "‚úÖ Information updated successfully"
        "contrasena_actualizada" -> "‚úÖ Password updated successfully"
        "error_actualizar_informacion" -> "‚ùå Error updating information"
        "error_cambiar_contrasena" -> "‚ùå Error changing password"
        "error_generico" -> "‚ùå Error: {0}"

        // Buttons and actions
        "volver" -> "Back"
        "ocultar_contrasena" -> "Hide password"
        "mostrar_contrasena" -> "Show password"

        // Dialogs
        "cambiar" -> "Change"
        "cancelar" -> "Cancel"
        "guardar" -> "Save"
        "aceptar" -> "Accept"
        "eliminar" -> "Delete"
        "contrasenas_no_coinciden_dialogo" -> "Passwords don't match"
        "contrasena_muy_corta" -> "Password must be at least 6 characters"

        // Messages
        "funcion_premium" -> "This feature is available only in Premium version"
        "error_actualizacion" -> "Error updating configuration"

        // ‚úÖ NEW STRINGS FOR CATEGORIES
        "add_categoria" -> "Add category"
        "nueva_categoria" -> "New Category"
        "editar_categoria" -> "Edit Category"
        "nombre" -> "Name"
        "seleccionar_color" -> "Select color"
        "pulsa_crear_primera_categoria" -> "Tap + to create your first category"
        "eliminar_categoria" -> "Delete Category"
        "confirmar_eliminar_categoria" -> "Are you sure you want to delete \"{nombre}\"?"
        "categoria_creada" -> "Category created successfully"
        "categoria_actualizada" -> "Category updated successfully"
        "categoria_eliminada" -> "Category deleted successfully"
        "error_crear_categoria" -> "Error creating category"
        "error_actualizar_categoria" -> "Error updating category"
        "error_eliminar_categoria" -> "Error deleting category"
        "nombre_categoria_requerido" -> "Category name is required"
        "nombre_categoria_muy_corto" -> "Name must be at least 2 characters"
        "nombre_categoria_muy_largo" -> "Name cannot be more than 50 characters"
        "categoria_nombre_duplicado" -> "A category with that name already exists"
        "color_invalido" -> "Invalid color"
        "sincronizacion_completada" -> "Synchronization completed"
        "error_sincronizacion" -> "Synchronization error"

        // Articles - Main screen
        "articulos" -> "Articles"
        "add_articulo" -> "Add article"
        "nuevo_articulo" -> "New Article"
        "editar_articulo" -> "Edit Article"
        "pulsa_crear_primer_articulo" -> "Tap + to create your first article"
        "eliminar_articulo" -> "Delete Article"
        "confirmar_eliminar_articulo" -> "Are you sure you want to delete \"{nombre}\"?"

        // Form fields
        "precio_venta" -> "Sale price"
        "precio_coste" -> "Cost price"
        "stock" -> "Stock"
        "categoria" -> "Category"
        "seleccionar_categoria" -> "Select category"
        "sin_categorias" -> "No categories available"

        // Premium controls
        "controlar_coste" -> "Control cost"
        "controlar_stock" -> "Control stock"
        "marcar_favorito" -> "Mark as favorite"

        // Validations and messages
        "precio_venta_requerido" -> "Sale price is required"
        "precio_venta_invalido" -> "Invalid sale price"
        "categoria_requerida" -> "Select a category"
        "articulo_creado" -> "Article created successfully"
        "articulo_actualizado" -> "Article updated successfully"
        "articulo_eliminado" -> "Article deleted successfully"
        "error_crear_articulo" -> "Error creating article"
        "error_actualizar_articulo" -> "Error updating article"
        "error_eliminar_articulo" -> "Error deleting article"

        // States
        "sin_articulos" -> "You have no registered articles"
        "cargando_articulos" -> "Loading articles..."
        "sincronizando_articulos" -> "Syncing articles..."

        // Premium
        "solo_premium_stock" -> "Stock control available only in Premium"
        "solo_premium_coste" -> "Cost control available only in Premium"


        // ‚úÖ AUTHENTICATION STRINGS PHASE 2
        "login_subtitle" -> "Sign in to your account"
        "register_subtitle" -> "Create your new account"
        "email" -> "Email"
        "email_placeholder" -> "your@email.com"
        "email_invalid" -> "Invalid email"
        "password" -> "Password"
        "password_placeholder" -> "Minimum 6 characters"
        "password_invalid" -> "Minimum 6 characters required"
        "login_button" -> "Sign In"
        "register_button" -> "Create Account"
        "loading" -> "Loading..."
        "or" -> "or"
        "go_to_register" -> "Don't have an account? Create account"
        "go_to_login" -> "Already have an account? Sign in"
        "register_benefits_title" -> "üöÄ Account benefits:"
        "benefit_1" -> "‚Ä¢ Automatic sync across all your devices"
        "benefit_2" -> "‚Ä¢ Personalized configuration saved"
        "benefit_3" -> "‚Ä¢ Access to Premium features"
        "benefit_4" -> "‚Ä¢ Secure data backup"
        "welcome" -> "Welcome"
        "premium_user" -> "Premium User"
        "free_user" -> "Free User"
        "not_authenticated" -> "Not authenticated"
        "home" -> "Home"
        "markets" -> "Markets"
        "add_market" -> "Add Market"
        "premium_features" -> "Premium Features"
        "upgrade_premium" -> "Upgrade to Premium"
        "about" -> "About"
        "logout" -> "Sign Out"
        "exit_app" -> "Exit App"
        "logout_title" -> "Sign Out"
        "logout_message" -> "Are you sure you want to sign out?"
        "logout_confirm" -> "Sign Out"
        "exit_title" -> "Exit App"
        "exit_message" -> "Are you sure you want to exit Market Sales?"
        "exit_confirm" -> "Exit"
        "available_markets" -> "Available Markets"
        "premium_required" -> "Requires Premium for full access"
        "see_details" -> "See details"
        "edit" -> "Edit"
        "menu" -> "Menu"
        "premium" -> "Premium"
        "free" -> "Free"

        // üöÄ GOOGLE AUTH V8 - NEW ENGLISH STRINGS
        "google_signin" -> "Continue with Google"
        "google_register" -> "Sign up with Google"
        "google_auth_error" -> "Google authentication error"
        "google_token_error" -> "Error getting Google token"
        "auth_provider_google" -> "Google"
        "auth_provider_email" -> "Email"
        "google_signin_success" -> "Google authentication successful"
        "google_signin_failed" -> "Google authentication failed"

        // ‚úÖ STRINGS PARA MERCADILLOS V11
        "add_mercadillo" -> "Add market"
        "nuevo_mercadillo" -> "New Market"
        "editar_mercadillo" -> "Edit Market"
        "ver_leyenda" -> "View legend"
        "leyenda_estados" -> "Status Legend"
        "entendido" -> "Understood"
        "proximo_mercadillo" -> "Next Market"
        "sin_mercadillos" -> "You have no registered markets"
        "pulsa_crear_primer_mercadillo" -> "Tap + to create your first market"

        // Market states
        "estado_programado_parcial" -> "Partially scheduled"
        "estado_programado_total" -> "Fully scheduled"
        "estado_en_curso" -> "In progress"
        "estado_pendiente_arqueo" -> "Finished (pending cash count)"
        "estado_pendiente_asignar_saldo" -> "Cash counted (pending balance assignment)"
        "estado_cerrado_completo" -> "Completely closed"
        "estado_cancelado" -> "Cancelled"

        // Market form
        "fecha_mercadillo" -> "Market date"
        "lugar_mercadillo" -> "Location"
        "organizador_mercadillo" -> "Organizer"
        "hora_inicio" -> "Start time"
        "hora_fin" -> "End time"
        "es_gratis" -> "Is free"
        "importe_suscripcion" -> "Subscription amount"
        "requiere_mesa" -> "Requires table"
        "requiere_carpa" -> "Requires tent"
        "hay_punto_luz" -> "Has power outlet"

        // Market validations
        "fecha_requerida" -> "Date is required"
        "fecha_invalida" -> "Invalid date format (dd-MM-yyyy)"
        "lugar_requerido" -> "Location is required"
        "lugar_muy_corto" -> "Location must be at least 3 characters"
        "lugar_muy_largo" -> "Location cannot be more than 100 characters"
        "organizador_requerido" -> "Organizer is required"
        "organizador_muy_corto" -> "Organizer must be at least 3 characters"
        "organizador_muy_largo" -> "Organizer cannot be more than 100 characters"
        "hora_inicio_invalida" -> "Invalid start time format (HH:mm)"
        "hora_fin_invalida" -> "Invalid end time format (HH:mm)"
        "horarios_invalidos" -> "Start time must be before end time"
        "importe_negativo" -> "Amount cannot be negative"
        "importe_muy_alto" -> "Amount is too high"
        "mercadillo_existe_fecha_hora" -> "A market already exists at that date and time"

        // Market messages
        "mercadillo_creado" -> "Market created successfully"
        "mercadillo_actualizado" -> "Market updated successfully"
        "mercadillo_eliminado" -> "Market deleted successfully"
        "mercadillo_cancelado" -> "Market cancelled successfully"
        "error_crear_mercadillo" -> "Error creating market"
        "error_actualizar_mercadillo" -> "Error updating market"
        "error_eliminar_mercadillo" -> "Error deleting market"
        "error_cancelar_mercadillo" -> "Error cancelling market"

        // Balances and cash counts
        "saldo_inicial" -> "Initial balance"
        "saldo_final" -> "Final balance"
        "asignar_saldo_inicial" -> "Assign initial balance"
        "asignar_automaticamente" -> "Assign automatically"
        "realizar_arqueo" -> "Perform cash count"
        "arqueo_caja" -> "Cash count"
        "saldo_asignado" -> "Initial balance assigned"
        "arqueo_realizado" -> "Cash count completed successfully"
        "sin_saldo_anterior" -> "No previous markets with available balance"
        "saldo_negativo" -> "Balance cannot be negative"
        "saldo_muy_alto" -> "Balance is too high"

        // Confirmations
        "confirmar_eliminar_mercadillo" -> "Are you sure you want to delete this market?"
        "confirmar_cancelar_mercadillo" -> "Are you sure you want to cancel this market?"
        "mercadillo_tiene_ventas" -> "Cannot cancel: market has sales"
        "mercadillo_estado_no_valido" -> "Cannot cancel: invalid status"

        "informacion_basica" -> "Basic Information"
        "horarios" -> "Schedule"
        "configuracion_mercadillo" -> "Market Configuration"
        "crear_mercadillo" -> "Create Market"
        "actualizar_mercadillo" -> "Update Market"
        "guardando" -> "Saving..."
        "saldo_inicial_ayuda" -> "Money available at the start of the market"
        "seleccionar_fecha" -> "Select date"
        "seleccionar_hora_inicio" -> "Select start time"
        "seleccionar_hora_fin" -> "Select end time"

        // English validations
        "fecha_no_puede_estar_vacia" -> "Date cannot be empty"
        "lugar_no_puede_estar_vacio" -> "Location cannot be empty"
        "organizador_no_puede_estar_vacio" -> "Organizer cannot be empty"
        "formato_fecha_invalido" -> "Invalid date format (dd-MM-yyyy)"
        "formato_hora_inicio_invalido" -> "Invalid start time format (HH:mm)"
        "formato_hora_fin_invalido" -> "Invalid end time format (HH:mm)"
        "hora_inicio_debe_ser_anterior" -> "Start time must be before end time"
        "lugar_minimo_caracteres" -> "Location must have at least 3 characters"
        "lugar_maximo_caracteres" -> "Location cannot have more than 100 characters"
        "organizador_minimo_caracteres" -> "Organizer must have at least 3 characters"
        "organizador_maximo_caracteres" -> "Organizer cannot have more than 100 characters"
        "importe_no_puede_ser_negativo" -> "Amount cannot be negative"
        "importe_demasiado_alto" -> "Amount is too high"
        "saldo_inicial_no_puede_ser_negativo" -> "Initial balance cannot be negative"
        "saldo_inicial_demasiado_alto" -> "Initial balance is too high"

        "seleccionar_hora" -> "Select time"
        "opcional" -> "(optional)"
        "lunes" -> "M"
        "martes" -> "T"
        "miercoles" -> "W"
        "jueves" -> "T"
        "viernes" -> "F"
        "sabado" -> "S"
        "domingo" -> "S"

        else -> key
    }
}



// app/src/main/java/es/nuskysoftware/marketsales/MainActivity.kt
package es.nuskysoftware.marketsales

import android.annotation.SuppressLint
import android.net.Uri
import android.os.Bundle
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavType
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import androidx.navigation.navArgument

import es.nuskysoftware.marketsales.ui.pantallas.PantallaConfiguracion
import es.nuskysoftware.marketsales.ui.pantallas.PantallaMercadillos
import es.nuskysoftware.marketsales.ui.pantallas.PantallaPerfil
import es.nuskysoftware.marketsales.ui.pantallas.PantallaSplash
import es.nuskysoftware.marketsales.ui.theme.MarketSalesTheme
import es.nuskysoftware.marketsales.ui.viewmodel.ConfiguracionViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.ConfiguracionViewModelFactory
import es.nuskysoftware.marketsales.ui.viewmodel.MercadilloViewModel
import es.nuskysoftware.marketsales.ui.viewmodel.MercadilloViewModelFactory
import es.nuskysoftware.marketsales.utils.ConfigurationManager
import es.nuskysoftware.marketsales.data.repository.ConfiguracionRepository
import es.nuskysoftware.marketsales.ui.pantallas.PantallaAltaMercadillo
import es.nuskysoftware.marketsales.ui.pantallas.PantallaArticulos
import es.nuskysoftware.marketsales.ui.pantallas.PantallaCambio
import es.nuskysoftware.marketsales.ui.pantallas.PantallaCategorias
import es.nuskysoftware.marketsales.ui.pantallas.PantallaEnviarRecibo
import es.nuskysoftware.marketsales.ui.pantallas.PantallaLogin
import es.nuskysoftware.marketsales.ui.pantallas.PantallaMetodoPago
import es.nuskysoftware.marketsales.ui.pantallas.PantallaResumenVentas
import es.nuskysoftware.marketsales.ui.pantallas.PantallaVentas
import es.nuskysoftware.marketsales.ui.pantallas.PantallaVentasCarrito


class MainActivity : ComponentActivity() {

    companion object { private const val TAG = "MainActivity" }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()

        Log.d(TAG, "üöÄ MainActivity iniciada")

        setContent {
            val configuracionRepository = ConfiguracionRepository(this@MainActivity)
            val configuracionViewModel: ConfiguracionViewModel = viewModel(
                factory = ConfiguracionViewModelFactory(configuracionRepository)
            )

            val isDarkTheme by ConfigurationManager.temaOscuro.collectAsState()

            MarketSalesTheme(configurationManager = ConfigurationManager) {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    NavigationSystem(configuracionViewModel)
                }
            }
        }
    }
}

@SuppressLint("UnrememberedGetBackStackEntry")
@Composable
fun NavigationSystem(
    configuracionViewModel: ConfiguracionViewModel
) {
    val navController = rememberNavController()
    var showSplash by remember { mutableStateOf(true) }

    LaunchedEffect(Unit) {
        kotlinx.coroutines.delay(2000)
        showSplash = false
    }

    if (showSplash) {
        PantallaSplash()
    } else {
        // üëâ Inicio SIEMPRE en "mercadillos". El login es opcional.
        NavHost(navController = navController, startDestination = "mercadillos") {

            // LISTA MERCADILLOS (home)
            composable("mercadillos") {
                PantallaMercadillos(navController)
            }

            // LOGIN (se entra solo si el usuario lo elige)
            composable("login") {
                PantallaLogin(
                    onNavigateToMain = {
                        // Volver a la pantalla desde la que se lleg√≥ (normalmente mercadillos)
                        navController.popBackStack()
                    }
                )
            }

            composable("configuracion") { PantallaConfiguracion(navController) }
            composable("perfil") { PantallaPerfil(navController = navController) }
            composable("categorias") { PantallaCategorias(navController = navController) }
            composable("articulos") { PantallaArticulos(navController = navController) }
            composable("alta_mercadillo") { PantallaAltaMercadillo(navController = navController) }

            composable(
                route = "editar_mercadillo/{mercadilloId}",
                arguments = listOf(navArgument("mercadilloId") { type = NavType.StringType })
            ) { backStackEntry ->
                val mercadilloId = backStackEntry.arguments?.getString("mercadilloId")
                PantallaAltaMercadillo(
                    navController = navController,
                    mercadilloId = mercadilloId
                )
            }

            // VENTAS
            composable(
                route = "ventas/{mercadilloId}",
                arguments = listOf(navArgument("mercadilloId") { type = NavType.StringType })
            ) { backStackEntry ->
                val mercadilloId = backStackEntry.arguments?.getString("mercadilloId")
                if (mercadilloId != null) {
                    PantallaVentasWrapper(
                        navController = navController,
                        mercadilloId = mercadilloId
                    )
                }
            }

            // M√âTODO DE PAGO
            composable(
                route = "metodo_pago/{mercadilloId}/{totalFmt}",
                arguments = listOf(
                    navArgument("mercadilloId") { type = NavType.StringType },
                    navArgument("totalFmt") { type = NavType.StringType }
                )
            ) { backStackEntry ->
                val mercadilloId = backStackEntry.arguments?.getString("mercadilloId") ?: ""
                val totalFmt = backStackEntry.arguments?.getString("totalFmt") ?: ""

                es.nuskysoftware.marketsales.ui.pantallas.PantallaMetodoPago(
                    totalFormateado = totalFmt,
                    onMetodoSeleccionado = { metodo ->
                        when (metodo) {
                            es.nuskysoftware.marketsales.ui.pantallas.MetodoPago.EFECTIVO -> {
                                navController.navigate(
                                    "cambio/${Uri.encode(mercadilloId)}/${Uri.encode(totalFmt)}"
                                )
                            }
                            es.nuskysoftware.marketsales.ui.pantallas.MetodoPago.BIZUM -> {
                                navController.navigate(
                                    "enviar_recibo/${Uri.encode(mercadilloId)}/${Uri.encode(totalFmt)}/bizum"
                                )
                            }
                            es.nuskysoftware.marketsales.ui.pantallas.MetodoPago.TARJETA -> {
                                navController.navigate(
                                    "enviar_recibo/${Uri.encode(mercadilloId)}/${Uri.encode(totalFmt)}/tarjeta"
                                )
                            }
                        }
                    },
                    onBack = { navController.popBackStack() }
                )
            }

            // CAMBIO (efectivo)
            composable(
                route = "cambio/{mercadilloId}/{totalFmt}",
                arguments = listOf(
                    navArgument("mercadilloId") { type = NavType.StringType },
                    navArgument("totalFmt") { type = NavType.StringType }
                )
            ) { backStackEntry ->
                val mercadilloId = backStackEntry.arguments?.getString("mercadilloId") ?: ""
                val totalFmt = backStackEntry.arguments?.getString("totalFmt") ?: ""
                es.nuskysoftware.marketsales.ui.pantallas.PantallaCambio(
                    totalFormateado = totalFmt,
                    onBack = { navController.popBackStack() },
                    onConfirmarCambio = {
                        navController.navigate(
                            "enviar_recibo/${Uri.encode(mercadilloId)}/${Uri.encode(totalFmt)}/efectivo"
                        )
                    }
                )
            }

            // ENVIAR RECIBO
            composable(
                route = "enviar_recibo/{mercadilloId}/{totalFmt}/{metodo}",
                arguments = listOf(
                    navArgument("mercadilloId") { type = NavType.StringType },
                    navArgument("totalFmt") { type = NavType.StringType },
                    navArgument("metodo") { type = NavType.StringType }
                )
            ) { backStackEntry ->
                val mercadilloId = backStackEntry.arguments?.getString("mercadilloId") ?: ""
                val totalFmt = backStackEntry.arguments?.getString("totalFmt") ?: ""
                val metodo = backStackEntry.arguments?.getString("metodo") ?: ""

                es.nuskysoftware.marketsales.ui.pantallas.PantallaEnviarRecibo(
                    totalFormateado = totalFmt,
                    metodo = metodo,
                    onBack = { navController.popBackStack() },
                    onEnviar = { /* TODO: env√≠o */ },
                    onFinalizarVenta = {
                        val ventasRoute = "ventas/$mercadilloId"
                        val ventasEntry = navController.getBackStackEntry(ventasRoute)
                        ventasEntry.savedStateHandle["finalizar_metodo"] = metodo
                        navController.popBackStack(route = ventasRoute, inclusive = false)
                    }
                )
            }

            // CARRITO
            composable(
                route = "carrito/{mercadilloId}",
                arguments = listOf(navArgument("mercadilloId"){ type = NavType.StringType })
            ) { backStackEntry ->
                val mercadilloId = backStackEntry.arguments?.getString("mercadilloId") ?: return@composable
                val parent = navController.getBackStackEntry("ventas/$mercadilloId")
                val context = LocalContext.current
                val ventasVM: es.nuskysoftware.marketsales.ui.viewmodel.VentasViewModel =
                    viewModel(parent, factory = es.nuskysoftware.marketsales.ui.viewmodel.VentasViewModelFactory(context))

                es.nuskysoftware.marketsales.ui.pantallas.PantallaVentasCarrito(
                    navController = navController,
                    ventasViewModel = ventasVM
                )
            }

            // RESUMEN
            composable(
                route = "resumen/{mercadilloId}",
                arguments = listOf(navArgument("mercadilloId") { type = NavType.StringType })
            ) { backStackEntry ->
                val mercadilloId = backStackEntry.arguments?.getString("mercadilloId") ?: return@composable
                es.nuskysoftware.marketsales.ui.pantallas.PantallaResumenVentas(
                    mercadilloId = mercadilloId,
                    onBack = { navController.popBackStack() }
                )
            }
        }
    }
}

@Composable
fun PantallaVentasWrapper(
    navController: androidx.navigation.NavController,
    mercadilloId: String
) {
    val context = LocalContext.current
    val mercadilloViewModel: MercadilloViewModel = viewModel(
        factory = MercadilloViewModelFactory(context)
    )

    LaunchedEffect(mercadilloId) {
        mercadilloViewModel.cargarMercadillo(mercadilloId)
    }

    val mercadilloParaEditar by mercadilloViewModel.mercadilloParaEditar.collectAsState()

    mercadilloParaEditar?.let { mercadillo ->
        es.nuskysoftware.marketsales.ui.pantallas.PantallaVentas(
            navController = navController,
            mercadilloActivo = mercadillo
        )
    }
}


// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    id("com.android.application") version "8.12.0" apply false
    id("org.jetbrains.kotlin.android") version "2.0.21" apply false
    id("org.jetbrains.kotlin.plugin.compose") version "2.0.21" apply false
    id("com.google.devtools.ksp") version "2.0.21-1.0.27"
    id("com.google.gms.google-services") version "4.4.3" apply false
}

plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
    id("org.jetbrains.kotlin.plugin.compose")
    id("com.google.devtools.ksp")
    id("com.google.gms.google-services")
    // deja kapt si lo necesitas realmente:
    id("kotlin-kapt")
}

android {
    namespace = "es.nuskysoftware.marketsales"
    compileSdk = 36

    defaultConfig {
        applicationId = "es.nuskysoftware.marketsales"
        minSdk = 24
        targetSdk = 36
        versionCode = 1
        versionName = "1.0"
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
        debug { }
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }
    kotlinOptions {
        jvmTarget = "11"
    }

    buildFeatures {
        compose = true
    }
}

dependencies {
    // ===== Compose BOM (versiona TODAS las libs de androidx.compose.*) =====
    implementation(platform(libs.androidx.compose.bom))

    // Compose UI (SIN versiones expl√≠citas)
    implementation(libs.androidx.ui)
    implementation(libs.androidx.ui.graphics)
    implementation(libs.androidx.ui.tooling.preview)
    implementation(libs.androidx.foundation)
    implementation(libs.androidx.material3)

    debugImplementation(libs.androidx.ui.tooling)
    debugImplementation(libs.androidx.ui.test.manifest)
    androidTestImplementation(platform(libs.androidx.compose.bom))
    androidTestImplementation(libs.androidx.ui.test.junit4)

    // ===== Tu stack existente =====
    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.lifecycle.runtime.ktx)
    implementation(libs.androidx.activity.compose)
    implementation(libs.androidx.navigation.compose)

    implementation(libs.androidx.room.runtime)
    ksp(libs.androidx.room.compiler)

    // (mant√©n tus otras dependencias tal cual)
    implementation("com.github.skydoves:colorpicker-compose:1.1.2")
    implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.8.4")
    implementation("androidx.room:room-ktx:2.7.1")

    // Firebase BOM + artefactos (si ya los usabas as√≠)
    implementation(platform("com.google.firebase:firebase-bom:33.3.0"))
    implementation("com.google.firebase:firebase-firestore")
    implementation("com.google.firebase:firebase-auth:22.3.0")
    // (ten√≠as tambi√©n una segunda firestore con 24.9.1; conserva solo una l√≠nea para evitar duplicados)
    // implementation("com.google.firebase:firebase-firestore:24.9.1")

    implementation("androidx.work:work-runtime-ktx:2.9.0")

    // Google Auth / Credentials
    implementation("com.google.android.gms:play-services-auth:20.7.0")
    implementation("androidx.credentials:credentials:1.3.0")
    implementation("androidx.credentials:credentials-play-services-auth:1.3.0")
    implementation("com.google.android.libraries.identity.googleid:googleid:1.1.1")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-play-services:1.7.3")

    // Dependencias que dejaste duplicadas con otras versiones:
    implementation("androidx.room:room-ktx:2.6.0")
    implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0")
    implementation("androidx.compose.material:material-icons-extended:1.5.4")
    implementation("com.github.skydoves:colorpicker-compose:1.0.5")

    // Tests
    testImplementation(libs.junit)
    androidTestImplementation(libs.androidx.junit)
    androidTestImplementation(libs.androidx.espresso.core)
}



/*
IMPORTANTE:
- Quita cualquier dependencia a:
    "androidx.compose.material:material-pull-refresh"
  y elimina los imports antiguos:
    androidx.compose.material.pullrefresh.*
- Usa SIEMPRE los nuevos imports de Material 3:
    androidx.compose.material3.pulltorefresh.*
*/


//plugins {
//    id("com.android.application")
//    id("org.jetbrains.kotlin.android")
//    id("org.jetbrains.kotlin.plugin.compose")
//    id("com.google.devtools.ksp")
//    id("com.google.gms.google-services")
//    id ("kotlin-kapt")
//}
//
//android {
//    namespace = "es.nuskysoftware.marketsales"
//    compileSdk = 36
//
//    defaultConfig {
//        applicationId = "es.nuskysoftware.marketsales"
//        minSdk = 24
//        targetSdk = 36
//        versionCode = 1
//        versionName = "1.0"
//        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
//    }
//
//    buildTypes {
//        release {
//            isMinifyEnabled = false
//            proguardFiles(
//                getDefaultProguardFile("proguard-android-optimize.txt"),
//                "proguard-rules.pro"
//            )
//        }
//    }
//
//    compileOptions {
//        sourceCompatibility = JavaVersion.VERSION_11
//        targetCompatibility = JavaVersion.VERSION_11
//    }
//
//    kotlinOptions {
//        jvmTarget = "11"
//    }
//
//    buildFeatures {
//        compose = true
//    }
//}
//
//dependencies {
//    implementation(libs.androidx.core.ktx)
//    implementation(libs.androidx.lifecycle.runtime.ktx)
//    implementation(libs.androidx.activity.compose)
//    implementation(platform(libs.androidx.compose.bom))
//    implementation(libs.androidx.ui)
//    implementation(libs.androidx.ui.graphics)
//    implementation(libs.androidx.ui.tooling.preview)
//    implementation(libs.androidx.material3)
//    implementation(libs.androidx.navigation.compose)
//    implementation(libs.androidx.room.runtime)
//    implementation(libs.androidx.foundation)
//    implementation(libs.material3)
//
//
//    testImplementation(libs.junit)
//    androidTestImplementation(libs.androidx.junit)
//    androidTestImplementation(libs.androidx.espresso.core)
//    androidTestImplementation(platform(libs.androidx.compose.bom))
//    androidTestImplementation(libs.androidx.ui.test.junit4)
//    debugImplementation(libs.androidx.ui.tooling)
//    debugImplementation(libs.androidx.ui.test.manifest)
//    ksp(libs.androidx.room.compiler)
//
//    implementation("com.github.skydoves:colorpicker-compose:1.1.2")
//
//    implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.8.4")
//
//    implementation("androidx.room:room-ktx:2.7.1")
//
//    // ‚úÖ Firebase BOM (maneja versiones autom√°ticamente)
//    implementation(platform("com.google.firebase:firebase-bom:33.3.0"))
//    implementation("com.google.firebase:firebase-firestore")
//
//    implementation("androidx.work:work-runtime-ktx:2.9.0")
//
//    // ‚úÖ FIREBASE AUTH PARA FASE 2
//    implementation("com.google.firebase:firebase-auth:22.3.0")
//    implementation("com.google.firebase:firebase-firestore:24.9.1")
//
//    // ‚úÖ GOOGLE AUTH V8 - NUEVAS DEPENDENCIAS AGREGADAS
//    implementation("com.google.android.gms:play-services-auth:20.7.0")
//    implementation("androidx.credentials:credentials:1.3.0")
//    implementation("androidx.credentials:credentials-play-services-auth:1.3.0")
//    implementation("com.google.android.libraries.identity.googleid:googleid:1.1.1")
//    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-play-services:1.7.3")
//
//    // ‚úÖ AGREGADO SOLO LO NECESARIO PARA FASE 2:
//    implementation("androidx.room:room-ktx:2.6.0")
//    implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0")
//    implementation("androidx.compose.material:material-icons-extended:1.5.4")
//
//    implementation("com.github.skydoves:colorpicker-compose:1.0.5")
//}


[versions]
kotlin = "2.0.21"
agp = "8.12.0"

# Compose BOM: controla TODAS las libs de androidx.compose.*
composeBom = "2025.07.00"

# Mantengo el resto como los ten√≠as
coreKtx = "1.16.0"
junit = "4.13.2"
junitVersion = "1.2.1"
espressoCore = "3.6.1"
lifecycleRuntimeKtx = "2.9.2"
activityCompose = "1.10.1"
navigationCompose = "2.9.2"
navigationComposeJvmstubs = "2.9.2"
ksp = "2.0.21-1.0.27"
roomRuntime = "2.7.2"
roomCompiler = "2.7.2"
firebaseFirestoreKtx = "26.0.0"
colorpickerCompose = "1.1.2"
hiltAndroid = "2.57"

[libraries]
# BOM de Compose
androidx-compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "composeBom" }

# Compose (SIN versi√≥n expl√≠cita: las fija la BOM)
androidx-ui = { group = "androidx.compose.ui", name = "ui" }
androidx-ui-graphics = { group = "androidx.compose.ui", name = "ui-graphics" }
androidx-ui-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
androidx-ui-tooling-preview = { group = "androidx.compose.ui", name = "ui-tooling-preview" }
androidx-ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }
androidx-ui-test-junit4 = { group = "androidx.compose.ui", name = "ui-test-junit4" }
androidx-foundation = { group = "androidx.compose.foundation", name = "foundation" }
androidx-material3 = { group = "androidx.compose.material3", name = "material3" }

# Core / Lifecycle / Activity / Navigation
androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
androidx-lifecycle-runtime-ktx = { group = "androidx.lifecycle", name = "lifecycle-runtime-ktx", version.ref = "lifecycleRuntimeKtx" }
androidx-activity-compose = { group = "androidx.activity", name = "activity-compose", version.ref = "activityCompose" }
androidx-navigation-compose = { module = "androidx.navigation:navigation-compose", version.ref = "navigationCompose" }
androidx-navigation-compose-jvmstubs = { group = "androidx.navigation", name = "navigation-compose-jvmstubs", version.ref = "navigationComposeJvmstubs" }

# Room
androidx-room-runtime = { module = "androidx.room:room-runtime", version.ref = "roomRuntime" }
androidx-room-compiler = { group = "androidx.room", name = "room-compiler", version.ref = "roomCompiler" }

# Firebase (si usas el artefacto KTX directo)
firebase-firestore-ktx = { group = "com.google.firebase", name = "firebase-firestore-ktx", version.ref = "firebaseFirestoreKtx" }

# Otras libs tuyas
colorpicker-compose = { module = "com.github.skydoves:colorpicker-compose", version.ref = "colorpickerCompose" }
hilt-android = { module = "com.google.dagger:hilt-android", version.ref = "hiltAndroid" }

# Test
junit = { group = "junit", name = "junit", version.ref = "junit" }
androidx-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
androidx-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }

[plugins]
android-application = { id = "com.android.application", version.ref = "agp" }
kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
kotlin-compose = { id = "org.jetbrains.kotlin.plugin.compose", version.ref = "kotlin" }
ksp = { id = "com.google.devtools.ksp", version.ref = "ksp" }
google-services = { id = "com.google.gms.google-services", version = "4.4.3" }

